(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{1064:function(e,t,n){"use strict";n.d(t,"a",(function(){return Fe})),n.d(t,"b",(function(){return bu})),n.d(t,"c",(function(){return yu})),n.d(t,"d",(function(){return Be}));var r=n(1065),o=n(906),l=n(971),h=function(e,t){return(h=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n])})(e,t)};function c(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");function n(){this.constructor=e}h(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}var d=function(){return(d=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var i in t=arguments[n])Object.prototype.hasOwnProperty.call(t,i)&&(e[i]=t[i]);return e}).apply(this,arguments)};function f(e,t,n,r){return new(n||(n=Promise))((function(i,s){function o(e){try{u(r.next(e))}catch(e){s(e)}}function a(e){try{u(r.throw(e))}catch(e){s(e)}}function u(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(o,a)}u((r=r.apply(e,t||[])).next())}))}function m(e,t){var n,r,i,s,o={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return s={next:a(0),throw:a(1),return:a(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function a(s){return function(a){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,r&&(i=2&s[0]?r.return:s[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,s[1])).done)return i;switch(r=0,i&&(s=[2&s[0],i.value]),s[0]){case 0:case 1:i=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,r=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!((i=(i=o.trys).length>0&&i[i.length-1])||6!==s[0]&&2!==s[0])){o=0;continue}if(3===s[0]&&(!i||s[1]>i[0]&&s[1]<i[3])){o.label=s[1];break}if(6===s[0]&&o.label<i[1]){o.label=i[1],i=s;break}if(i&&o.label<i[2]){o.label=i[2],o.ops.push(s);break}i[2]&&o.ops.pop(),o.trys.pop();continue}s=t.call(e,o)}catch(e){s=[6,e],r=0}finally{n=i=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,a])}}}function y(e,t,n){if(n||2===arguments.length)for(var r,i=0,s=t.length;i<s;i++)!r&&i in t||(r||(r=Array.prototype.slice.call(t,0,i)),r[i]=t[i]);return e.concat(r||Array.prototype.slice.call(t))}var x=["nose","left_eye","right_eye","left_ear","right_ear","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle"],v=["nose","left_eye_inner","left_eye","left_eye_outer","right_eye_inner","right_eye","right_eye_outer","left_ear","right_ear","mouth_left","mouth_right","left_shoulder","right_shoulder","left_elbow","right_elbow","left_wrist","right_wrist","left_pinky","right_pinky","left_index","right_index","left_thumb","right_thumb","left_hip","right_hip","left_knee","right_knee","left_ankle","right_ankle","left_heel","right_heel","left_foot_index","right_foot_index"],w={left:[1,2,3,7,9,11,13,15,17,19,21,23,25,27,29,31],right:[4,5,6,8,10,12,14,16,18,20,22,24,26,28,30,32],middle:[0]},k={left:[1,3,5,7,9,11,13,15],right:[2,4,6,8,10,12,14,16],middle:[0]},S=[[0,1],[0,2],[1,3],[2,4],[5,6],[5,7],[5,11],[6,8],[6,12],[7,9],[8,10],[11,12],[11,13],[12,14],[13,15],[14,16]],I=[[0,1],[0,4],[1,2],[2,3],[3,7],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[11,23],[12,14],[14,16],[12,24],[13,15],[15,17],[16,18],[16,20],[15,17],[15,19],[15,21],[16,22],[17,19],[18,20],[23,25],[23,24],[24,26],[25,27],[26,28],[27,29],[28,30],[27,31],[28,32],[29,31],[30,32]];function C(e){return e instanceof SVGAnimatedLength?e.baseVal.value:e}function O(e){return f(this,void 0,void 0,(function(){var t,i;return m(this,(function(s){switch(s.label){case 0:return t=document.createElement("canvas"),e instanceof o.Cc?[4,o.Rc.toPixels(e,t)]:[3,2];case 1:return s.sent(),[3,3];case 2:t.width=C(e.width),t.height=C(e.height),i=t.getContext("2d"),e instanceof ImageData?i.putImageData(e,0,0):i.drawImage(e,0,0),s.label=3;case 3:return[2,t]}}))}))}function A(e){return f(this,void 0,void 0,(function(){var t,i,s,n,a,u;return m(this,(function(r){switch(r.label){case 0:return e instanceof o.Cc?(t=e.shape.slice(0,2),i=t[0],s=t[1],n=ImageData.bind,[4,o.Rc.toPixels(e)]):[3,2];case 1:return[2,new(n.apply(ImageData,[void 0,r.sent(),s,i]))];case 2:return a=document.createElement("canvas"),u=a.getContext("2d"),a.width=C(e.width),a.height=C(e.height),u.drawImage(e,0,0),[2,u.getImageData(0,0,a.width,a.height)]}}))}))}function T(e){return f(this,void 0,void 0,(function(){var t,n;return m(this,(function(i){switch(i.label){case 0:return e instanceof SVGImageElement||e instanceof OffscreenCanvas?[4,O(e)]:[3,2];case 1:return n=i.sent(),[3,3];case 2:n=e,i.label=3;case 3:return t=n,[2,o.Rc.fromPixels(t,4)]}}))}))}function E(e){if(e<0||e>=256)throw new Error("Mask value must be in range [0, 255] but got ".concat(e));if(!Number.isInteger(e))throw new Error("Mask value must be an integer but got ".concat(e))}var R={runtime:"mediapipe",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,modelType:"full"},P=function(){function e(e){this.mask=e}return e.prototype.toCanvasImageSource=function(){return f(this,void 0,void 0,(function(){return m(this,(function(e){return[2,this.mask]}))}))},e.prototype.toImageData=function(){return f(this,void 0,void 0,(function(){return m(this,(function(e){return[2,A(this.mask)]}))}))},e.prototype.toTensor=function(){return f(this,void 0,void 0,(function(){return m(this,(function(e){return[2,T(this.mask)]}))}))},e.prototype.getUnderlyingType=function(){return"canvasimagesource"},e}();function $(e){return E(e),"person"}var F=function(){function e(e){var t,n=this;switch(this.width=0,this.height=0,this.selfieMode=!1,this.poseSolution=new r.Pose({locateFile:function(t,n){if(e.solutionPath){var r=e.solutionPath.replace(/\/+$/,"");return"".concat(r,"/").concat(t)}return"".concat(n,"/").concat(t)}}),e.modelType){case"lite":t=0;break;case"heavy":t=2;break;default:t=1}this.poseSolution.setOptions({modelComplexity:t,smoothLandmarks:e.enableSmoothing,enableSegmentation:e.enableSegmentation,smoothSegmentation:e.smoothSegmentation,selfieMode:this.selfieMode}),this.poseSolution.onResults((function(e){if(n.height=e.image.height,n.width=e.image.width,null==e.poseLandmarks)n.poses=[];else{var t=n.translateOutput(e.poseLandmarks,e.poseWorldLandmarks);e.segmentationMask&&(t.segmentation={maskValueToLabel:$,mask:new P(e.segmentationMask)}),n.poses=[t]}}))}return e.prototype.translateOutput=function(e,t){var n=this,r={keypoints:e.map((function(e,t){return{x:e.x*n.width,y:e.y*n.height,z:e.z,score:e.visibility,name:v[t]}}))};return null!=t&&(r.keypoints3D=t.map((function(e,t){return{x:e.x,y:e.y,z:e.z,score:e.visibility,name:v[t]}}))),r},e.prototype.estimatePoses=function(e,t,i){return f(this,void 0,void 0,(function(){var s,n;return m(this,(function(a){switch(a.label){case 0:return t&&t.flipHorizontal&&t.flipHorizontal!==this.selfieMode&&(this.selfieMode=t.flipHorizontal,this.poseSolution.setOptions({selfieMode:this.selfieMode})),e instanceof o.Cc?(n=ImageData.bind,[4,o.Rc.toPixels(e)]):[3,2];case 1:return s=new(n.apply(ImageData,[void 0,a.sent(),e.shape[1],e.shape[0]])),[3,3];case 2:s=e,a.label=3;case 3:return e=s,[4,this.poseSolution.send({image:e},i)];case 4:return a.sent(),[2,this.poses]}}))}))},e.prototype.dispose=function(){this.poseSolution.close()},e.prototype.reset=function(){this.poseSolution.reset()},e.prototype.initialize=function(){return this.poseSolution.initialize()},e}();function _(e){return f(this,void 0,void 0,(function(){var t,n;return m(this,(function(r){switch(r.label){case 0:return t=function(e){if(null==e)return d({},R);var t=d({},e);return t.runtime="mediapipe",null==t.enableSegmentation&&(t.enableSegmentation=R.enableSegmentation),null==t.enableSmoothing&&(t.enableSmoothing=R.enableSmoothing),null==t.smoothSegmentation&&(t.smoothSegmentation=R.smoothSegmentation),null==t.modelType&&(t.modelType=R.modelType),t}(e),[4,(n=new F(t)).initialize()];case 1:return r.sent(),[2,n]}}))}))}function N(e){return e instanceof o.Cc?{height:e.shape[0],width:e.shape[1]}:{height:e.height,width:e.width}}function z(e){return e-2*Math.PI*Math.floor((e+Math.PI)/(2*Math.PI))}function M(e){return e instanceof o.Cc?e:o.Rc.fromPixels(e)}function L(e,t,n){return B(n,"inputResolution"),[1/n.width*e[0][0]*t.width,1/n.height*e[0][1]*t.width,e[0][3]*t.width,1/n.width*e[1][0]*t.height,1/n.height*e[1][1]*t.height,e[1][3]*t.height,0,0]}function B(e,t){o.Ed.assert(0!==e.width,(function(){return"".concat(t," width cannot be 0.")})),o.Ed.assert(0!==e.height,(function(){return"".concat(t," height cannot be 0.")}))}function U(e,t,n){var r=n.rotationVectorStartKeypointIndex,i=n.rotationVectorEndKeypointIndex,s=e.locationData,o=s.relativeKeypoints[r].x*t.width,a=s.relativeKeypoints[r].y*t.height,u=s.relativeKeypoints[i].x*t.width,l=s.relativeKeypoints[i].y*t.height,h=2*Math.sqrt((u-o)*(u-o)+(l-a)*(l-a)),c=function(e,t,n){var r,i=e.locationData,s=n.rotationVectorStartKeypointIndex,o=n.rotationVectorEndKeypointIndex;r=n.rotationVectorTargetAngle?n.rotationVectorTargetAngle:Math.PI*n.rotationVectorTargetAngleDegree/180;var a=i.relativeKeypoints[s].x*t.width,u=i.relativeKeypoints[s].y*t.height,l=i.relativeKeypoints[o].x*t.width,h=i.relativeKeypoints[o].y*t.height;return z(r-Math.atan2(-(h-u),l-a))}(e,t,n);return{xCenter:o/t.width,yCenter:a/t.height,width:h/t.width,height:h/t.height,rotation:c}}function D(e){if(16!==e.length)throw new Error("Array length must be 16 but got ".concat(e.length));return[[e[0],e[1],e[2],e[3]],[e[4],e[5],e[6],e[7]],[e[8],e[9],e[10],e[11]],[e[12],e[13],e[14],e[15]]]}function j(e,t,n,r,i,s,o){return e[t][i]*(e[n][s]*e[r][o]-e[n][o]*e[r][s])}function W(e,t,n){var r=(t+1)%4,i=(t+2)%4,s=(t+3)%4,o=(n+1)%4,a=(n+2)%4,u=(n+3)%4;return j(e,r,i,s,o,a,u)+j(e,i,s,r,o,a,u)+j(e,s,r,i,o,a,u)}function V(e,t,n){void 0===n&&(n={ignoreRotation:!1});for(var r=[],i=0,s=e;i<s.length;i++){var o=s[i],a=o.x-.5,u=o.y-.5,l=n.ignoreRotation?0:t.rotation,h=Math.cos(l)*a-Math.sin(l)*u,c=Math.sin(l)*a+Math.cos(l)*u;h=h*t.width+t.xCenter,c=c*t.height+t.yCenter;var f=o.z*t.width,p=d({},o);p.x=h,p.y=c,p.z=f,r.push(p)}return r}function tr(e,t){var n=function(e,t,n,r){var o=(r-n)/255;return{scale:o,offset:n-0*o}}(0,0,t[0],t[1]);return Object(o.Bd)((function(){return Object(o.Lc)(Object(o.kd)(e,n.scale),n.offset)}))}function G(e,t,n){var r,s,l,h,p,c,g,d,f,b,m,y,x=t.outputTensorSize,v=t.keepAspectRatio,w=t.borderMode,k=t.outputTensorFloatRange,S=N(e),I=function(e,t){return t?{xCenter:t.xCenter*e.width,yCenter:t.yCenter*e.height,width:t.width*e.width,height:t.height*e.height,rotation:t.rotation}:{xCenter:.5*e.width,yCenter:.5*e.height,width:e.width,height:e.height,rotation:0}}(S,n),C=function(e,t,n){if(void 0===n&&(n=!1),!n)return{top:0,left:0,right:0,bottom:0};var r=t.height,i=t.width;B(t,"targetSize"),B(e,"roi");var s,o,a=r/i,u=e.height/e.width,l=0,h=0;return a>u?(s=e.width,o=e.width*a,h=(1-u/a)/2):(s=e.height/a,o=e.height,l=(1-a/u)/2),e.width=s,e.height=o,{top:h,left:l,right:l,bottom:h}}(I,x,v),O=(r=I,s=S.width,l=S.height,!1,h=r.width,p=r.height,1,c=Math.cos(r.rotation),g=Math.sin(r.rotation),d=r.xCenter,f=r.yCenter,b=1/s,m=1/l,(y=new Array(16))[0]=h*c*1*b,y[1]=-p*g*b,y[2]=0,y[3]=(-.5*h*c*1+.5*p*g+d)*b,y[4]=h*g*1*m,y[5]=p*c*m,y[6]=0,y[7]=(-.5*p*c-.5*h*g*1+f)*m,y[8]=0,y[9]=0,y[10]=h*b,y[11]=0,y[12]=0,y[13]=0,y[14]=0,y[15]=1,D(y));return{imageTensor:Object(o.Bd)((function(){var t=M(e),n=Object(o.Ad)(L(O,S,x),[1,8]),r="zero"===w?"constant":"nearest",i=o.ed.transform(Object(o.cd)(Object(o.Tc)(t,"float32")),n,"bilinear",r,0,[x.height,x.width]);return null!=k?tr(i,k):i})),padding:C,transformationMatrix:O}}function H(e,t,n,r){return 1===r?.5*(e+t):e+(t-e)*n/(r-1)}function K(e){return null!=e&&null!=e.currentTime}function X(e){for(var t={locationData:{relativeKeypoints:[]}},n=Number.MAX_SAFE_INTEGER,r=Number.MIN_SAFE_INTEGER,i=Number.MAX_SAFE_INTEGER,s=Number.MIN_SAFE_INTEGER,o=0;o<e.length;++o){var a=e[o];n=Math.min(n,a.x),r=Math.max(r,a.x),i=Math.min(i,a.y),s=Math.max(s,a.y),t.locationData.relativeKeypoints.push({x:a.x,y:a.y})}return t.locationData.relativeBoundingBox={xMin:n,yMin:i,xMax:r,yMax:s,width:r-n,height:s-i},t}function Y(e,t,n,r){return f(this,void 0,void 0,(function(){var r,i,s,l,h;return m(this,(function(c){switch(c.label){case 0:return e.sort((function(e,t){return Math.max.apply(Math,t.score)-Math.max.apply(Math,e.score)})),r=Object(o.Ad)(e.map((function(e){return[e.locationData.relativeBoundingBox.yMin,e.locationData.relativeBoundingBox.xMin,e.locationData.relativeBoundingBox.yMax,e.locationData.relativeBoundingBox.xMax]}))),i=Object(o.zd)(e.map((function(e){return e.score[0]}))),[4,o.ed.nonMaxSuppressionAsync(r,i,t,n)];case 1:return[4,(s=c.sent()).array()];case 2:return l=c.sent(),h=e.filter((function(e,t){return l.indexOf(t)>-1})),Object(o.Xc)([r,i,s]),[2,h]}}))}))}function Q(e,t){return e.map((function(e){var n=d(d({},e),{x:e.x*t.width,y:e.y*t.height});return null!=e.z&&(n.z=e.z*t.width),n}))}function Z(e,t,n){return f(this,void 0,void 0,(function(){var r,i,s,l,a,u,h,c,f,p,y,x,g,v,w,b,k,S,I,C,O,A,T,E;return m(this,(function(m){switch(m.label){case 0:if(r=Object(o.ud)(t,[0]),i=r.shape,s=i[0],l=i[1],a=i[2],e.length!==a)throw new Error("Expected heatmap to have same number of channels as the number of landmarks. But got landmarks length: "+"".concat(e.length,", heatmap length: ").concat(a));return u=[],[4,r.buffer()];case 1:for(h=m.sent(),c=0;c<e.length;c++)if(f=e[c],p=d({},f),u.push(p),y=Math.trunc(p.x*l),x=Math.trunc(p.y*s),!(y<0||y>=l||x<0||y>=s)){for(g=Math.trunc((n.kernelSize-1)/2),v=Math.max(0,y-g),w=Math.min(l,y+g+1),b=Math.max(0,x-g),k=Math.min(s,x+g+1),S=0,I=0,C=0,O=0,A=b;A<k;++A)for(T=v;T<w;++T)E=h.get(A,T,c),S+=E,O=Math.max(O,E),I+=T*E,C+=A*E;O>=n.minConfidenceToRefine&&S>0&&(p.x=I/l/S,p.y=C/s/S)}return r.dispose(),[2,u]}}))}))}function hr(e,t){var n=t.left,r=t.top,i=t.left+t.right,s=t.top+t.bottom;return e.map((function(e){return d(d({},e),{x:(e.x-n)/(1-i),y:(e.y-r)/(1-s),z:e.z/(1-i)})}))}function J(e,t,n){return f(this,void 0,void 0,(function(){var r,a,u,l,h;return m(this,(function(c){switch(c.label){case 0:return r=e[0],a=e[1],u=function(e,t,n){return Object(o.Bd)((function(){var r,i,a,u;n.reverseOutputOrder?(i=Object(o.ud)(Object(o.rd)(e,[0,n.boxCoordOffset+0],[-1,1])),r=Object(o.ud)(Object(o.rd)(e,[0,n.boxCoordOffset+1],[-1,1])),u=Object(o.ud)(Object(o.rd)(e,[0,n.boxCoordOffset+2],[-1,1])),a=Object(o.ud)(Object(o.rd)(e,[0,n.boxCoordOffset+3],[-1,1]))):(r=Object(o.ud)(Object(o.rd)(e,[0,n.boxCoordOffset+0],[-1,1])),i=Object(o.ud)(Object(o.rd)(e,[0,n.boxCoordOffset+1],[-1,1])),a=Object(o.ud)(Object(o.rd)(e,[0,n.boxCoordOffset+2],[-1,1])),u=Object(o.ud)(Object(o.rd)(e,[0,n.boxCoordOffset+3],[-1,1]))),i=Object(o.Lc)(Object(o.kd)(Object(o.Yc)(i,n.xScale),t.w),t.x),r=Object(o.Lc)(Object(o.kd)(Object(o.Yc)(r,n.yScale),t.h),t.y),n.applyExponentialOnBoxSize?(a=Object(o.kd)(Object(o.bd)(Object(o.Yc)(a,n.hScale)),t.h),u=Object(o.kd)(Object(o.bd)(Object(o.Yc)(u,n.wScale)),t.w)):(a=Object(o.kd)(Object(o.Yc)(a,n.hScale),t.h),u=Object(o.kd)(Object(o.Yc)(u,n.wScale),t.h));var l=Object(o.wd)(r,Object(o.Yc)(a,2)),h=Object(o.wd)(i,Object(o.Yc)(u,2)),p=Object(o.Lc)(r,Object(o.Yc)(a,2)),c=Object(o.Lc)(i,Object(o.Yc)(u,2)),d=Object(o.Wc)([Object(o.od)(l,[n.numBoxes,1]),Object(o.od)(h,[n.numBoxes,1]),Object(o.od)(p,[n.numBoxes,1]),Object(o.od)(c,[n.numBoxes,1])],1);if(n.numKeypoints)for(var g=0;g<n.numKeypoints;++g){var f=n.keypointCoordOffset+g*n.numValuesPerKeypoint,b=void 0,m=void 0;n.reverseOutputOrder?(b=Object(o.ud)(Object(o.rd)(e,[0,f],[-1,1])),m=Object(o.ud)(Object(o.rd)(e,[0,f+1],[-1,1]))):(m=Object(o.ud)(Object(o.rd)(e,[0,f],[-1,1])),b=Object(o.ud)(Object(o.rd)(e,[0,f+1],[-1,1])));var y=Object(o.Lc)(Object(o.kd)(Object(o.Yc)(b,n.xScale),t.w),t.x),x=Object(o.Lc)(Object(o.kd)(Object(o.Yc)(m,n.yScale),t.h),t.y);d=Object(o.Wc)([d,Object(o.od)(y,[n.numBoxes,1]),Object(o.od)(x,[n.numBoxes,1])],1)}return d}))}(a,t,n),l=Object(o.Bd)((function(){var e=r;return n.sigmoidScore?(null!=n.scoreClippingThresh&&(e=Object(o.Uc)(r,-n.scoreClippingThresh,n.scoreClippingThresh)),e=Object(o.qd)(e)):e})),[4,ee(u,l,n)];case 1:return h=c.sent(),Object(o.Xc)([u,l]),[2,h]}}))}))}function ee(e,t,n){return f(this,void 0,void 0,(function(){var r,i,s,o,a,u,l,h,c,d,p,f;return m(this,(function(m){switch(m.label){case 0:return r=[],[4,e.data()];case 1:return i=m.sent(),[4,t.data()];case 2:for(s=m.sent(),o=0;o<n.numBoxes;++o)if(!(null!=n.minScoreThresh&&s[o]<n.minScoreThresh||(a=o*n.numCoords,u=te(i[a+0],i[a+1],i[a+2],i[a+3],s[o],n.flipVertically,o),(l=u.locationData.relativeBoundingBox).width<0||l.height<0))){if(n.numKeypoints>0)for((h=u.locationData).relativeKeypoints=[],c=n.numKeypoints*n.numValuesPerKeypoint,d=0;d<c;d+=n.numValuesPerKeypoint)p=a+n.keypointCoordOffset+d,f={x:i[p+0],y:n.flipVertically?1-i[p+1]:i[p+1]},h.relativeKeypoints.push(f);r.push(u)}return[2,r]}}))}))}function te(e,t,n,r,i,s,o){return{score:[i],ind:o,locationData:{relativeBoundingBox:{xMin:t,yMin:s?1-n:e,xMax:r,yMax:s?1-e:n,width:r-t,height:n-e}}}}function ne(e,t){return"none"===e?t:function(e){return 1/(1+Math.exp(-e))}(t)}function re(e,t,n,r){return f(this,void 0,void 0,(function(){var i,s,o,a,u,l,h,c;return m(this,(function(d){switch(d.label){case 0:return n=n||t.flipHorizontally||!1,r=r||t.flipVertically||!1,i=e.size,s=i/t.numLandmarks,[4,e.data()];case 1:for(o=d.sent(),a=[],u=0;u<t.numLandmarks;++u)l=u*s,(c={x:0,y:0}).x=n?t.inputImageWidth-o[l]:o[l],s>1&&(c.y=r?t.inputImageHeight-o[l+1]:o[l+1]),s>2&&(c.z=o[l+2]),s>3&&(c.score=ne(t.visibilityActivation,o[l+3])),a.push(c);for(h=0;h<a.length;++h)(c=a[h]).x=c.x/t.inputImageWidth,c.y=c.y/t.inputImageHeight,c.z=c.z/t.inputImageWidth/(t.normalizeZ||1);return[2,a]}}))}))}function ie(e,t,n){var r=e.width,i=e.height,s=e.rotation;if(null==n.rotation&&null==n.rotationDegree||(s=function(e,t){return null!=t.rotation?e+=t.rotation:null!=t.rotationDegree&&(e+=Math.PI*t.rotationDegree/180),z(e)}(s,n)),0===s)e.xCenter=e.xCenter+r*n.shiftX,e.yCenter=e.yCenter+i*n.shiftY;else{var o=(t.width*r*n.shiftX*Math.cos(s)-t.height*i*n.shiftY*Math.sin(s))/t.width,a=(t.width*r*n.shiftX*Math.sin(s)+t.height*i*n.shiftY*Math.cos(s))/t.height;e.xCenter=e.xCenter+o,e.yCenter=e.yCenter+a}if(n.squareLong){var u=Math.max(r*t.width,i*t.height);r=u/t.width,i=u/t.height}else if(n.squareShort){var l=Math.min(r*t.width,i*t.height);r=l/t.width,i=l/t.height}return e.width=r*n.scaleX,e.height=i*n.scaleY,e}function oe(e,t){return e.map((function(e){var n=d(d({},e),{x:e.x/t.width,y:e.y/t.height});return null!=e.z&&(e.z=e.z/t.width),n}))}var br=function(){function e(e){this.alpha=e,this.initialized=!1}return e.prototype.apply=function(e,t){var n;return this.initialized?n=null==t?this.storedValue+this.alpha*(e-this.storedValue):this.storedValue+this.alpha*t*Math.asinh((e-this.storedValue)/t):(n=e,this.initialized=!0),this.rawValue=e,this.storedValue=n,n},e.prototype.applyWithAlpha=function(e,t,n){return this.alpha=t,this.apply(e,n)},e.prototype.hasLastRawValue=function(){return this.initialized},e.prototype.lastRawValue=function(){return this.rawValue},e.prototype.reset=function(){this.initialized=!1},e}(),ae=function(){function e(e){this.frequency=e.frequency,this.minCutOff=e.minCutOff,this.beta=e.beta,this.thresholdCutOff=e.thresholdCutOff,this.thresholdBeta=e.thresholdBeta,this.derivateCutOff=e.derivateCutOff,this.x=new br(this.getAlpha(this.minCutOff)),this.dx=new br(this.getAlpha(this.derivateCutOff)),this.lastTimestamp=0}return e.prototype.apply=function(e,t,n){if(null==e)return e;var r=Math.trunc(t);if(this.lastTimestamp>=r)return e;0!==this.lastTimestamp&&0!==r&&(this.frequency=1/(1e-6*(r-this.lastTimestamp))),this.lastTimestamp=r;var i=this.x.hasLastRawValue()?(e-this.x.lastRawValue())*n*this.frequency:0,s=this.dx.applyWithAlpha(i,this.getAlpha(this.derivateCutOff)),o=this.minCutOff+this.beta*Math.abs(s),a=null!=this.thresholdCutOff?this.thresholdCutOff+this.thresholdBeta*Math.abs(s):null;return this.x.applyWithAlpha(e,this.getAlpha(o),a)},e.prototype.getAlpha=function(e){return 1/(1+this.frequency/(2*Math.PI*e))},e}(),se=function(){function e(e){this.config=e}return e.prototype.apply=function(e,t,n){var r=this;if(null==e)return this.reset(),null;this.initializeFiltersIfEmpty(e);var i=1;if(!this.config.disableValueScaling){if(n<this.config.minAllowedObjectScale)return y([],e,!0);i=1/n}return e.map((function(e,n){var s=d(d({},e),{x:r.xFilters[n].apply(e.x,t,i),y:r.yFilters[n].apply(e.y,t,i)});return null!=e.z&&(s.z=r.zFilters[n].apply(e.z,t,i)),s}))},e.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},e.prototype.initializeFiltersIfEmpty=function(e){var t=this;null!=this.xFilters&&this.xFilters.length===e.length||(this.xFilters=e.map((function(e){return new ae(t.config)})),this.yFilters=e.map((function(e){return new ae(t.config)})),this.zFilters=e.map((function(e){return new ae(t.config)})))},e}(),ue=function(){function e(e){this.config=e,this.window=[],this.lowPassFilter=new br(1),this.lastValue=0,this.lastValueScale=1,this.lastTimestamp=-1}return e.prototype.apply=function(e,t,n){if(null==e)return e;var r,i=Math.trunc(t);if(this.lastTimestamp>=i)return e;if(-1===this.lastTimestamp)r=1;else{for(var s=e*n-this.lastValue*this.lastValueScale,o=i-this.lastTimestamp,a=s,u=o,l=(1+this.window.length)*(1e6/30),h=0,c=this.window;h<c.length;h++){var d=c[h];if(u+d.duration>l)break;a+=d.distance,u+=d.duration}var p=a/(1e-6*u);r=1-1/(1+this.config.velocityScale*Math.abs(p)),this.window.unshift({distance:s,duration:o}),this.window.length>this.config.windowSize&&this.window.pop()}return this.lastValue=e,this.lastValueScale=n,this.lastTimestamp=i,this.lowPassFilter.applyWithAlpha(e,r)},e}(),le=function(){function e(e){this.config=e}return e.prototype.apply=function(e,t,n){var r=this;if(null==e)return this.reset(),null;var i=1;if(!this.config.disableValueScaling){if(n<this.config.minAllowedObjectScale)return y([],e,!0);i=1/n}return this.initializeFiltersIfEmpty(e),e.map((function(e,n){var s=d(d({},e),{x:r.xFilters[n].apply(e.x,t,i),y:r.yFilters[n].apply(e.y,t,i)});return null!=e.z&&(s.z=r.zFilters[n].apply(e.z,t,i)),s}))},e.prototype.reset=function(){this.xFilters=null,this.yFilters=null,this.zFilters=null},e.prototype.initializeFiltersIfEmpty=function(e){var t=this;null!=this.xFilters&&this.xFilters.length===e.length||(this.xFilters=e.map((function(e){return new ue(t.config)})),this.yFilters=e.map((function(e){return new ue(t.config)})),this.zFilters=e.map((function(e){return new ue(t.config)})))},e}(),he=function(){function e(e){if(null!=e.velocityFilter)this.keypointsFilter=new le(e.velocityFilter);else{if(null==e.oneEuroFilter)throw new Error("Either configure velocityFilter or oneEuroFilter, but got "+"".concat(e,"."));this.keypointsFilter=new se(e.oneEuroFilter)}}return e.prototype.apply=function(e,t,n,r,i){if(void 0===r&&(r=!1),null==e)return this.keypointsFilter.reset(),null;var s=null!=i?function(e,t){return(e.width*t.width+e.height*t.height)/2}(i,n):1,o=r?Q(e,n):e,a=this.keypointsFilter.apply(o,t,s);return r?oe(a,n):a},e}(),ce=function(){function e(e){this.alpha=e.alpha}return e.prototype.apply=function(e){var t=this;if(null==e)return this.visibilityFilters=null,null;null!=this.visibilityFilters&&this.visibilityFilters.length===e.length||(this.visibilityFilters=e.map((function(e){return new br(t.alpha)})));for(var n=[],r=0;r<e.length;++r){var i=e[r],s=d({},i);s.score=this.visibilityFilters[r].apply(i.score),n.push(s)}return n},e}(),de={reduceBoxesInLowestlayer:!1,interpolatedScaleAspectRatio:1,featureMapHeight:[],featureMapWidth:[],numLayers:5,minScale:.1484375,maxScale:.75,inputSizeHeight:224,inputSizeWidth:224,anchorOffsetX:.5,anchorOffsetY:.5,strides:[8,16,32,32,32],aspectRatios:[1],fixedAnchorSize:!0},pe={runtime:"tfjs",modelType:"full",enableSmoothing:!0,enableSegmentation:!1,smoothSegmentation:!0,detectorModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/detector/1",landmarkModelUrl:"https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"},fe={maxPoses:1,flipHorizontal:!1},me={applyExponentialOnBoxSize:!1,flipVertically:!1,ignoreClasses:[],numClasses:1,numBoxes:2254,numCoords:12,boxCoordOffset:0,keypointCoordOffset:4,numKeypoints:4,numValuesPerKeypoint:2,sigmoidScore:!0,scoreClippingThresh:100,reverseOutputOrder:!0,xScale:224,yScale:224,hScale:224,wScale:224,minScoreThresh:.5},ge={shiftX:0,shiftY:0,scaleX:1.25,scaleY:1.25,squareLong:!0},be={outputTensorSize:{width:224,height:224},keepAspectRatio:!0,outputTensorFloatRange:[-1,1],borderMode:"zero"},ye={outputTensorSize:{width:256,height:256},keepAspectRatio:!0,outputTensorFloatRange:[0,1],borderMode:"zero"},xe={numLandmarks:39,inputImageWidth:256,inputImageHeight:256,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},ve={numLandmarks:39,inputImageWidth:1,inputImageHeight:1,visibilityActivation:"sigmoid",flipHorizontally:!1,flipVertically:!1},we={kernelSize:7,minConfidenceToRefine:.5},ke={alpha:.1},Se={oneEuroFilter:{frequency:30,minCutOff:.05,beta:80,derivateCutOff:1,minAllowedObjectScale:1e-6}},Ie={oneEuroFilter:{frequency:30,minCutOff:.01,beta:10,derivateCutOff:1,minAllowedObjectScale:1e-6}},Ce={oneEuroFilter:{frequency:30,minCutOff:.1,beta:40,derivateCutOff:1,minAllowedObjectScale:1e-6,disableValueScaling:!0}},Oe={activation:"none"},Ae={combineWithPreviousRatio:.7},Te=function(){function e(e){this.mask=e}return e.prototype.toCanvasImageSource=function(){return f(this,void 0,void 0,(function(){return m(this,(function(e){return[2,O(this.mask)]}))}))},e.prototype.toImageData=function(){return f(this,void 0,void 0,(function(){return m(this,(function(e){return[2,A(this.mask)]}))}))},e.prototype.toTensor=function(){return f(this,void 0,void 0,(function(){return m(this,(function(e){return[2,this.mask]}))}))},e.prototype.getUnderlyingType=function(){return"tensor"},e}();function Ee(e){return E(e),"person"}var Re=function(){function e(e,t,n,r,i,s){this.detectorModel=e,this.landmarkModel=t,this.enableSmoothing=n,this.enableSegmentation=r,this.smoothSegmentation=i,this.modelType=s,this.regionOfInterest=null,this.prevFilteredSegmentationMask=null,this.anchors=function(e){null==e.reduceBoxesInLowestLayer&&(e.reduceBoxesInLowestLayer=!1),null==e.interpolatedScaleAspectRatio&&(e.interpolatedScaleAspectRatio=1),null==e.fixedAnchorSize&&(e.fixedAnchorSize=!1);for(var t=[],n=0;n<e.numLayers;){for(var r=[],i=[],s=[],o=[],a=n;a<e.strides.length&&e.strides[a]===e.strides[n];){var u=H(e.minScale,e.maxScale,a,e.strides.length);if(0===a&&e.reduceBoxesInLowestLayer)s.push(1),s.push(2),s.push(.5),o.push(.1),o.push(u),o.push(u);else{for(var l=0;l<e.aspectRatios.length;++l)s.push(e.aspectRatios[l]),o.push(u);if(e.interpolatedScaleAspectRatio>0){var h=a===e.strides.length-1?1:H(e.minScale,e.maxScale,a+1,e.strides.length);o.push(Math.sqrt(u*h)),s.push(e.interpolatedScaleAspectRatio)}}a++}for(var c=0;c<s.length;++c){var d=Math.sqrt(s[c]);r.push(o[c]/d),i.push(o[c]*d)}var p=0,f=0;if(e.featureMapHeight.length>0)p=e.featureMapHeight[n],f=e.featureMapWidth[n];else{var m=e.strides[n];p=Math.ceil(e.inputSizeHeight/m),f=Math.ceil(e.inputSizeWidth/m)}for(var g=0;g<p;++g)for(var y=0;y<f;++y)for(var x=0;x<r.length;++x){var b={xCenter:(y+e.anchorOffsetX)/f,yCenter:(g+e.anchorOffsetY)/p,width:0,height:0};e.fixedAnchorSize?(b.width=1,b.height=1):(b.width=i[x],b.height=r[x]),t.push(b)}n=a}return t}(de);var l=Object(o.zd)(this.anchors.map((function(e){return e.width}))),u=Object(o.zd)(this.anchors.map((function(e){return e.height}))),h=Object(o.zd)(this.anchors.map((function(e){return e.xCenter}))),c=Object(o.zd)(this.anchors.map((function(e){return e.yCenter})));this.anchorTensor={x:h,y:c,w:l,h:u},this.prevFilteredSegmentationMask=this.enableSegmentation?Object(o.Ad)([],[0,0]):null}return e.prototype.estimatePoses=function(e,t,n){return f(this,void 0,void 0,(function(){var r,s,l,a,u,h,c,f,y,g,x,w,b,k,S,I,C,O,A,T,E,R,P;return m(this,(function(m){switch(m.label){case 0:return r=function(e){var t;if(null==(t=null==e?fe:d({},e)).maxPoses&&(t.maxPoses=1),t.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(t.maxPoses,". Should be > 0."));if(t.maxPoses>1)throw new Error("Multi-pose detection is not implemented yet. Please set maxPoses to 1.");return t}(t),null==e?(this.reset(),[2,[]]):(this.maxPoses=r.maxPoses,this.timestamp=null!=n?1e3*n:K(e)?1e6*e.currentTime:null,s=N(e),l=Object(o.Bd)((function(){return Object(o.Tc)(M(e),"float32")})),null!=(a=this.regionOfInterest)?[3,2]:[4,this.detectPose(l)]);case 1:if(0===(u=m.sent()).length)return this.reset(),l.dispose(),[2,[]];h=u[0],a=this.poseDetectionToRoi(h,s),m.label=2;case 2:return[4,this.poseLandmarksByRoi(a,l)];case 3:return c=m.sent(),l.dispose(),null==c?(this.reset(),[2,[]]):(f=c.landmarks,y=c.auxiliaryLandmarks,g=c.poseScore,x=c.worldLandmarks,w=c.segmentationMask,b=this.poseLandmarkFiltering(f,y,x,s),k=b.actualLandmarksFiltered,S=b.auxiliaryLandmarksFiltered,I=b.actualWorldLandmarksFiltered,C=this.poseLandmarksToRoi(S,s),this.regionOfInterest=C,O=this.smoothSegmentation&&null!=w?this.poseSegmentationFiltering(w):w,null!=(A=null!=k?Q(k,s):null)&&A.forEach((function(e,t){e.name=v[t]})),null!=(T=I)&&T.forEach((function(e,t){e.name=v[t]})),E={score:g,keypoints:A,keypoints3D:T},null!==O&&(R=Object(o.Bd)((function(){var e=Object(o.cd)(O,2),t=Object(o.ld)(e,[[0,0],[0,0],[0,1]]);return Object(o.jd)(t,[[0,0],[0,0],[0,2]],"symmetric")})),this.smoothSegmentation||Object(o.Xc)(O),P={maskValueToLabel:Ee,mask:new Te(R)},E.segmentation=P),[2,[E]])}}))}))},e.prototype.poseSegmentationFiltering=function(e){var t=this.prevFilteredSegmentationMask;return 0===t.size?this.prevFilteredSegmentationMask=e:(this.prevFilteredSegmentationMask=function(e,t,n){return"webgl"===Object(o.dd)()?function(e,t,n){var r=n.combineWithPreviousRatio.toFixed(2),s={variableNames:["prevMask","newMask"],outputShape:e.shape,userCode:"\n  void main() {\n      ivec2 coords = getOutputCoords();\n      int height = coords[0];\n      int width = coords[1];\n\n      float prevMaskValue = getPrevMask(height, width);\n      float newMaskValue = getNewMask(height, width);\n\n      /*\n      * Assume p := newMaskValue\n      * H(p) := 1 + (p * log(p) + (1-p) * log(1-p)) / log(2)\n      * uncertainty alpha(p) =\n      *   Clamp(1 - (1 - H(p)) * (1 - H(p)), 0, 1) [squaring the\n      * uncertainty]\n      *\n      * The following polynomial approximates uncertainty alpha as a\n      * function of (p + 0.5):\n      */\n      const float c1 = 5.68842;\n      const float c2 = -0.748699;\n      const float c3 = -57.8051;\n      const float c4 = 291.309;\n      const float c5 = -624.717;\n      float t = newMaskValue - 0.5;\n      float x = t * t;\n\n      float uncertainty =\n        1.0 - min(1.0, x * (c1 + x * (c2 + x * (c3 + x * (c4 + x * c5)))));\n\n      float outputValue = newMaskValue + (prevMaskValue - newMaskValue) *\n                             (uncertainty * ".concat(r,");\n\n      setOutput(outputValue);\n    }\n")},l=Object(o.Nc)();return Object(o.Bd)((function(){var n=l.compileAndRun(s,[e,t]);return Object(o.Zc)().makeTensorFromDataId(n.dataId,n.shape,n.dtype)}))}(e,t,n):Object(o.Bd)((function(){var r=Object(o.wd)(t,.5),i=Object(o.td)(r),a=Object(o.wd)(1,Object(o.id)(1,Object(o.kd)(i,Object(o.Lc)(5.68842,Object(o.kd)(i,Object(o.Lc)(-.748699,Object(o.kd)(i,Object(o.Lc)(-57.8051,Object(o.kd)(i,Object(o.Lc)(291.309,Object(o.kd)(i,-624.717)))))))))));return Object(o.Lc)(t,Object(o.kd)(Object(o.wd)(e,t),Object(o.kd)(a,n.combineWithPreviousRatio)))}))}(t,e,Ae),Object(o.Xc)(e)),Object(o.Xc)(t),this.prevFilteredSegmentationMask},e.prototype.dispose=function(){this.detectorModel.dispose(),this.landmarkModel.dispose(),Object(o.Xc)([this.anchorTensor.x,this.anchorTensor.y,this.anchorTensor.w,this.anchorTensor.h,this.prevFilteredSegmentationMask])},e.prototype.reset=function(){this.regionOfInterest=null,this.enableSegmentation&&(Object(o.Xc)(this.prevFilteredSegmentationMask),this.prevFilteredSegmentationMask=Object(o.Ad)([],[0,0])),this.visibilitySmoothingFilterActual=null,this.visibilitySmoothingFilterAuxiliary=null,this.landmarksSmoothingFilterActual=null,this.landmarksSmoothingFilterAuxiliary=null},e.prototype.detectPose=function(e){return f(this,void 0,void 0,(function(){var t,n,r,i,s,l,a,u,h,c;return m(this,(function(d){switch(d.label){case 0:return t=G(e,be),n=t.imageTensor,r=t.padding,i=this.detectorModel.predict(n),s=function(e){return Object(o.Bd)((function(){var t=function(e){return Object(o.Bd)((function(){return[Object(o.rd)(e,[0,0,0],[1,-1,1]),Object(o.rd)(e,[0,0,1],[1,-1,-1])]}))}(e),n=t[0],r=t[1];return{boxes:Object(o.ud)(r),logits:Object(o.ud)(n)}}))}(i),l=s.boxes,[4,J([a=s.logits,l],this.anchorTensor,me)];case 1:return 0===(u=d.sent()).length?(Object(o.Xc)([n,i,a,l]),[2,u]):[4,Y(u,this.maxPoses,.3)];case 2:return h=d.sent(),c=function(e,t){void 0===e&&(e=[]);for(var n=t.left,r=t.top,i=t.left+t.right,s=t.top+t.bottom,o=0;o<e.length;o++){var a=e[o],u=a.locationData.relativeBoundingBox,l=(u.xMin-n)/(1-i),h=(u.yMin-r)/(1-s),c=u.width/(1-i),d=u.height/(1-s);u.xMin=l,u.yMin=h,u.width=c,u.height=d,u.xMax=l+c,u.yMax=h+d;var p=a.locationData.relativeKeypoints;p&&p.forEach((function(e){var t=(e.x-n)/(1-i),o=(e.y-r)/(1-s);e.x=t,e.y=o}))}return e}(h,r),Object(o.Xc)([n,i,a,l]),[2,c]}}))}))},e.prototype.poseDetectionToRoi=function(e,t){return ie(U(e,t,{rotationVectorEndKeypointIndex:1,rotationVectorStartKeypointIndex:0,rotationVectorTargetAngleDegree:90}),t,ge)},e.prototype.poseLandmarksByRoi=function(e,t){return f(this,void 0,void 0,(function(){var n,r,i,s,l,a,u,h,c,f,y,x,v,g;return m(this,(function(m){switch(m.label){case 0:if(n=N(t),r=G(t,ye,e),i=r.imageTensor,s=r.padding,l=r.transformationMatrix,"lite"!==this.modelType&&"full"!==this.modelType&&"heavy"!==this.modelType)throw new Error("Model type must be one of lite, full or heavy,"+"but got ".concat(this.modelType));return a=["ld_3d","output_poseflag","activation_heatmap","world_3d"],this.enableSegmentation&&a.push("activation_segmentation"),u=this.landmarkModel.execute(i,a),[4,this.tensorsToPoseLandmarksAndSegmentation(u)];case 1:return null==(h=m.sent())?(Object(o.Xc)(u),Object(o.Xc)(i),[2,null]):(c=h.landmarks,f=h.auxiliaryLandmarks,y=h.poseScore,x=h.worldLandmarks,v=h.segmentationMask,[4,this.poseLandmarksAndSegmentationInverseProjection(n,e,s,l,c,f,x,v)]);case 2:return g=m.sent(),Object(o.Xc)(u),Object(o.Xc)(i),[2,d({poseScore:y},g)]}}))}))},e.prototype.poseLandmarksAndSegmentationInverseProjection=function(e,t,n,r,s,l,h,c){return f(this,void 0,void 0,(function(){var f,y,x,g,v,w;return m(this,(function(b){return f=hr(s,n),y=hr(l,n),x=V(f,t),g=V(y,t),v=function(e,t){for(var n=[],r=0,i=e;r<i.length;r++){var s=i[r],o=s.x,a=s.y,u=t.rotation,l=Math.cos(u)*o-Math.sin(u)*a,h=Math.sin(u)*o+Math.cos(u)*a,c=d({},s);c.x=l,c.y=h,n.push(c)}return n}(h,t),w=null,this.enableSegmentation&&(w=Object(o.Bd)((function(){var t=c.shape,n=t[0],i=t[1],s=function(e){var t=D(new Array(16).fill(0));t[0][0]=W(e,0,0),t[1][0]=-W(e,0,1),t[2][0]=W(e,0,2),t[3][0]=-W(e,0,3),t[0][2]=W(e,2,0),t[1][2]=-W(e,2,1),t[2][2]=W(e,2,2),t[3][2]=-W(e,2,3),t[0][1]=-W(e,1,0),t[1][1]=W(e,1,1),t[2][1]=-W(e,1,2),t[3][1]=W(e,1,3),t[0][3]=-W(e,3,0),t[1][3]=W(e,3,1),t[2][3]=-W(e,3,2),t[3][3]=W(e,3,3);for(var n=e[0][0]*t[0][0]+e[1][0]*t[0][1]+e[2][0]*t[0][2]+e[3][0]*t[0][3],r=0;r<t.length;r++)for(var i=0;i<t.length;i++)t[r][i]/=n;return t}(r),l=Object(o.Ad)(L(s,{width:i,height:n},e),[1,8]),h=[1,n,i,1];return Object(o.ud)(o.ed.transform(Object(o.od)(c,h),l,"bilinear","constant",0,[e.height,e.width]),[0,3])})),Object(o.Xc)(c)),[2,{landmarks:x,auxiliaryLandmarks:g,worldLandmarks:v,segmentationMask:w}]}))}))},e.prototype.tensorsToPoseLandmarksAndSegmentation=function(e){return f(this,void 0,void 0,(function(){var t,n,r,s,l,a,h,c,f,p,y,x,g;return m(this,(function(m){switch(m.label){case 0:return t=e[0],n=e[1],r=e[2],s=e[3],l=this.enableSegmentation?e[4]:null,[4,n.data()];case 1:return(a=m.sent()[0])<.5?[2,null]:[4,re(t,xe)];case 2:return[4,Z(m.sent(),r,we)];case 3:return h=m.sent(),c=h.slice(0,33),f=h.slice(33,35),[4,re(s,ve)];case 4:return p=m.sent(),y=p.slice(0,33),x=function(e,t,n){void 0===n&&(n=!0);for(var r=[],i=0;i<e.length;i++){var s=d({},t[i]);n&&(s.score=e[i].score),r.push(s)}return r}(c,y,!0),g=this.enableSegmentation?function(e,t,n){return Object(o.Bd)((function(){var n=Object(o.ud)(e,[0]),i=n.shape[2];if(1===i){var s=n;switch(t.activation){case"none":break;case"sigmoid":s=Object(o.qd)(s);break;case"softmax":throw new Error("Softmax activation requires two channels.");default:throw new Error("Activation not supported (".concat(t.activation,")"))}var r=s;return Object(o.ud)(r,[2])}throw new Error("Unsupported number of tensor channels ".concat(i))}))}(l,Oe):null,[2,{landmarks:c,auxiliaryLandmarks:f,poseScore:a,worldLandmarks:x,segmentationMask:g}]}}))}))},e.prototype.poseLandmarksToRoi=function(e,t){return ie(U(X(e),t,{rotationVectorStartKeypointIndex:0,rotationVectorEndKeypointIndex:1,rotationVectorTargetAngleDegree:90}),t,ge)},e.prototype.poseLandmarkFiltering=function(e,t,n,r){var i,s,o;if(null!=this.timestamp&&this.enableSmoothing){var a=U(X(t),r,{rotationVectorEndKeypointIndex:0,rotationVectorStartKeypointIndex:1,rotationVectorTargetAngleDegree:90});null==this.visibilitySmoothingFilterActual&&(this.visibilitySmoothingFilterActual=new ce(ke)),i=this.visibilitySmoothingFilterActual.apply(e),null==this.visibilitySmoothingFilterAuxiliary&&(this.visibilitySmoothingFilterAuxiliary=new ce(ke)),s=this.visibilitySmoothingFilterAuxiliary.apply(t),o=this.visibilitySmoothingFilterActual.apply(n),null==this.landmarksSmoothingFilterActual&&(this.landmarksSmoothingFilterActual=new he(Se)),i=this.landmarksSmoothingFilterActual.apply(i,this.timestamp,r,!0,a),null==this.landmarksSmoothingFilterAuxiliary&&(this.landmarksSmoothingFilterAuxiliary=new he(Ie)),s=this.landmarksSmoothingFilterAuxiliary.apply(s,this.timestamp,r,!0,a),null==this.worldLandmarksSmoothingFilterActual&&(this.worldLandmarksSmoothingFilterActual=new he(Ce)),o=this.worldLandmarksSmoothingFilterActual.apply(n,this.timestamp)}else i=e,s=t,o=n;return{actualLandmarksFiltered:i,auxiliaryLandmarksFiltered:s,actualWorldLandmarksFiltered:o}},e}();function Pe(e){return f(this,void 0,void 0,(function(){var t,n,r,i,s,o;return m(this,(function(a){switch(a.label){case 0:return t=function(e){var t=d({},null==e?pe:e);if(null==t.enableSmoothing&&(t.enableSmoothing=pe.enableSmoothing),null==t.enableSegmentation&&(t.enableSegmentation=pe.enableSegmentation),null==t.smoothSegmentation&&(t.smoothSegmentation=pe.smoothSegmentation),null==t.modelType&&(t.modelType=pe.modelType),null==t.detectorModelUrl&&(t.detectorModelUrl=pe.detectorModelUrl),null==t.landmarkModelUrl)switch(t.modelType){case"lite":t.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/lite/2";break;case"heavy":t.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/heavy/2";break;default:t.landmarkModelUrl="https://tfhub.dev/mediapipe/tfjs-model/blazepose_3d/landmark/full/2"}return t}(e),n="string"==typeof t.detectorModelUrl&&t.detectorModelUrl.indexOf("https://tfhub.dev")>-1,r="string"==typeof t.landmarkModelUrl&&t.landmarkModelUrl.indexOf("https://tfhub.dev")>-1,[4,Promise.all([Object(l.a)(t.detectorModelUrl,{fromTFHub:n}),Object(l.a)(t.landmarkModelUrl,{fromTFHub:r})])];case 1:return i=a.sent(),s=i[0],o=i[1],[2,new Re(s,o,t.enableSmoothing,t.enableSegmentation,t.smoothSegmentation,t.modelType)]}}))}))}var $e,Fe,_e,Ne=function(){function e(e){!function(e){if(e.maxTracks<1)throw new Error("Must specify 'maxTracks' to be at least 1, but "+"encountered ".concat(e.maxTracks));if(e.maxAge<=0)throw new Error("Must specify 'maxAge' to be positive, but "+"encountered ".concat(e.maxAge));if(void 0!==e.keypointTrackerParams){if(e.keypointTrackerParams.keypointConfidenceThreshold<0||e.keypointTrackerParams.keypointConfidenceThreshold>1)throw new Error("Must specify 'keypointConfidenceThreshold' to be in the range [0, 1], but encountered "+"".concat(e.keypointTrackerParams.keypointConfidenceThreshold));if(e.keypointTrackerParams.minNumberOfKeypoints<1)throw new Error("Must specify 'minNumberOfKeypoints' to be at least 1, but "+"encountered ".concat(e.keypointTrackerParams.minNumberOfKeypoints));for(var t=0,n=e.keypointTrackerParams.keypointFalloff;t<n.length;t++){var r=n[t];if(r<=0)throw new Error("Must specify each keypoint falloff parameterto be positive "+"but encountered ".concat(r))}}}(e),this.tracks=[],this.maxTracks=e.maxTracks,this.maxAge=1e3*e.maxAge,this.minSimilarity=e.minSimilarity,this.nextID=1}return e.prototype.apply=function(e,t){this.filterOldTracks(t);var n=this.computeSimilarity(e);return this.assignTracks(e,n,t),this.updateTracks(t),e},e.prototype.getTracks=function(){return this.tracks.slice()},e.prototype.getTrackIDs=function(){return new Set(this.tracks.map((function(e){return e.id})))},e.prototype.filterOldTracks=function(e){var t=this;this.tracks=this.tracks.filter((function(n){return e-n.lastTimestamp<=t.maxAge}))},e.prototype.assignTracks=function(e,t,n){for(var r=Array.from(Array(t[0].length).keys()),i=[],s=0,o=Array.from(Array(e.length).keys());s<o.length;s++){var a=o[s];if(0!==r.length){for(var u=-1,l=-1,h=0,c=r;h<c.length;h++){var d=c[h],p=t[a][d];p>=this.minSimilarity&&p>l&&(u=d,l=p)}if(u>=0){var f=this.tracks[u];f=Object.assign(f,this.createTrack(e[a],n,f.id)),e[a].id=f.id;var m=r.indexOf(u);r.splice(m,1)}else i.push(a)}else i.push(a)}for(var g=0,y=i;g<y.length;g++){a=y[g];var x=this.createTrack(e[a],n);this.tracks.push(x),e[a].id=x.id}},e.prototype.updateTracks=function(e){this.tracks.sort((function(e,t){return t.lastTimestamp-e.lastTimestamp})),this.tracks=this.tracks.slice(0,this.maxTracks)},e.prototype.createTrack=function(e,t,n){var r={id:n||this.nextTrackID(),lastTimestamp:t,keypoints:y([],e.keypoints,!0).map((function(e){return d({},e)}))};return void 0!==e.box&&(r.box=d({},e.box)),r},e.prototype.nextTrackID=function(){var e=this.nextID;return this.nextID+=1,e},e.prototype.remove=function(){for(var e=[],t=0;t<arguments.length;t++)e[t]=arguments[t];this.tracks=this.tracks.filter((function(t){return!e.includes(t.id)}))},e.prototype.reset=function(){this.tracks=[]},e}(),ze=function(e){function t(t){return e.call(this,t)||this}return c(t,e),t.prototype.computeSimilarity=function(e){var t=this;return 0===e.length||0===this.tracks.length?[[]]:e.map((function(e){return t.tracks.map((function(n){return t.iou(e,n)}))}))},t.prototype.iou=function(e,t){var n=Math.max(e.box.xMin,t.box.xMin),r=Math.max(e.box.yMin,t.box.yMin),i=Math.min(e.box.xMax,t.box.xMax),s=Math.min(e.box.yMax,t.box.yMax);if(n>=i||r>=s)return 0;var o=(i-n)*(s-r);return o/(e.box.width*e.box.height+t.box.width*t.box.height-o)},t}(Ne),Me=function(e){function t(t){var n=e.call(this,t)||this;return n.keypointThreshold=t.keypointTrackerParams.keypointConfidenceThreshold,n.keypointFalloff=t.keypointTrackerParams.keypointFalloff,n.minNumKeyoints=t.keypointTrackerParams.minNumberOfKeypoints,n}return c(t,e),t.prototype.computeSimilarity=function(e){if(0===e.length||0===this.tracks.length)return[[]];for(var t=[],n=0,r=e;n<r.length;n++){for(var i=r[n],s=[],o=0,a=this.tracks;o<a.length;o++){var u=a[o];s.push(this.oks(i,u))}t.push(s)}return t},t.prototype.oks=function(e,t){for(var n=this.area(t.keypoints)+1e-6,r=0,i=0,s=0;s<e.keypoints.length;++s){var o=e.keypoints[s],a=t.keypoints[s];if(!(o.score<this.keypointThreshold||a.score<this.keypointThreshold)){i+=1;var u=Math.pow(o.x-a.x,2)+Math.pow(o.y-a.y,2),l=2*this.keypointFalloff[s];r+=Math.exp(-1*u/(2*n*Math.pow(l,2)))}}return i<this.minNumKeyoints?0:r/i},t.prototype.area=function(e){var t=this,n=e.filter((function(e){return e.score>t.keypointThreshold})),r=Math.min.apply(Math,y([1],n.map((function(e){return e.x})),!1)),i=Math.max.apply(Math,y([0],n.map((function(e){return e.x})),!1)),s=Math.min.apply(Math,y([1],n.map((function(e){return e.y})),!1));return(i-r)*(Math.max.apply(Math,y([0],n.map((function(e){return e.y})),!1))-s)},t}(Ne);function Le(e){switch(e){case Fe.BlazePose:return v.reduce((function(e,t,n){return e[t]=n,e}),{});case Fe.PoseNet:case Fe.MoveNet:return x.reduce((function(e,t,n){return e[t]=n,e}),{});default:throw new Error("Model ".concat(e," is not supported."))}}(_e=$e||($e={})).Keypoint="keypoint",_e.BoundingBox="boundingBox",function(e){e.MoveNet="MoveNet",e.BlazePose="BlazePose",e.PoseNet="PoseNet"}(Fe||(Fe={}));var Be=Object.freeze({__proto__:null,getKeypointIndexBySide:function(e){switch(e){case Fe.BlazePose:return w;case Fe.PoseNet:case Fe.MoveNet:return k;default:throw new Error("Model ".concat(e," is not supported."))}},getAdjacentPairs:function(e){switch(e){case Fe.BlazePose:return I;case Fe.PoseNet:case Fe.MoveNet:return S;default:throw new Error("Model ".concat(e," is not supported."))}},getKeypointIndexByName:Le}),Ue=["SinglePose.Lightning","SinglePose.Thunder","MultiPose.Lightning"],De={modelType:"SinglePose.Lightning",enableSmoothing:!0},je={},We={frequency:30,minCutOff:2.5,beta:300,derivateCutOff:2.5,thresholdCutOff:.5,thresholdBeta:5,disableValueScaling:!0},Ve={maxTracks:18,maxAge:1e3,minSimilarity:.2,keypointTrackerParams:{keypointConfidenceThreshold:.3,keypointFalloff:[.026,.025,.025,.035,.035,.079,.079,.072,.072,.062,.062,.107,.107,.087,.087,.089,.089],minNumberOfKeypoints:4}},Ge={maxTracks:18,maxAge:1e3,minSimilarity:.15,trackerParams:{}};function He(e,t){var n,r,i,s;return e?t.width>t.height?(n=1,r=t.height/t.width,i=0,s=(t.width/2-t.height/2)/t.width):(n=t.width/t.height,r=1,i=(t.height/2-t.width/2)/t.height,s=0):t.width>t.height?(n=t.width/t.height,r=1,i=(t.height/2-t.width/2)/t.height,s=0):(n=1,r=t.height/t.width,i=0,s=(t.width/2-t.height/2)/t.width),{yMin:i,xMin:s,yMax:i+n,xMax:s+r,height:n,width:r}}function li(e,t){var n={maxTracks:e.maxTracks,maxAge:e.maxAge,minSimilarity:e.minSimilarity};return null!=t.maxTracks&&(n.maxTracks=t.maxTracks),null!=t.maxAge&&(n.maxAge=t.maxAge),null!=t.minSimilarity&&(n.minSimilarity=t.minSimilarity),n}var Ke=function(){function e(e,t){this.moveNetModel=e,this.modelInputResolution={height:0,width:0},this.keypointIndexByName=Le(Fe.MoveNet),"SinglePose.Lightning"===t.modelType?(this.modelInputResolution.width=192,this.modelInputResolution.height=192):"SinglePose.Thunder"===t.modelType&&(this.modelInputResolution.width=256,this.modelInputResolution.height=256),this.multiPoseModel="MultiPose.Lightning"===t.modelType,this.multiPoseModel||(this.keypointFilter=new se(We),this.cropRegionFilterYMin=new br(.9),this.cropRegionFilterXMin=new br(.9),this.cropRegionFilterYMax=new br(.9),this.cropRegionFilterXMax=new br(.9)),this.enableSmoothing=t.enableSmoothing,t.minPoseScore?this.minPoseScore=t.minPoseScore:this.minPoseScore=.25,t.multiPoseMaxDimension?this.multiPoseMaxDimension=t.multiPoseMaxDimension:this.multiPoseMaxDimension=256,this.enableTracking=t.enableTracking,this.multiPoseModel&&this.enableTracking&&(t.trackerType===$e.Keypoint?this.tracker=new Me(t.trackerConfig):t.trackerType===$e.BoundingBox&&(this.tracker=new ze(t.trackerConfig)),this.enableSmoothing&&(this.keypointFilterMap=new Map))}return e.prototype.runSinglePersonPoseModel=function(e){return f(this,void 0,void 0,(function(){var t,n,r,i,s;return m(this,(function(l){switch(l.label){case 0:if(4!==(t=this.moveNetModel.execute(e)).shape.length||1!==t.shape[0]||1!==t.shape[1]||17!==t.shape[2]||3!==t.shape[3])throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return"webgpu"===Object(o.dd)()?[3,1]:(n=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:n=l.sent(),l.label=3;case 3:for(t.dispose(),r={keypoints:[],score:0},i=0,s=0;s<17;++s)r.keypoints[s]={y:n[3*s],x:n[3*s+1],score:n[3*s+2]},r.keypoints[s].score>.2&&(++i,r.score+=r.keypoints[s].score);return i>0&&(r.score/=i),[2,r]}}))}))},e.prototype.runMultiPersonPoseModel=function(e){return f(this,void 0,void 0,(function(){var t,n,r,i,s,l,a,u;return m(this,(function(h){switch(h.label){case 0:if(3!==(t=this.moveNetModel.execute(e)).shape.length||1!==t.shape[0]||56!==t.shape[2])throw t.dispose(),new Error("Unexpected output shape from model: [".concat(t.shape,"]"));return"webgpu"===Object(o.dd)()?[3,1]:(n=t.dataSync(),[3,3]);case 1:return[4,t.data()];case 2:n=h.sent(),h.label=3;case 3:for(t.dispose(),r=[],i=n.length/56,s=0;s<i;++s)for(r[s]={keypoints:[]},l=56*s+51,r[s].box={yMin:n[l],xMin:n[l+1],yMax:n[l+2],xMax:n[l+3],width:n[l+3]-n[l+1],height:n[l+2]-n[l]},a=56*s+55,r[s].score=n[a],r[s].keypoints=[],u=0;u<17;++u)r[s].keypoints[u]={y:n[56*s+3*u],x:n[56*s+3*u+1],score:n[56*s+3*u+2]};return[2,r]}}))}))},e.prototype.estimatePoses=function(e,t,n){return void 0===t&&(t=je),f(this,void 0,void 0,(function(){var i,s,r,a,u,l;return m(this,(function(h){switch(h.label){case 0:return t=function(e){return null==e?je:d({},e)}(t),null==e?(this.reset(),[2,[]]):(null==n?K(e)&&(n=1e6*e.currentTime):n*=1e3,i=M(e),s=N(i),r=Object(o.cd)(i,0),e instanceof o.Cc||i.dispose(),a=[],this.multiPoseModel?[3,2]:[4,this.estimateSinglePose(r,s,n)]);case 1:return a=h.sent(),[3,4];case 2:return[4,this.estimateMultiplePoses(r,s,n)];case 3:a=h.sent(),h.label=4;case 4:for(u=0;u<a.length;++u)for(l=0;l<a[u].keypoints.length;++l)a[u].keypoints[l].name=x[l],a[u].keypoints[l].y*=s.height,a[u].keypoints[l].x*=s.width;return[2,a]}}))}))},e.prototype.estimateSinglePose=function(e,t,n){return f(this,void 0,void 0,(function(){var r,s,l,h,c=this;return m(this,(function(d){switch(d.label){case 0:return this.cropRegion||(this.cropRegion=He(null==this.cropRegion,t)),r=Object(o.Bd)((function(){var t=Object(o.Ad)([[c.cropRegion.yMin,c.cropRegion.xMin,c.cropRegion.yMax,c.cropRegion.xMax]]),n=Object(o.Fd)([1],"int32"),r=[c.modelInputResolution.height,c.modelInputResolution.width];return Object(o.Tc)(o.ed.cropAndResize(e,t,n,r,"bilinear",0),"int32")})),e.dispose(),[4,this.runSinglePersonPoseModel(r)];case 1:if(s=d.sent(),r.dispose(),s.score<this.minPoseScore)return this.reset(),[2,[]];for(l=0;l<s.keypoints.length;++l)s.keypoints[l].y=this.cropRegion.yMin+s.keypoints[l].y*this.cropRegion.height,s.keypoints[l].x=this.cropRegion.xMin+s.keypoints[l].x*this.cropRegion.width;return null!=n&&this.enableSmoothing&&(s.keypoints=this.keypointFilter.apply(s.keypoints,n,1)),h=function(e,t,n,r){for(var i={},s=0,o=x;s<o.length;s++){var a=o[s];i[a]=[t[n[a]].y*r.height,t[n[a]].x*r.width]}if(function(e,t){return(e[t.left_hip].score>.2||e[t.right_hip].score>.2)&&(e[t.left_shoulder].score>.2||e[t.right_shoulder].score>.2)}(t,n)){var u=(i.left_hip[0]+i.right_hip[0])/2,l=(i.left_hip[1]+i.right_hip[1])/2,h=function(e,t,n,r,i){for(var s=["left_shoulder","right_shoulder","left_hip","right_hip"],o=0,a=0,u=0;u<s.length;u++)(p=Math.abs(r-n[s[u]][0]))>o&&(o=p),(f=Math.abs(i-n[s[u]][1]))>a&&(a=f);for(var l=0,h=0,c=0,d=Object.keys(n);c<d.length;c++){var p,f,m=d[c];e[t[m]].score<.2||((p=Math.abs(r-n[m][0]))>l&&(l=p),(f=Math.abs(i-n[m][1]))>h&&(h=f))}return[o,a,l,h]}(t,n,i,u,l),c=h[0],d=h[1],p=h[2],f=h[3],m=Math.max(1.9*d,1.9*c,1.2*p,1.2*f),g=[u-(m=Math.min(m,Math.max(l,r.width-l,u,r.height-u))),l-m];if(m>Math.max(r.width,r.height)/2)return He(null==e,r);var y=2*m;return{yMin:g[0]/r.height,xMin:g[1]/r.width,yMax:(g[0]+y)/r.height,xMax:(g[1]+y)/r.width,height:(g[0]+y)/r.height-g[0]/r.height,width:(g[1]+y)/r.width-g[1]/r.width}}return He(null==e,r)}(this.cropRegion,s.keypoints,this.keypointIndexByName,t),this.cropRegion=this.filterCropRegion(h),[2,[s]]}}))}))},e.prototype.estimateMultiplePoses=function(e,t,n){return f(this,void 0,void 0,(function(){var r,i,s,l,a,h,c,d,p,f,y,g=this;return m(this,(function(m){switch(m.label){case 0:return t.width>t.height?(i=this.multiPoseMaxDimension,s=Math.round(this.multiPoseMaxDimension*t.height/t.width),r=o.ed.resizeBilinear(e,[s,i]),a=i,h=32*Math.ceil(s/32),l=Object(o.ld)(r,[[0,0],[0,h-s],[0,0],[0,0]])):(i=Math.round(this.multiPoseMaxDimension*t.width/t.height),s=this.multiPoseMaxDimension,r=o.ed.resizeBilinear(e,[s,i]),a=32*Math.ceil(i/32),h=s,l=Object(o.ld)(r,[[0,0],[0,0],[0,a-i],[0,0]])),r.dispose(),e.dispose(),c=Object(o.Tc)(l,"int32"),l.dispose(),[4,this.runMultiPersonPoseModel(c)];case 1:for(d=m.sent(),c.dispose(),d=d.filter((function(e){return e.score>=g.minPoseScore})),f=0;f<d.length;++f)for(p=0;p<d[f].keypoints.length;++p)d[f].keypoints[p].y*=h/s,d[f].keypoints[p].x*=a/i;if(this.enableTracking&&(this.tracker.apply(d,n),this.enableSmoothing)){for(f=0;f<d.length;++f)this.keypointFilterMap.has(d[f].id)||this.keypointFilterMap.set(d[f].id,new se(We)),d[f].keypoints=this.keypointFilterMap.get(d[f].id).apply(d[f].keypoints,n,1);y=this.tracker.getTrackIDs(),this.keypointFilterMap.forEach((function(e,t){y.has(t)||g.keypointFilterMap.delete(t)}))}return[2,d]}}))}))},e.prototype.filterCropRegion=function(e){if(e){var t=this.cropRegionFilterYMin.apply(e.yMin),n=this.cropRegionFilterXMin.apply(e.xMin),r=this.cropRegionFilterYMax.apply(e.yMax),i=this.cropRegionFilterXMax.apply(e.xMax);return{yMin:t,xMin:n,yMax:r,xMax:i,height:r-t,width:i-n}}return this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset(),null},e.prototype.dispose=function(){this.moveNetModel.dispose()},e.prototype.reset=function(){this.cropRegion=null,this.resetFilters()},e.prototype.resetFilters=function(){this.keypointFilter.reset(),this.cropRegionFilterYMin.reset(),this.cropRegionFilterXMin.reset(),this.cropRegionFilterYMax.reset(),this.cropRegionFilterXMax.reset()},e}();function Xe(e){return void 0===e&&(e=De),f(this,void 0,void 0,(function(){var t,n,r,i;return m(this,(function(s){switch(s.label){case 0:return t=function(e){var t,n=null==e?De:d({},e);if(null==n.modelType)n.modelType="SinglePose.Lightning";else if(Ue.indexOf(n.modelType)<0)throw new Error("Invalid architecture ".concat(n.modelType,". ")+"Should be one of ".concat(Ue));if(null==n.enableSmoothing&&(n.enableSmoothing=!0),null!=n.minPoseScore&&(n.minPoseScore<0||n.minPoseScore>1))throw new Error("minPoseScore should be between 0.0 and 1.0");if(null!=n.multiPoseMaxDimension&&(n.multiPoseMaxDimension%32!=0||n.multiPoseMaxDimension<32))throw new Error("multiPoseMaxDimension must be a multiple of 32 and higher than 0");if("MultiPose.Lightning"===n.modelType&&null==n.enableTracking&&(n.enableTracking=!0),"MultiPose.Lightning"===n.modelType&&!0===n.enableTracking)if(null==n.trackerType&&(n.trackerType=$e.BoundingBox),n.trackerType===$e.Keypoint)null!=n.trackerConfig?n.trackerConfig=function(e){var t=li(Ve,e);return t.keypointTrackerParams=d({},Ve.keypointTrackerParams),null!=e.keypointTrackerParams&&(null!=e.keypointTrackerParams.keypointConfidenceThreshold&&(t.keypointTrackerParams.keypointConfidenceThreshold=e.keypointTrackerParams.keypointConfidenceThreshold),null!=e.keypointTrackerParams.keypointFalloff&&(t.keypointTrackerParams.keypointFalloff=e.keypointTrackerParams.keypointFalloff),null!=e.keypointTrackerParams.minNumberOfKeypoints&&(t.keypointTrackerParams.minNumberOfKeypoints=e.keypointTrackerParams.minNumberOfKeypoints)),t}(n.trackerConfig):n.trackerConfig=Ve;else{if(n.trackerType!==$e.BoundingBox)throw new Error("Tracker type not supported by MoveNet");null!=n.trackerConfig?n.trackerConfig=(t=n.trackerConfig,li(Ge,t)):n.trackerConfig=Ge}return n}(e),r=!0,t.modelUrl?(r="string"==typeof t.modelUrl&&t.modelUrl.indexOf("https://tfhub.dev")>-1,[4,Object(l.a)(t.modelUrl,{fromTFHub:r})]):[3,2];case 1:return n=s.sent(),[3,4];case 2:return i=void 0,"SinglePose.Lightning"===t.modelType?i="https://tfhub.dev/google/tfjs-model/movenet/singlepose/lightning/4":"SinglePose.Thunder"===t.modelType?i="https://tfhub.dev/google/tfjs-model/movenet/singlepose/thunder/4":"MultiPose.Lightning"===t.modelType&&(i="https://tfhub.dev/google/tfjs-model/movenet/multipose/lightning/1"),[4,Object(l.a)(i,{fromTFHub:r})];case 3:n=s.sent(),s.label=4;case 4:return"webgl"===Object(o.dd)()&&Object(o.ad)().set("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",0),[2,new Ke(n,t)]}}))}))}var Ye={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:{height:257,width:257}},qe=["MobileNetV1","ResNet50"],Qe={MobileNetV1:[8,16],ResNet50:[16]},Ze=[8,16,32],Je={MobileNetV1:[.5,.75,1],ResNet50:[1]},et=[1,2,4],tt={maxPoses:1,flipHorizontal:!1},nt={maxPoses:5,flipHorizontal:!1,scoreThreshold:.5,nmsRadius:20},it=[-123.15,-115.9,-103.06];function ot(e){return Math.floor(e/2)}var at=function(){function e(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return e.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},e.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},e.prototype.empty=function(){return-1===this.numberOfElements},e.prototype.size=function(){return this.numberOfElements+1},e.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},e.prototype.max=function(){return this.priorityQueue[0]},e.prototype.swim=function(e){for(;e>0&&this.less(ot(e),e);)this.exchange(e,ot(e)),e=ot(e)},e.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},e.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},e.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},e.prototype.exchange=function(e,t){var n=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=n},e}();function st(e,t,n,r,i,s){for(var o=s.shape,a=o[0],u=o[1],l=!0,h=Math.max(n-i,0),c=Math.min(n+i+1,a),d=h;d<c;++d){for(var p=Math.max(r-i,0),f=Math.min(r+i+1,u),m=p;m<f;++m)if(s.get(d,m,e)>t){l=!1;break}if(!l)break}return l}function ut(e){return f(this,void 0,void 0,(function(){return m(this,(function(t){return[2,Promise.all(e.map((function(e){return e.buffer()})))]}))}))}function lt(e,t,n,r){return{y:r.get(e,t,n),x:r.get(e,t,n+17)}}function ht(e,t,n){var r=lt(e.heatmapY,e.heatmapX,e.id,n),i=r.y,s=r.x;return{x:e.heatmapX*t+s,y:e.heatmapY*t+i}}function ct(e,t,n,r){var i=n.x,s=n.y;return e.some((function(e){var n,o,l,h,c=e.keypoints;return n=s,o=i,(l=c[r].y-n)*l+(h=c[r].x-o)*h<=t}))}var pt=x.reduce((function(e,t,n){return e[t]=n,e}),{}),ft=[["nose","left_eye"],["left_eye","left_ear"],["nose","right_eye"],["right_eye","right_ear"],["nose","left_shoulder"],["left_shoulder","left_elbow"],["left_elbow","left_wrist"],["left_shoulder","left_hip"],["left_hip","left_knee"],["left_knee","left_ankle"],["nose","right_shoulder"],["right_shoulder","right_elbow"],["right_elbow","right_wrist"],["right_shoulder","right_hip"],["right_hip","right_knee"],["right_knee","right_ankle"]].map((function(e){var t=e[0],n=e[1];return[pt[t],pt[n]]})),mt=ft.map((function(e){return e[1]})),gt=ft.map((function(e){return e[0]}));function bt(e,t,n){return e<t?t:e>n?n:e}function yt(e,t,n,r){return{y:bt(Math.round(e.y/t),0,n-1),x:bt(Math.round(e.x/t),0,r-1)}}function xt(e,t){return{x:e.x+t.x,y:e.y+t.y}}function vt(e,t,n,r,i,s,o,a){void 0===a&&(a=2);for(var u=r.shape,l=u[0],h=u[1],c={y:t.y,x:t.x},d=xt(c,function(e,t,n){var r=n.shape[2]/2;return{y:n.get(t.y,t.x,e),x:n.get(t.y,t.x,r+e)}}(e,yt(c,s,l,h),o)),p=0;p<a;p++){var f=yt(d,s,l,h),m=lt(f.y,f.x,n,i);d=xt({x:f.x*s,y:f.y*s},{x:m.x,y:m.y})}var g=yt(d,s,l,h),y=r.get(g.y,g.x,n);return{y:d.y,x:d.x,name:x[n],score:y}}function wt(e,t,n,r,i,s){var o=t.shape[2],a=mt.length,u=new Array(o),l=e.part,h=e.score,c=ht(l,r,n);u[l.id]={score:h,name:x[l.id],y:c.y,x:c.x};for(var d=a-1;d>=0;--d){var p=mt[d],f=gt[d];u[p]&&!u[f]&&(u[f]=vt(d,u[p],f,t,n,r,s))}for(d=0;d<a;++d)p=gt[d],f=mt[d],u[p]&&!u[f]&&(u[f]=vt(d,u[p],f,t,n,r,i));return u}function kt(e,t,n){return n.reduce((function(n,r,i){var s=r.y,o=r.x,a=r.score;return ct(e,t,{y:s,x:o},i)||(n+=a),n}),0)/n.length}function St(e,t,n,r,i,s,o,a){return void 0===o&&(o=.5),void 0===a&&(a=20),f(this,void 0,void 0,(function(){var u,l,h,c,d,p,f,y,g,x,v,b;return m(this,(function(m){switch(m.label){case 0:return[4,ut([e,t,n,r])];case 1:for(u=m.sent(),l=u[0],h=u[1],c=u[2],d=u[3],p=[],f=function(e,t,n){for(var r=n.shape,i=r[0],s=r[1],o=r[2],a=new at(i*s*o,(function(e){return e.score})),u=0;u<i;++u)for(var l=0;l<s;++l)for(var h=0;h<o;++h){var c=n.get(u,l,h);c<e||st(h,c,u,l,1,n)&&a.enqueue({score:c,part:{heatmapY:u,heatmapX:l,id:h}})}return a}(o,0,l),y=a*a;p.length<s&&!f.empty();)g=f.dequeue(),x=ht(g.part,i,h),ct(p,y,x,g.part.id)||(v=wt(g,l,h,i,c,d),b=kt(p,y,v),p.push({keypoints:v,score:b}));return[2,p]}}))}))}const It=Object(o.ad)();It.registerFlag("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE",(()=>15)),It.registerFlag("WEBGPU_CPU_FORWARD",(()=>!0)),It.registerFlag("WEBGPU_MATMUL_PROGRAM_TYPE",(()=>-1)),It.registerFlag("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE",(()=>!1)),It.registerFlag("WEBGPU_USE_LOW_POWER_GPU",(()=>!1)),It.registerFlag("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e3)),It.registerFlag("WEBGPU_USE_PROFILE_TOOL",(()=>!1)),It.registerFlag("WEBGPU_IMPORT_EXTERNAL_TEXTURE",(()=>!0)),It.registerFlag("WEBGPU_USE_NAIVE_CONV2D_DEBUG",(()=>!1)),It.registerFlag("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL",(()=>0)),It.registerFlag("WEBGPU_CONV_SEPARATE_IM2COL_SHADER",(()=>!1));class Ct{constructor(e){e&&(this.vendor=e.vendor,this.architecture=e.architecture,this.intelGPUGeneration=this.getIntelGPUGeneration())}getIntelGPUGeneration(){if(this.isIntel()){if(this.architecture.startsWith("gen"))return Number(this.architecture.match(/\d+/));if(this.architecture.startsWith("xe"))return 12}return 0}isIntel(){return"intel"===this.vendor}}class Ot{constructor(e){this.device=e,this.numUsedBuffers=0,this.numFreeBuffers=0,this.freeBuffers=new Map,this.usedBuffers=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireUploadBuffer(e,t){return this.acquireBuffer(e,t,!0)}acquireBuffer(e,t,n=!1){const r=At(e,t);if(this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.usedBuffers.has(r)||this.usedBuffers.set(r,[]),this.numBytesUsed+=e,this.numUsedBuffers++,this.freeBuffers.get(r).length>0){this.numFreeBuffers--;const e=this.freeBuffers.get(r).shift();return this.usedBuffers.get(r).push(e),e}this.numBytesAllocated+=e;const i=this.device.createBuffer({size:e,usage:t,mappedAtCreation:n});return this.usedBuffers.get(r).push(i),i}releaseBuffer(e,t,n){if(0===this.freeBuffers.size)return;const r=At(t,n);this.freeBuffers.has(r)||this.freeBuffers.set(r,[]),this.freeBuffers.get(r).push(e),this.numFreeBuffers++,this.numUsedBuffers--;const i=this.usedBuffers.get(r),s=i.indexOf(e);if(s<0)throw new Error("Cannot release a buffer that was never provided by this buffer manager");i.splice(s,1),this.numBytesUsed-=t}releaseUploadBuffer(e,t,n){e.mapAsync(GPUMapMode.WRITE).then((()=>{this.releaseBuffer(e,t,n)}),(e=>{}))}getNumUsedBuffers(){return this.numUsedBuffers}getNumFreeBuffers(){return this.numFreeBuffers}dispose(){this.freeBuffers.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.usedBuffers.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.freeBuffers=new Map,this.usedBuffers=new Map,this.numUsedBuffers=0,this.numFreeBuffers=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function At(e,t){return`${e}_${t}`}class Tt{constructor(e){this.device=e,this.numUsedTextures=0,this.numFreeTextures=0,this.freeTextures=new Map,this.usedTextures=new Map,this.numBytesUsed=0,this.numBytesAllocated=0}acquireTexture(e,t,n,r){const i=e*t*Rt(n),s=Et(e,t,n,r);if(this.freeTextures.has(s)||this.freeTextures.set(s,[]),this.usedTextures.has(s)||this.usedTextures.set(s,[]),this.numBytesUsed+=i,this.numUsedTextures++,this.freeTextures.get(s).length>0){this.numFreeTextures--;const e=this.freeTextures.get(s).shift();return this.usedTextures.get(s).push(e),e}this.numBytesAllocated+=i;const o=this.device.createTexture({size:[e,t],format:n,usage:r});return this.usedTextures.get(s).push(o),o}releaseTexture(e,t,n,r,i){if(0===this.freeTextures.size)return;const s=Et(t,n,r,i);this.freeTextures.has(s)||this.freeTextures.set(s,[]),this.freeTextures.get(s).push(e),this.numFreeTextures++,this.numUsedTextures--;const o=this.usedTextures.get(s),a=o.indexOf(e);if(a<0)throw new Error("Cannot release a texture that was never provided by this texture manager");o.splice(a,1);const u=t*n*Rt(r);this.numBytesUsed-=u}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){this.freeTextures.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.usedTextures.forEach(((e,t)=>{e.forEach((e=>{e.destroy()}))})),this.freeTextures=new Map,this.usedTextures=new Map,this.numUsedTextures=0,this.numFreeTextures=0,this.numBytesUsed=0,this.numBytesAllocated=0}}function Et(e,t,n,r){return`${e}_${t}_${n}_${r}`}function Rt(e){if("rgba8unorm"===e)return 16;throw new Error(e+" is not supported!")}function Pt(e,t){if(Math.max(...e)>3)throw new Error("Cannot symbolically compute strides for rank > 4 tensor.");const n=e.length,r=e.map((e=>`${t}[${e}]`)),i=new Array(n-1);i[n-2]=r[n-1];for(let e=n-3;e>=0;--e)i[e]=`(${i[e+1]} * ${r[e+1]})`;return i}const $t=(e,t,n)=>"int32"===n?`atomicAdd(${e}, bitcast<i32>(${t}));`:`\n          {\n            var oldValue = 0;\n            loop {\n              let newValueF32 = bitcast<f32>(oldValue) + (${t});\n              let newValue = bitcast<i32>(newValueF32);\n              let res = atomicCompareExchangeWeak(${e}, oldValue, newValue);\n              if res.exchanged {\n                break;\n              }\n              oldValue = res.old_value;\n            }\n          }`;function Ft(e){if(e<=1)return"i32";if(2===e)return"vec2<i32>";if(3===e)return"vec3<i32>";if(4===e)return"vec4<i32>";if(5===e)return"vec5";if(6===e)return"vec6";throw Error(`GPU for rank ${e} is not yet supported`)}function _t(e){if(0===e)return"x";if(1===e)return"y";if(2===e)return"z";if(3===e)return"w";if(4===e)return"u";if(5===e)return"v";throw Error(`Index ${e} is not yet supported`)}function Nt(...e){let t;switch(e.length){case 0:t="\n        fn main()\n      ";break;case 1:t=`\n        fn main(${e[0]} : i32)\n      `;break;default:throw Error("Unreachable")}return t}function zt(e,t){let n;return n=`\n     ${function(e){return`\n  @compute @workgroup_size(${e.workgroupSize[0]}, ${e.workgroupSize[1]}, ${e.workgroupSize[2]})\n`}(t)}\n      fn _start(@builtin(local_invocation_id) LocalId : vec3<u32>,\n                @builtin(global_invocation_id) GlobalId : vec3<u32>,\n                @builtin(local_invocation_index) LocalIndex: u32,\n                @builtin(workgroup_id) WorkgroupId : vec3<u32>,\n                @builtin(num_workgroups) NumWorkgroups : vec3<u32>) {\n        localId = LocalId;\n        localIndex = LocalIndex;\n        globalId = GlobalId;\n        numWorkgroups = NumWorkgroups;\n        workgroupId = WorkgroupId;\n        ${e?"main(getGlobalIndex());":"main();"};\n      }\n    `,n}const Mt="\n  struct vec5 {x: i32, y: i32, z: i32, w: i32, u: i32};\n  struct vec6 {x: i32, y: i32, z: i32, w: i32, u: i32, v: i32};\n\n  // Checks whether coordinates lie within the bounds of the shape.\n  fn coordsInBounds2D(coord : vec2<i32>, shape : vec2<i32>) -> bool {\n    return all(coord >= vec2<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds3D(coord : vec3<i32>, shape : vec3<i32>) -> bool {\n    return all(coord >= vec3<i32>(0)) && all(coord < shape);\n  }\n  fn coordsInBounds4D(coord : vec4<i32>, shape : vec4<i32>) -> bool {\n    return all(coord >= vec4<i32>(0)) && all(coord < shape);\n  }\n\n  fn getIndexFromCoords1D(coord : i32, shape : i32) -> i32 {\n    return coord;\n  }\n  fn getIndexFromCoords2D(coords : vec2<i32>, shape : vec2<i32>) -> i32 {\n    return dot(coords, vec2<i32>(shape.y, 1));\n  }\n  fn getIndexFromCoords3D(coords : vec3<i32>, shape : vec3<i32>) -> i32 {\n    return dot(coords, vec3<i32>(shape.y * shape.z, shape.z, 1));\n  }\n  fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {\n    return dot(coords, vec4<i32>(\n        shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));\n  }\n  fn getIndexFromCoords5D(coords : vec5, shape : vec5) -> i32 {\n    let shapeStrides: vec5 = vec5(shape.y * shape.z * shape.w * shape.u, shape.z * shape.w * shape.u, shape.w * shape.u, shape.u, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u;\n  }\n  fn getIndexFromCoords6D(coords : vec6, shape : vec6) -> i32 {\n    let shapeStrides: vec6 = vec6(shape.y * shape.z * shape.w * shape.u * shape.v, shape.z * shape.w * shape.u * shape.v, shape.w * shape.u * shape.v, shape.u * shape.v, shape.v, 1);\n    return coords.x*shapeStrides.x + coords.y*shapeStrides.y + coords.z*shapeStrides.z + coords.w*shapeStrides.w + coords.u*shapeStrides.u + coords.v*shapeStrides.v;\n  }\n\n  fn idiv(a: i32, b: i32, sign: f32) -> i32 {\n    var res: i32 = a / b;\n    let modulo: i32 = a % b;\n    if (sign < 0. && modulo != 0) {\n      res = res - 1;\n    }\n    return res;\n  }\n\n  // NaN defination in IEEE 754-1985 is :\n  //   - sign = either 0 or 1.\n  //   - biased exponent = all 1 bits.\n  //   - fraction = anything except all 0 bits (since all 0 bits represents infinity).\n  // https://en.wikipedia.org/wiki/IEEE_754-1985#Representation_of_non-numbers\n  fn isnan(val: f32) -> bool {\n    let floatToUint: u32 = bitcast<u32>(val);\n    return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n  }\n  fn isnanVec4(val : vec4<f32>) -> vec4<bool> {\n    let floatToUint: vec4<u32> = bitcast<vec4<u32>>(val);\n    return (floatToUint & vec4<u32>(0x7fffffffu)) > vec4<u32>(0x7f800000u);\n  }\n",Lt="\n  fn isinf(val: f32) -> bool {\n    return abs(val) == uniforms.INFINITY;\n  }\n";function Bt(e){const t=e.length;if(t<=1)return"fn getCoordsFromIndex(index : i32) -> i32 { return index; }";const n=o.Ed.computeStrides(e),i=Ft(t),s=[];for(let e=0;e<t;e++)s.push("d"+e);if(1===n.length)return"    fn getCoordsFromIndex(index : i32) -> vec2<i32> {\n      let d0 = index / uniforms.outShapeStrides; let d1 = index - d0 * uniforms.outShapeStrides;\n      return vec2<i32>(d0, d1);\n    }";let r;return r="var index2 = index;"+n.map(((e,t)=>`let ${s[t]} = index2 / uniforms.outShapeStrides.${_t(t)}; ${t===n.length-1?`let ${s[t+1]} = index2 - ${s[t]} * uniforms.outShapeStrides.${_t(t)}`:`index2 = index2 - ${s[t]} * uniforms.outShapeStrides.${_t(t)}`};`)).join(""),`\n    fn getCoordsFromIndex(index : i32) -> ${i} {\n      ${r}\n      return ${i}(${s.join(",")});\n    }\n  `}function Ut(e){let t="";switch(e){case 0:case 1:t+="\n        fn getOutputIndexFromCoords(coords : i32) -> i32 {\n          return coords;\n        }\n        ";break;case 2:t+="\n        fn getOutputIndexFromCoords(coords : vec2<i32>) -> i32 {\n          return dot(coords, vec2<i32>(uniforms.outShapeStrides, 1));\n        }\n        ";break;case 3:t+="\n        fn getOutputIndexFromCoords(coords : vec3<i32>) -> i32 {\n          return dot(coords, vec3<i32>(uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, 1));\n        }\n        ";break;case 4:t+="\n        fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {\n          return dot(coords, vec4<i32>(\n            uniforms.outShapeStrides.x, uniforms.outShapeStrides.y, uniforms.outShapeStrides.z, 1));\n        }\n        ";break;case 5:t+="\n        fn getOutputIndexFromCoords(coords : vec5) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u;\n        }\n        ";break;case 6:t+="\n        fn getOutputIndexFromCoords(coords : vec6) -> i32 {\n          return coords.x * uniforms.outShapeStrides.x +\n              coords.y * uniforms.outShapeStrides.y +\n              coords.z * uniforms.outShapeStrides.z +\n              coords.w * uniforms.outShapeStrides.w +\n              coords.u * uniforms.outShapeStrides.u +\n              coords.v;\n        }\n        ";break;default:o.Ed.assert(!1,(()=>`Unsupported ${e}D shape`))}return t}function Dt(e){return 1===e.dispatch[1]&&1===e.dispatch[2]}function jt(e,t){return"float32"===e?t?"vec4<f32>":"f32":"int32"===e||"bool"===e?t?"vec4<i32>":"i32":e}function Wt(e){return!(e.dispatchLayout.hasOwnProperty("y")&&0!==e.dispatchLayout.y.length||e.dispatchLayout.hasOwnProperty("z")&&0!==e.dispatchLayout.z.length)}const Vt=e=>{let t=1;for(let n=0;n<e.length;n++)t*=e[n];return t};function Gt(e,t,n=[1,1,1],r=[1,1,1]){const[i,s,o]=[Math.ceil(Vt(e.x.map((e=>t[e])))/(n[0]*r[0])),e.y?Math.ceil(Vt(e.y.map((e=>t[e])))/(n[1]*r[1])):1,e.z?Math.ceil(Vt(e.z.map((e=>t[e])))/(n[2]*r[2])):1];return[i,s,o]}function Ht(e,t,n=!1){if(n)return[8,8,1];const r=Vt(e.x.map((e=>t[e]))),i=Vt(e.y.map((e=>t[e])));return r<=4?[4,16,1]:i<=4?[16,4,1]:[16,16,1]}function Kt(e,t,n=!1){if(n)return[4,4,1];const r=Vt(e.x.map((e=>t[e]))),i=Vt(e.y.map((e=>t[e])));return r<=4?[1,2,1]:i<=4?[2,1,1]:[2,2,1]}function Xt(e){return{x:e.map(((e,t)=>t))}}function Yt(e){if("float32"===e||"int32"===e||"bool"===e||"string"===e)return 4;if("complex64"===e)return 8;throw new Error("Unknown dtype "+e)}function qt(){return("undefined"!=typeof window||"undefined"!=typeof WorkerGlobalScope)&&!!navigator.gpu}var Qt;!function(e){e[e.MatMulReduceProgram=0]="MatMulReduceProgram",e[e.MatMulSplitKProgram=1]="MatMulSplitKProgram",e[e.MatMulSmallOutputSizeProgram=2]="MatMulSmallOutputSizeProgram",e[e.MatMulPackedProgram=3]="MatMulPackedProgram",e[e.MatMulMax=4]="MatMulMax"}(Qt||(Qt={}));const Zt=Object(o.ad)().getNumber("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD");class Jt extends o.mb{constructor(e,t){if(super(),this.commandQueueOwnedIds=new WeakSet,this.dispatchNumberInEncoder=0,this.disposed=!1,this.downloadWaitMs=0,this.tensorDataPendingDisposal=[],this.stagingPendingDisposal=[],this.uniformPendingDisposal=[],this.uploadWaitMs=0,!qt())throw new Error("WebGPU is not supported on this device");this.pipelineCache={},this.device=e,this.queue=e.queue,this.currentCommandEncoder=null,this.currentComputePass=null,this.supportTimeQuery=e.features.has("timestamp-query-inside-passes"),this.adapterInfo=new Ct(t),this.thresholdToIncreaseWorkgroups=this.adapterInfo.intelGPUGeneration>=12?16:8,this.bufferManager=new Ot(this.device),this.textureManager=new Tt(this.device),this.tensorMap=new o.G(this,Object(o.Zc)()),this.supportTimeQuery&&(this.querySet=this.device.createQuerySet({type:"timestamp",count:2})),Object(o.ad)().getBool("WEBGPU_USE_PROFILE_TOOL")&&(this.dummyCanvas=document.createElement("canvas"),this.dummyCanvas.width=1,this.dummyCanvas.height=1,this.dummyContext=this.dummyCanvas.getContext("webgpu"),this.dummyContext.configure({device:e,format:"bgra8unorm"}),document.body.appendChild(this.dummyCanvas))}nextDataId(){return Jt.nextDataId++}floatPrecision(){return 32}defaultGpuBufferUsage(){return GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST}disposeData(e,t=!1){if(this.tensorDataPendingDisposal.indexOf(e)>=0)return!1;if(!this.tensorMap.has(e))return!0;const n=this.tensorMap.get(e);if(this.decRef(e),!t&&n.refCount>0)return!1;if(this.commandQueueOwnedIds.has(e))return this.tensorDataPendingDisposal.push(e),!1;const{complexTensorInfos:r}=this.tensorMap.get(e);return null!=r&&(this.disposeData(r.real.dataId,t),this.disposeData(r.imag.dataId,t)),this.releaseResource(e),this.tensorMap.delete(e),!0}memory(){return{numBytesInGPU:this.bufferManager.numBytesUsed,numBytesAllocatedInGPU:this.bufferManager.numBytesAllocated,unreliable:!1}}releaseResource(e){const t=this.tensorMap.get(e);if(t&&t.resourceInfo)if(t.external)t.resourceInfo=null;else{if("texture"in t.resourceInfo){const e=t.resourceInfo;e.texture instanceof GPUTexture&&this.textureManager.releaseTexture(e.texture,e.width,e.height,e.format,e.usage),e.texture=null}else{const e=t.resourceInfo;this.bufferManager.releaseBuffer(e.buffer,e.size,e.usage),e.buffer=null}t.resourceInfo=null}}refCount(e){return this.tensorMap.has(e)?this.tensorMap.get(e).refCount:0}incRef(e){this.tensorMap.get(e).refCount++}decRef(e){this.tensorMap.has(e)&&this.tensorMap.get(e).refCount--}write(e,t,n){if("complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.tensorMap.set(r,{dtype:n,shape:t,values:e,refCount:1}),r}move(e,t,n,r,i){if("complex64"===r)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.tensorMap.set(e,{dtype:r,shape:n,values:t,refCount:i})}submitQueue(){this.ensureComputePassEnded(),this.queue.submit([this.currentCommandEncoder.finish()]),this.currentCommandEncoder=null,this.dispatchNumberInEncoder=0,this.commandQueueOwnedIds=new WeakSet,this.tensorDataPendingDisposal.forEach((e=>{this.releaseResource(e),this.tensorMap.delete(e)})),this.uniformPendingDisposal.forEach((e=>this.bufferManager.releaseBuffer(e.buffer,e.size,e.usage))),this.stagingPendingDisposal.forEach((e=>this.bufferManager.releaseUploadBuffer(e.buffer,e.size,e.usage))),this.tensorDataPendingDisposal=[],this.uniformPendingDisposal=[],this.stagingPendingDisposal=[]}ensureCommandEncoderReady(){this.currentCommandEncoder||(this.currentCommandEncoder=this.device.createCommandEncoder())}ensureComputePassEnded(){this.currentComputePass&&(this.currentComputePass.end(),this.currentComputePass=null)}getComputePass(){return this.currentComputePass||(this.currentComputePass=this.currentCommandEncoder.beginComputePass()),this.currentComputePass}async getBufferData(e,t){const n=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,n,0,t),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);const i=n.getMappedRange().slice(0);return n.unmap(),null!=n&&this.bufferManager.releaseBuffer(n,t,GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ),Object(o.ad)().getBool("WEBGPU_USE_PROFILE_TOOL")&&(o.Ed.assert(void 0!==this.dummyContext,(()=>"Fail to get context for profiling tool")),this.dummyContext.getCurrentTexture()),i}convertAndCacheOnCPU(e,t){const n=this.tensorMap.get(e);return this.releaseResource(e),n.values=t,n.values}readSync(e){const t=this.tensorMap.get(e),{values:n}=t;if(null==n)throw new Error("WebGPU readSync is only available for CPU-resident tensors.");return n}async read(e){if(!this.tensorMap.has(e))throw new Error(`Tensor ${e} was not registered!`);const t=this.tensorMap.get(e),{values:n}=t;if(null!=n)return this.convertAndCacheOnCPU(e,n);let i;if("complex64"===t.dtype){const e=await Promise.all([this.read(t.complexTensorInfos.real.dataId),this.read(t.complexTensorInfos.imag.dataId)]),n=e[0],r=e[1];i=o.Oc.mergeRealAndImagArrays(n,r)}else{const e=t.resourceInfo,n=await this.getBufferData(e.buffer,e.size);i=o.Ed.convertBackendValuesAndArrayBuffer(n,t.dtype)}return this.convertAndCacheOnCPU(e,i),i}copyBuffer(e,t,n){const r=this.bufferManager.acquireBuffer(t,n);return this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,r,0,t),this.submitQueue(),r}createTensorFromGPUData(e,t,n){let i=e.buffer;if("complex64"===n)throw new Error("Cannot write to a complex64 dtype. ");const s={id:this.nextDataId()};this.tensorMap.set(s,{dtype:n,shape:t,values:null,refCount:1,external:e.zeroCopy});const r=this.tensorMap.get(s),a=Yt(r.dtype)*o.Ed.sizeFromShape(r.shape);if(e.buffer.size<a)throw new Error(`GPUBuffer size(${e.buffer.size}) is smaller than tensor size(${a})!`);if((e.buffer.usage&(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))!=(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC))throw new Error("GPUBuffer.usage should include GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC!");return!0!==e.zeroCopy&&(i=this.copyBuffer(i,a,i.usage)),r.resourceInfo={size:i.size,usage:i.usage,buffer:i},Object(o.Zc)().makeTensorFromDataId(s,t,n,this)}readToGPU(e){const t=this.tensorMap.get(e),{values:n,dtype:r,shape:i,resourceInfo:s}=t;if("complex64"===r)throw new Error("Does not support reading buffer for complex64 dtype.");if(null==s)throw null!=n?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const l=s.size,a=this.bufferManager.acquireBuffer(l,s.usage);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(s.buffer,0,a,0,l),this.submitQueue();const u=this.makeTensorInfo(i,r),h=Object(o.Zc)().makeTensorFromTensorInfo(u);return this.tensorMap.get(u.dataId).resourceInfo={size:l,usage:this.defaultGpuBufferUsage(),buffer:a},{tensorRef:h,buffer:a,bufSize:l}}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>o.Ed.decodeString(e)));return Object(o.Sc)(e.shape,e.dtype,n)}catch(e){throw new Error("Failed to decode encoded string bytes into utf-8")}return Object(o.Sc)(e.shape,e.dtype,t)}async time(e){this.supportTimeQuery||console.warn("This device doesn't support timestamp-query-inside-passes extension. Start Chrome browser with flag --disable-dawn-features=disallow_unsafe_apis then try again. Otherwise, zero will be shown for the kernel time when profiling mode is enabled. Using performance.now is not workable for webgpu since it doesn't support synchronous data read from GPU.");const t=this.activeTimers,n=[];let i=!1;null==this.programTimersStack?(this.programTimersStack=n,i=!0):this.activeTimers.push(n),this.activeTimers=n,e();const s=o.Ed.flatten(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),r=o.Ed.flatten(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,i&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null},u=await Promise.all(s);return a.kernelMs=o.Ed.sum(u),a.getExtraProfileInfo=()=>u.map(((e,t)=>({name:r[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", "),this.uploadWaitMs=0,this.downloadWaitMs=0,a}makeTensorInfo(e,t,n){return"string"===t&&null!=n&&n.length>0&&o.Ed.isString(n[0])&&(n=n.map((e=>o.Ed.encodeString(e)))),{dataId:this.write(n,e,t),shape:e,dtype:t}}tensorToBinding(e){if(!e)return null;const t=this.tensorMap.get(e.dataId);if("texture"in t.resourceInfo){const e=t.resourceInfo;return e.texture instanceof GPUExternalTexture?e.texture:e.texture.createView()}const n=t.resourceInfo;return{offset:0,size:n.size,buffer:n.buffer}}async getQueryTime(e){return this.supportTimeQuery?this.getTimeFromQuerySet(e):0}uploadToGPU(e){const t=this.tensorMap.get(e);if(t.resourceInfo)return;const n=Yt(t.dtype)*o.Ed.sizeFromShape(t.shape),i=this.bufferManager.acquireBuffer(n,this.defaultGpuBufferUsage());if(t.resourceInfo={size:n,usage:this.defaultGpuBufferUsage(),buffer:i},t.values){const e=this.bufferManager.acquireUploadBuffer(n,GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC),r=e.getMappedRange();"int32"===t.dtype||"bool"===t.dtype?new Int32Array(r).set(t.values):new Float32Array(r).set(t.values),e.unmap(),this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.copyBufferToBuffer(e,0,i,0,n);const s={size:n,usage:GPUBufferUsage.MAP_WRITE|GPUBufferUsage.COPY_SRC,buffer:e};this.stagingPendingDisposal.push(s)}}makeUniforms(e){let t=0,n=0;const i=[];let s=1;e.forEach((e=>{let r;switch(0===e.data.length&&(e.data=[1]),e.data.length){case 1:r=4;break;case 2:r=8;break;case 3:case 4:case 5:case 6:r=16;break;default:o.Ed.assert(!1,(()=>`Unsupported ${e.data.length}D shape`))}5!==n&&6!==n||(r=16),r>s&&(s=r),t=Math.ceil(t/r)*r,n=e.data.length,i.push(t),t+=4*e.data.length})),t=Math.ceil(t/s)*s;const r=new ArrayBuffer(t);e.forEach(((e,t)=>{const n=i[t];"int32"===e.type?new Int32Array(r,n,e.data.length).set(e.data):"uint32"===e.type?new Uint32Array(r,n,e.data.length).set(e.data):new Float32Array(r,n,e.data.length).set(e.data)}));const a=this.bufferManager.acquireBuffer(t,GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM);this.queue.writeBuffer(a,0,r,0,t);const u={size:t,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.UNIFORM,buffer:a};return this.uniformPendingDisposal.push(u),{offset:0,size:t,buffer:a}}runWebGPUProgram(e,t,n,i,s){if(s||(s=this.makeTensorInfo(e.outputShape,n)),0===o.Ed.sizeFromShape(s.shape))return this.tensorMap.get(s.dataId).values=o.Ed.getTypedArrayFromDType(s.dtype,0),s;this.uploadToGPU(s.dataId),e.dispatch=((e,t)=>{const n=e.limits.maxComputeWorkgroupsPerDimension,i=t.dispatchLayout,s=t.dispatch;if(s.every((e=>e<=n)))return s;o.Ed.assert(s[0]>n&&void 0===i.y&&void 0===i.z,(()=>"Dispatch size exceeds WebGPU limits in Y or Z dimension."));let r=Math.ceil(Math.sqrt(s[0]));return r>n?(r=Math.ceil(Math.cbrt(s[0])),o.Ed.assert(r<=n,(()=>"Total dispatch size exceeds WebGPU maximum.")),[r,r,r]):[r,r,1]})(this.device,e);let r=[],a=[];if(!e.isFromPixels){r.push({type:"float32",data:[NaN]},{type:"float32",data:[1/0]}),a=t.concat(s).map((e=>e.shape));const n="int32";a.map((e=>{r.push({type:n,data:e})}));const i=o.Ed.computeStrides(s.shape);if(r.push({type:n,data:i}),e.size){const t=o.Ed.sizeFromShape(e.outputShape);r.push({type:n,data:[e.isVec4?t/4:t]})}}const u=t.map(((t,n)=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");return this.uploadToGPU(t.dataId),{dtype:this.tensorMap.get(t.dataId).dtype,shape:t.shape,name:e.variableNames[n]}})),l=function(e,t,n,i){let s=e.shaderKey;if(e.isFromPixels)return s;const r=n.map((e=>e.dtype)).concat(i.dtype),a=n.map((e=>o.Oc.getBroadcastDims(e.shape,i.shape))),u=n.map((e=>o.Ed.arraysEqual(e.shape,i.shape))).join("_"),l=a.map((e=>e.join("_"))).join(";"),h=Dt(e)?"flatDispatch":"";return s+="_"+(e.workgroupSize?e.workgroupSize.join(","):"")+t.map((e=>e.length)).join(",")+r.join(",")+e.variableNames.join(",")+l+u+h,s}(e,a,u,s);let h;l in this.pipelineCache?h=this.pipelineCache[l]:(h=((e,t,n,i)=>{const s=function(e,t,n){const i=[],s=n.workgroupSize[0]*n.workgroupSize[1]*n.workgroupSize[2];if(i.push(`\n\n      var<private> localId: vec3<u32>;\n      var<private> localIndex: u32;\n      var<private> globalId: vec3<u32>;\n      var<private> numWorkgroups: vec3<u32>;\n      var<private> workgroupId: vec3<u32>;\n\n      // Only used when the y/z dimension of workgroup size is 1.\n      fn getGlobalIndex() -> i32 {\n        ${Dt(n)?"  return i32(globalId.x);":`  return i32((workgroupId.z * numWorkgroups.x * numWorkgroups.y +\n                workgroupId.y * numWorkgroups.x + workgroupId.x) * ${s}u +\n                localIndex);\n        `}\n      }\n    `),n.isFromPixels){i.push(`\n        struct Uniform {\n          size            : i32,\n          numChannels     : i32,\n          outShapeStrides : vec2<i32>,\n        };\n\n        @group(0) @binding(0) var<storage, read_write> result: array<${jt(t.dtype,n.isVec4)}>;\n        @group(0) @binding(2) var<uniform> uniforms: Uniform;\n      `);const e=Wt(n);return[Mt,i.join("\n"),Bt(t.shape),n.getUserCode(),zt(e,n)].join("\n")}let r="struct Uniforms { NAN : f32, INFINITY : f32, ";n.variableNames.forEach(((t,n)=>{const o=Ft(e[n].shape.length);r+=`${t.charAt(0).toLowerCase()+t.slice(1)}Shape : ${o}, `}));const a=Ft(t.shape.length);r+=`outShape : ${a}, `;const u=Ft(t.shape.length-1);r+=`\n         outShapeStrides: ${u}, `,n.size&&(r+="size : i32, "),n.uniforms&&(r+=n.uniforms),r+="};",r=function(e){return(e=e.replace(/(\w+)\s*:\s*vec(5|6)/g,(e=>"@align(16) "+e))).replace(/vec(5|6)\s*,\s*(\w+)/g,((e,t,n)=>`vec${t}, @align(16) ${n}`))}(r),i.push(r),n.atomic?i.push("\n      @group(0) @binding(0) var<storage, read_write> result: array<atomic<i32>>;\n    "):i.push(`\n      @group(0) @binding(0) var<storage, read_write> result: array<${jt(t.dtype,n.isVec4)}>;\n    `),n.variableNames.forEach(((t,r)=>{i.push(`\n      @group(0) @binding(${1+r}) var<storage, read> ${t}: array<${n.variableTypes?n.variableTypes[r]:jt(e[r].dtype,n.isVec4)}>;\n        `)})),""!==r&&i.push(`\n      @group(0) @binding(${1+n.variableNames.length}) var<uniform> uniforms: Uniforms;\n      `);const l=function(e,t){const{x:n,y:r=[],z:i=[]}=t,s=e.length,o=n.length+r.length+i.length;if(o!==s)return"";if(n.length===s)return`fn getOutputCoords() -> ${Ft(s)}{\n    let globalIndex = getGlobalIndex();\n    return getCoordsFromIndex(globalIndex);\n  }\n  `;let a="";const u=[n,r,i];for(let e=0;e<u.length;e++){const t=u[e];if(0!==t.length)if(1===t.length)a+=`let d${t[0]} = i32(globalId[${e}]);`;else{const n=Pt(t,"uniforms.outShape");a+=`var index${e} = i32(globalId[${e}]);`;for(let r=0;r<n.length;r++)a+=`let d${t[r]} = index${e} / ${n[r]};`,r===n.length-1?a+=`let d${t[r+1]} = index${e} - d${t[r]} * ${n[r]};`:a+=`index${e} = index${e} - d${t[r]} * ${n[r]};`}}const l=[];for(let e=0;e<o;e++)l.push("d"+e);const h=Ft(o);let c=`fn getOutputCoords() -> ${h} {\n  ${a}\n`;return 0===l.length?c+=`return ${h}(0); }`:c+=`return ${h}(${l.join(",")}); }`,c}(t.shape,n.dispatchLayout),h=[Mt,i.join("\n")+Lt,Bt(t.shape),l,Ut(t.shape.length)];n.atomic||h.push(function(e,t,n){const r=e.length,i=jt(t,n);let s;if(s=n?`fn setOutputAtIndex(flatIndex : i32, value : vec4<f32>) {\n      result[flatIndex] = ${i}(value);\n    }\n    fn setOutputAtIndexI32(flatIndex : i32, value : vec4<i32>) {\n      result[flatIndex] = ${i}(value);\n    }`:`fn setOutputAtIndex(flatIndex : i32, value : f32) {\n      result[flatIndex] = ${i}(value);\n    }\n    fn setOutputAtIndexI32(flatIndex : i32, value : i32) {\n      result[flatIndex] = ${i}(value);\n    }`,r>=2){const e=["d0","d1","d2","d3","d4","d5"].slice(0,r),t=Ft(r);s+=n?`\n      fn setOutputAtCoords(${e.map((e=>e+" : i32")).join(", ")}, value : vec4<f32>) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndex(flatIndex / 4, value);\n      }\n      fn setOutputAtCoordsI32(${e.map((e=>e+" : i32")).join(", ")}, value : vec4<i32>) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndexI32(flatIndex / 4, value);\n      }\n    `:`\n      fn setOutputAtCoords(${e.map((e=>e+" : i32")).join(", ")}, value : f32) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndex(flatIndex, value);\n      }\n      fn setOutputAtCoordsI32(${e.map((e=>e+" : i32")).join(", ")}, value : i32) {\n        let flatIndex = getOutputIndexFromCoords(${t}(${e.join(", ")}));\n        setOutputAtIndexI32(flatIndex, value);\n      }\n    `}return s}(t.shape,t.dtype,n.isVec4));const c=e.map(((e,i)=>function(e,t,n,i){let s=function(e,t){const n=e.name,r=e.shape.length,i=Ft(r),s="get"+n.charAt(0).toUpperCase()+n.slice(1),o=["d0","d1","d2","d3","d4","d5"].slice(0,r),a=o.map((e=>e+" : i32")).join(", ");if(r<1)return t?`\n        fn ${s}() -> vec4<f32> {\n          return vec4<f32>(${n}[0]);\n        }\n      `:`\n      fn ${s}() ->f32 {\n        return f32(${n}[0]);\n      }\n    `;const u=`uniforms.${n.charAt(0).toLowerCase()+n.slice(1)}Shape`;let l=r+"D";return 0===r&&(l="1D"),t?`\n      fn ${s}(${a}) -> vec4<f32> {\n        return vec4<f32>(${n}[getIndexFromCoords${l}(${i}(${o.join(",")}),\n          ${u}) / 4]);\n      }\n      `:`\n    fn ${s}(${a}) -> f32 {\n      return f32(${n}[getIndexFromCoords${l}(${i}(${o.join(",")}),\n        ${u})]);\n    }\n   `}(e,n);return e.shape.length<=t.length&&(s+=function(e,t,n,i){const s=e.name,r=s.charAt(0).toUpperCase()+s.slice(1),a="get"+r+"ByOutput",u=e.shape.length,l=t.length,h=Ft(l);if(o.Ed.arraysEqual(e.shape,t)&&i)return n?`\n      fn ${a}Index(globalIndex : i32) -> vec4<f32> {\n        return vec4<f32>(${s}[globalIndex]);\n      }\n\n      fn ${a}Coords(coords : ${h}) -> vec4<f32> {\n        return vec4<f32>(${s}[${l>1?"getOutputIndexFromCoords(coords)":"coords"} / 4]);\n      }\n      `:`\n    fn ${a}Index(globalIndex : i32) -> f32 {\n      return f32(${s}[globalIndex]);\n    }\n\n    fn ${a}Coords(coords : ${h}) -> f32 {\n      return f32(${s}[${l>1?"getOutputIndexFromCoords(coords)":"coords"}]);\n    }\n    `;const c=o.Oc.getBroadcastDims(e.shape,t),d=l-u;let p="";if(0===u)return n?`\n    fn ${a}Index(globalIndex : i32) -> vec4<f32> {\n      return get${r}();\n    }\n\n    fn ${a}Coords(coords : ${h}) -> vec4<f32> {\n      return get${r}();\n    }\n  `:`\n    fn ${a}Index(globalIndex : i32) -> f32{\n      return get${r}();\n    }\n\n    fn ${a}Coords(coords : ${h}) -> f32{\n      return get${r}();\n    }\n  `;p=l<2&&c.length>=1?"coords = 0;":c.map((e=>`coords.${_t(e+d)} = 0;`)).join("\n");let f="";if(l<2&&u>0)f="coords";else if(l>1){const t=Ft(u),n=e.shape.map(((e,t)=>"coords."+_t(t+d))).join(", ");f=`${t}(${n})`}else f="coords";const m=`uniforms.${s.charAt(0).toLowerCase()+s.slice(1)}Shape`,g=u+"D";return n?`\n    fn ${a}Index(globalIndex : i32) -> vec4<f32> {\n      var coords = getCoordsFromIndex(globalIndex);\n      ${p}\n      return ${s}[getIndexFromCoords${g}(${f}, ${m}) / 4];\n    }\n\n    fn ${a}Coords(coordsIn : ${h}) -> vec4<f32> {\n      var coords = coordsIn;\n      ${p}\n      return ${s}[getIndexFromCoords${g}(${f}, ${m}) / 4];\n    }\n  `:`\n  fn ${a}Index(globalIndex : i32) -> f32 {\n    var coords = getCoordsFromIndex(globalIndex);\n    ${p}\n    return f32(${s}[getIndexFromCoords${g}(${f}, ${m})]);\n  }\n\n  fn ${a}Coords(coordsIn : ${h}) -> f32 {\n    var coords = coordsIn;\n    ${p}\n    return f32(${s}[getIndexFromCoords${g}(${f}, ${m})]);\n  }\n`}(e,t,n,i)),s}(e,t.shape,n.variableTypes?"vec4<f32>"===n.variableTypes[i]:n.isVec4,n.dispatchLayout.x.length===t.shape.length))).join("\n");h.push(c),h.push(n.getUserCode());const d=Wt(n);return h.push(zt(d,n)),h.join("\n")}(n,{dtype:i.dtype,shape:i.shape},t),r=e.createShaderModule({code:s,label:t.constructor.name});return e.createComputePipeline({compute:{module:r,entryPoint:"_start"},label:t.constructor.name,layout:"auto"})})(this.device,e,u,s),this.pipelineCache[l]=h),i&&(r=[...r,...i]);const c=[this.tensorToBinding(s),...t.map((e=>this.tensorToBinding(e))),this.makeUniforms(r)],d=this.device.createBindGroup({layout:h.getBindGroupLayout(0),entries:c.map(((e,t)=>({binding:t,resource:e})))});this.ensureCommandEncoderReady();const p=this.getComputePass(),f=null!=this.activeTimers;return f&&this.supportTimeQuery&&p.writeTimestamp(this.querySet,0),p.setPipeline(h),p.setBindGroup(0,d),p.dispatchWorkgroups(e.dispatch[0],e.dispatch[1],e.dispatch[2]),f&&this.supportTimeQuery&&p.writeTimestamp(this.querySet,1),this.dispatchNumberInEncoder++,t.forEach((e=>{this.commandQueueOwnedIds.add(e.dataId)})),this.commandQueueOwnedIds.add(s.dataId),Object(o.ad)().get("WEBGPU_DEFERRED_SUBMIT_BATCH_SIZE")<=this.dispatchNumberInEncoder&&this.submitQueue(),f&&this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(this.querySet)}),s}async getTimeFromQuerySet(e){const t=this.bufferManager.acquireBuffer(16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),n=this.bufferManager.acquireBuffer(16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);this.ensureCommandEncoderReady(),this.ensureComputePassEnded(),this.currentCommandEncoder.resolveQuerySet(e,0,2,t,0),this.currentCommandEncoder.copyBufferToBuffer(t,0,n,0,16),this.submitQueue(),await n.mapAsync(GPUMapMode.READ);const r=new BigUint64Array(n.getMappedRange()),i=Number(r[1]-r[0]);return n.unmap(),this.bufferManager.releaseBuffer(n,16,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),this.bufferManager.releaseBuffer(t,16,GPUBufferUsage.COPY_SRC|GPUBufferUsage.QUERY_RESOLVE),i/1e6}shouldExecuteOnCPU(e,t=Zt){return Object(o.ad)().getBool("WEBGPU_CPU_FORWARD")&&e.every((e=>null==this.tensorMap.get(e.dataId).resourceInfo&&o.Ed.sizeFromShape(e.shape)<t))}numDataIds(){return this.tensorMap.numDataIds()-this.tensorDataPendingDisposal.length}dispose(){this.disposed||(this.bufferManager.dispose(),this.textureManager.dispose(),this.disposed=!0)}}var en;Jt.nextDataId=0,qt()&&Object(o.md)("webgpu",(async()=>{Object(o.ad)().set("CHECK_COMPUTATION_FOR_ERRORS",!1);const e={powerPreference:Object(o.ad)().get("WEBGPU_USE_LOW_POWER_GPU")?"low-power":"high-performance"},t=await navigator.gpu.requestAdapter(e),n={};t.features.has("timestamp-query-inside-passes")&&(n.requiredFeatures=["timestamp-query-inside-passes"]);const r=t.limits;n.requiredLimits={maxComputeWorkgroupStorageSize:r.maxComputeWorkgroupStorageSize,maxComputeWorkgroupsPerDimension:r.maxComputeWorkgroupsPerDimension,maxStorageBufferBindingSize:r.maxStorageBufferBindingSize};const i=await t.requestDevice(n),s=await t.requestAdapterInfo();return new Jt(i,s)}),3),function(e){e[e.ADD=0]="ADD",e[e.ATAN2=1]="ATAN2",e[e.COMPLEX_MULTIPLY_IMAG=2]="COMPLEX_MULTIPLY_IMAG",e[e.COMPLEX_MULTIPLY_REAL=3]="COMPLEX_MULTIPLY_REAL",e[e.DIV=4]="DIV",e[e.EQUAL=5]="EQUAL",e[e.GREATER=6]="GREATER",e[e.GREATER_EQUAL=7]="GREATER_EQUAL",e[e.INT_DIV=8]="INT_DIV",e[e.LESS=9]="LESS",e[e.LESS_EQUAL=10]="LESS_EQUAL",e[e.LOGICAL_AND=11]="LOGICAL_AND",e[e.LOGICAL_OR=12]="LOGICAL_OR",e[e.MAX=13]="MAX",e[e.MIN=14]="MIN",e[e.MOD=15]="MOD",e[e.MUL=16]="MUL",e[e.NOT_EQUAL=17]="NOT_EQUAL",e[e.POW=18]="POW",e[e.PRELU=19]="PRELU",e[e.SQUARED_DIFFERENCE=20]="SQUARED_DIFFERENCE",e[e.SUB=21]="SUB"}(en||(en={}));const tn="\n  if (isnan(a)) { return a; }\n  if (isnan(b)) { return b; }\n  ",nn="\n  resultTemp = select(\n      resultTemp, vec4<f32>(valueForNaN),\n      vec4<bool>(isNaN) | isnanVec4(a) | isnanVec4(b));\n  ",rn=`\n  ${tn}\n  if (b == 0.) {\n    return uniforms.NAN;\n  }\n  var resultTemp = a % b;\n  if ((a < 0. && b < 0.) || (a >= 0. && b > 0.)) {\n    return resultTemp;\n  } else {\n    return (resultTemp + b) % b;\n  }\n`,on=`\n  let isNaN = !vec4<bool>(b);\n  let valueForNaN = uniforms.NAN;\n  var resultTemp = vec4<f32>(a % b);\n  ${nn}\n\n  if (!((a[0] < 0. && b[0] < 0.) || (a[0] >= 0. && b[0] > 0.))) {\n    resultTemp[0] = (resultTemp[0] + b[0]) % b[0];\n  }\n  if (!((a[1] < 0. && b[1] < 0.) || (a[1] >= 0. && b[1] > 0.))) {\n    resultTemp[1] = (resultTemp[1] + b[1]) % b[1];\n  }\n  if (!((a[2] < 0. && b[2] < 0.) || (a[2] >= 0. && b[2] > 0.))) {\n    resultTemp[2] = (resultTemp[2] + b[2]) % b[2];\n  }\n  if (!((a[3] < 0. && b[3] < 0.) || (a[3] >= 0. && b[3] > 0.))) {\n    resultTemp[3] = (resultTemp[3] + b[3]) % b[3];\n  }\n\n  return resultTemp;\n`,an=`\n  var resultTemp = vec4<f32>(a != b);\n  let valueForNaN = 1.0;\n  ${nn}\n\n  return resultTemp;\n`,sn=`\n  let isModRound1Bool = vec4<i32>(round(abs(b) % vec4<f32>(2.0))) == vec4<i32>(1);\n  let isModRound1 = vec4<f32>(isModRound1Bool);\n  let multiplier = sign(a) * isModRound1 + (vec4<f32>(1.0) - isModRound1);\n  var resultTemp = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  let isExpZero = b == vec4<f32>(0.0);\n  if (isExpZero.r) {\n    resultTemp.r = 1.0;\n  }\n  if (isExpZero.g) {\n    resultTemp.g = 1.0;\n  }\n  if (isExpZero.b) {\n    resultTemp.b = 1.0;\n  }\n  if (isExpZero.a) {\n    resultTemp.a = 1.0;\n  }\n  let isNaN = (a < vec4<f32>(0.0)) & (floor(b) < b);\n  let valueForNaN = uniforms.NAN;\n  ${nn}\n  return resultTemp;\n`;function un(e,t,n="uniforms.NAN"){const r=t?nn:tn;return t?`\n    let valueForNaN = ${n};\n    var resultTemp = vec4<f32>(${e}(a, b));\n    `+r+"\n    return resultTemp;\n  ":r+`\n    return ${e}(a, b);\n  `}function ln(e,t){switch(e){case en.ADD:return"return a + b;";case en.ATAN2:return un("atan2",t);case en.COMPLEX_MULTIPLY_IMAG:return"return areal * bimag + aimag * breal;";case en.COMPLEX_MULTIPLY_REAL:return"return areal * breal - aimag * bimag;";case en.DIV:return"return a / b;";case en.EQUAL:return t?"return vec4<f32>(a == b);":"return f32(a == b);";case en.GREATER:return t?"return vec4<f32>(a > b);":"return f32(a > b);";case en.GREATER_EQUAL:return t?"return vec4<f32>(a >= b);":"return f32(a >= b);";case en.INT_DIV:return t?"\n  let ia = vec4<i32>(round(a));\n  let ib = vec4<i32>(round(b));\n  let cond = ib != vec4<i32>(0);\n  var resultTemp = vec4<i32>(0);\n  let s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    resultTemp[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    resultTemp[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    resultTemp[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    resultTemp[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4<f32>(resultTemp);\n":"\n  let s = sign(a) * sign(b);\n  let ia = i32(round(a));\n  let ib = i32(round(b));\n  return f32(idiv(ia, ib, s));\n";case en.LESS:return t?"return vec4<f32>(a < b);":"return f32(a < b);";case en.LESS_EQUAL:return t?"return vec4<f32>(a <= b);":"return f32(a <= b);";case en.LOGICAL_AND:return t?"return (vec4<f32>(a >= vec4<f32>(1.0)) *\n  vec4<f32>(b >= vec4<f32>(1.0)));":"return f32(a >= 1.0 && b >= 1.0);";case en.LOGICAL_OR:return t?"return min(vec4<f32>(a >= vec4<f32>(1.0)) +\n  vec4<f32>(b >= vec4<f32>(1.0)), vec4<f32>(1.0));":"return f32(a >= 1.0 || b >= 1.0);";case en.MAX:return un("max",t);case en.MIN:return un("min",t);case en.MOD:return t?on:rn;case en.MUL:return"return a * b;";case en.NOT_EQUAL:return t?an:"\n  if (isnan(a) || isnan(b)) {\n    return 1.0;\n  }\n  return f32(a != b);\n";case en.POW:return t?sn:"\n  if(a < 0.0 && floor(b) < b) {\n    return uniforms.NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  if (round(abs(b) % 2.0) != 1.0) {\n    return pow(abs(a), b);\n  }\n  return sign(a) * pow(abs(a), b);\n";case en.PRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (b * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return b * a; }  return a;";case en.SQUARED_DIFFERENCE:return"return (a - b) * (a - b);";case en.SUB:return"return a - b;";default:throw new Error(`BinaryType ${e} is not implemented!`)}}var hn;!function(e){e[e.ABS=0]="ABS",e[e.ACOS=1]="ACOS",e[e.ACOSH=2]="ACOSH",e[e.ASIN=3]="ASIN",e[e.ASINH=4]="ASINH",e[e.ATAN=5]="ATAN",e[e.ATANH=6]="ATANH",e[e.CEIL=7]="CEIL",e[e.COS=8]="COS",e[e.COSH=9]="COSH",e[e.ELU=10]="ELU",e[e.ERF=11]="ERF",e[e.EXP=12]="EXP",e[e.EXPM1=13]="EXPM1",e[e.FLOOR=14]="FLOOR",e[e.IS_FINITE=15]="IS_FINITE",e[e.IS_INF=16]="IS_INF",e[e.IS_NAN=17]="IS_NAN",e[e.LINEAR=18]="LINEAR",e[e.LOG=19]="LOG",e[e.LOG1P=20]="LOG1P",e[e.LOGICAL_NOT=21]="LOGICAL_NOT",e[e.NEG=22]="NEG",e[e.RELU=23]="RELU",e[e.RELU6=24]="RELU6",e[e.LEAKYRELU=25]="LEAKYRELU",e[e.RECIPROCAL=26]="RECIPROCAL",e[e.ROUND=27]="ROUND",e[e.RSQRT=28]="RSQRT",e[e.SELU=29]="SELU",e[e.SIGMOID=30]="SIGMOID",e[e.SIGN=31]="SIGN",e[e.SIN=32]="SIN",e[e.SINH=33]="SINH",e[e.SOFTPLUS=34]="SOFTPLUS",e[e.SQRT=35]="SQRT",e[e.SQUARE=36]="SQUARE",e[e.STEP=37]="STEP",e[e.TAN=38]="TAN",e[e.TANH=39]="TANH",e[e.TO_INT=40]="TO_INT"}(hn||(hn={}));const cn=`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  let p = ${o.Oc.ERF_P};\n  let a1 = ${o.Oc.ERF_A1};\n  let a2 = ${o.Oc.ERF_A2};\n  let a3 = ${o.Oc.ERF_A3};\n  let a4 = ${o.Oc.ERF_A4};\n  let a5 = ${o.Oc.ERF_A5};\n\n  let sign = sign(a);\n  let absA = abs(a);\n  let t = 1.0 / (1.0 + p * absA);\n  return sign * (1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp(-absA * absA));\n`,dn=`\n  if (a >= 0.0) {\n    return ${o.Oc.SELU_SCALE} * a;\n  } else {\n    return ${o.Oc.SELU_SCALEALPHA} * (exp(a) - 1.0);\n  }\n`;function pn(e,t){switch(e){case hn.ABS:return"return abs(a);";case hn.ACOS:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return acos(a);\n";case hn.ACOSH:return"\n  if (a < 1.) {\n    return uniforms.NAN;\n  }\n  return acosh(a);\n";case hn.ASIN:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  return asin(a);\n";case hn.ASINH:return"return asinh(a);";case hn.ATAN:return"\n  if (isnan(a)) {\n    return uniforms.NAN;\n  }\n  return atan(a);\n";case hn.ATANH:return"\n  if (abs(a) > 1.) {\n    return uniforms.NAN;\n  }\n  if (a == 1.) {\n    return uniforms.INFINITY;\n  }\n  if (a == -1.) {\n    return -uniforms.INFINITY;\n  }\n  return atanh(a);\n";case hn.COS:return"return cos(a);";case hn.COSH:return"\n  let e2x = exp(-a);\n  return (e2x + 1.0 / e2x) / 2.0;\n";case hn.CEIL:return"return ceil(a);";case hn.ELU:return t?"\n  var resFloat = exp(a) - vec4<f32>(1.0);\n  if (a.r >= 0.0) {\n    resFloat.r = a.r;\n  }\n  if (a.g >= 0.0) {\n    resFloat.g = a.g;\n  }\n  if (a.b >= 0.0) {\n    resFloat.b = a.b;\n  }\n  if (a.a >= 0.0) {\n    resFloat.a = a.a;\n  }\n  return resFloat;\n":"if (a >= 0.0) { return a; }  return (exp(a) - 1.0);";case hn.ERF:return cn;case hn.EXP:return"return exp(a);";case hn.EXPM1:return"return exp(a) - 1.0;";case hn.FLOOR:return"return floor(a);";case hn.IS_FINITE:return"return f32(!isnan(a) && !isinf(a));";case hn.IS_INF:return"return f32(isinf(a));";case hn.IS_NAN:return"return f32(isnan(a));";case hn.LINEAR:return"return a;";case hn.LOG:return"if (a < 0.0) { return uniforms.NAN; }\n  return log(a);";case hn.LOG1P:return"\n  if (isnan(a)) { return a; }\n  return log(1.0 + a);\n";case hn.LOGICAL_NOT:return"return f32(!(a >= 1.0));";case hn.NEG:return"return -a;";case hn.LEAKYRELU:return t?"\n  let aLessThanZero = vec4<f32>(a < vec4<f32>(0.0));\n  return (aLessThanZero * (uniforms.alpha * a)) + ((vec4<f32>(1.0) - aLessThanZero) * a);\n":"if (a < 0.0) { return uniforms.alpha * a; } return a;";case hn.RECIPROCAL:return"return 1.0 / a;";case hn.RELU:return t?"\n  return select(a, vec4<f32>(0.0), a < vec4<f32>(0.0));\n":"return select(a, 0.0, a < 0.0);";case hn.RELU6:return t?"return clamp(a, vec4<f32>(0.0, 0.0, 0.0, 0.0), vec4<f32>(6.0, 6.0, 6.0, 6.0));":"return clamp(a, 0.0, 6.0);";case hn.ROUND:return"return round(a);";case hn.RSQRT:return"return inverseSqrt(a);";case hn.SELU:return dn;case hn.SIGMOID:return"return 1.0 / (1.0 + exp(-1.0 * a));";case hn.SIGN:return"return sign(a);";case hn.SIN:return"return sin(a);";case hn.SINH:return"\n  let e2x = exp(a);\n  return (e2x - 1.0 / e2x) / 2.0;\n";case hn.SOFTPLUS:return"\n  let epsilon = 1.1920928955078125e-7;\n  let threshold = log(epsilon) + 2.0;\n\n  let too_large = a > -threshold;\n  let too_small = a < threshold;\n  let exp_a = exp(a);\n\n  if (too_large) {\n    return a;\n  } else if (too_small) {\n    return exp_a;\n  } else {\n    return log(exp_a + 1.0);\n  }\n";case hn.SQRT:return"return sqrt(a);";case hn.SQUARE:return"return a * a;";case hn.STEP:return"\n  if (isnan(a)) {\n    return a;\n  }\n\n  return select(uniforms.stepAlpha, 1.0, a > 0.0);\n";case hn.TAN:return"return tan(a);";case hn.TANH:return"\n  let e2x = exp(-2.0 * abs(a));\n  return sign(a) * (1.0 - e2x) / (1.0 + e2x);\n";case hn.TO_INT:return"return f32(i32((a)));";default:throw new Error(`BinaryType ${e} is not implemented!`)}}const fn=e=>{switch(e){case 1:return"f32";case 2:return"vec2<f32>";case 3:return"vec3<f32>";case 4:return"vec4<f32>";default:throw new Error(e+"-component is not supported.")}};function mn(e,t=!1,n=!1,r=3){if(null===e)return"";let i="";if("linear"===e)i=pn(hn.LINEAR);else if("relu"===e)i=pn(hn.RELU,n);else if("elu"===e)i=pn(hn.ELU,n);else if("relu6"===e)i=pn(hn.RELU6,n);else if("prelu"===e)i=ln(en.PRELU,n);else if("sigmoid"===e)i=pn(hn.SIGMOID,n);else{if("leakyrelu"!==e)throw new Error(`Activation ${e} has not been implemented for the WebGPU backend.`);i=pn(hn.LEAKYRELU,n)}const s=fn(n?4:1);let o="";return o=t?`\n      fn activation(a : ${s}, coords : vec${r}<i32>) -> ${s} {\n        let b = getPreluActivationWeightsByOutputCoords(coords);\n        ${i}\n      }`:`\n      fn activation(a : ${s}, coords : vec${r}<i32>) -> ${s} {\n        ${i}\n      }`,o}function gn(e,t){return`\n      ${e?"value = value + getBiasByOutputCoords(coords);":""}\n      ${t?"value = activation(value, coords);":""}\n      `}function bn(e,t,n=!1,i=!1,s=!1,r=1){o.Ed.assert(e&&1===r||!e,(()=>`transposeA ${e} is not compatible with component size ${r}`));const a=`\n      ${e?"value = getA(batch, col, row);":"value = getA(batch, row, col);"}\n\n    `,u=t?"value = getB(batch, col, row);":"value = getB(batch, row, col);";return`\n  fn mm_readA(batch: i32, row: i32, colIn: i32) -> ${fn(r)} {\n    var value = ${fn(r)}(0.0);\n    let col = colIn * ${r};\n    ${n&&s?a:`\n    ${e?"if(row < uniforms.dimAOuter && col < uniforms.dimInner)":"if(row < uniforms.aShape[1] && col < uniforms.aShape[2])"}\n    {\n      ${a}\n    }\n    `}\n    return value;\n  }\n\n  fn mm_readB(batch: i32, row: i32, colIn: i32) -> ${fn(r)} {\n    let col = colIn * ${r};\n    var value = ${fn(r)}(0.0);\n    ${u}\n    return value;\n  }\n  `}function yn(e,t,n,r,i=!1,s=!1,o=!1,a=1){return`\n  ${bn(n,r,i,s,o,a)}\n  fn mm_write(batch: i32, row: i32, colIn: i32, valueIn: ${fn(a)}) {\n    let col = colIn * ${a};\n    ${i&&s?"":"if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)"}\n    {\n      var value = valueIn;\n      let coords = vec3<i32>(batch, row, col);\n      ${gn(e,t)}\n      setOutputAtCoords(coords[0], coords[1], coords[2], value);\n    }\n  }\n  `}function xn(e,t,n=!1,i=32,s=!1,r=32,a=!1,u=!1){const l=t[1]*e[1],h=t[0]*e[0],c=n?l:i,d=n?i:l,p=c/t[0],f=i/t[1],m=e[1];return o.Ed.assert((n&&4===p&&4===e[1]||!n&&(3===p||4===p))&&c%t[0]==0&&i%t[1]==0&&4===e[0],(()=>`If transposeA ${n} is true, innerElementSize ${p} and workPerThread[1] ${e[1]} must be 4.\n          Otherwise, innerElementSize ${p} must be 3 or 4.\n      tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}. tileInner ${i} must be divisible by workgroupSize[1] ${t[1]}. colPerThread ${e[0]} must be 4.`)),`\n  var<workgroup> mm_Asub : array<array<vec${p}<f32>, ${c/p}>, ${d}>;\n  var<workgroup> mm_Bsub : array<array<vec4<f32>, ${h/e[0]}>, ${i}>;\n\n  ${Nt()} {\n    let localRow = i32(localId.y);\n    let tileRow = ${a?"0":"localRow * "+m};\n    let tileCol = i32(localId.x);\n\n    let globalRow = ${a?"0":"i32(globalId.y) * "+m};\n    let globalCol = i32(globalId.x);\n    let batch = ${s?"0":"i32(globalId.z)"};\n    let batchA = ${s||!u?"batch":"batch % uniforms.aShape[0]"};\n    let batchB = ${s||!u?"batch":"batch % uniforms.bShape[0]"};\n    let globalRowStart = i32(workgroupId.y) * ${l};\n\n    let numTiles = ${s?""+Math.ceil(r/i):`(uniforms.dimInner - 1) / ${i} + 1`};\n    var kStart = ${s?"i32(globalId.z) * "+r:"0"};\n\n    var acc: array<vec4<f32>, ${m}>;\n\n    // Loop over shared dimension.\n    let tileRowB = localRow * ${f};\n    for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var innerRow = 0; innerRow < ${m}; innerRow++) {\n            let inputRow = tileRow + innerRow;\n            let inputCol = tileCol;\n            ${((e,t)=>e?`\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart / ${t} + inputCol);\n        `:`\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRow + innerRow,\n          kStart / ${t} + inputCol);\n        `)(n,p)}\n        }\n\n        // Load one tile of B into local memory.\n        for (var innerRow = 0; innerRow < ${f}; innerRow++) {\n            let inputRow = tileRowB + innerRow;\n            let inputCol = tileCol;\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB, kStart + inputRow, globalCol);\n        }\n        kStart = kStart + ${i};\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < ${i/p}; k++) {\n            let BCached0 = mm_Bsub[k * ${p}][tileCol];\n            let BCached1 = mm_Bsub[k * ${p} + 1][tileCol];\n            let BCached2 = mm_Bsub[k * ${p} + 2][tileCol];\n            ${3===p?"":`let BCached3 = mm_Bsub[k * ${p} + 3][tileCol];`}\n\n            ${((e,t,n)=>e?`\n        let ACached0 = mm_Asub[k * ${t}][localRow];\n        let ACached1 = mm_Asub[k * ${t} + 1][localRow];\n        let ACached2 = mm_Asub[k * ${t} + 2][localRow];\n        ${3===t?"":`let ACached3 = mm_Asub[k * ${t} + 3][localRow];`}\n        for (var i = 0; i < ${n}; i++) {\n          acc[i] = BCached0 * ACached0[i] + acc[i];\n          acc[i] = BCached1 * ACached1[i] + acc[i];\n          acc[i] = BCached2 * ACached2[i] + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached3[i] + acc[i];"}\n        }`:`\n        for (var i = 0; i < ${n}; i++) {\n          let ACached = mm_Asub[tileRow + i][k];\n          acc[i] = BCached0 * ACached.x + acc[i];\n          acc[i] = BCached1 * ACached.y + acc[i];\n          acc[i] = BCached2 * ACached.z + acc[i];\n          ${3===t?"":"acc[i] = BCached3 * ACached.w + acc[i];"}\n        }`)(n,p,m)}\n        }\n\n        workgroupBarrier();\n    }\n\n    for (var innerRow = 0; innerRow < ${m}; innerRow++) {\n        mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);\n    }\n  }`}const vn=e=>e?"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          kStart + inputRow,\n          globalRowStart + inputCol);\n        ":"\n        mm_Asub[inputRow][inputCol] = mm_readA(batchA,\n          globalRowStart + inputRow,\n          kStart + inputCol);\n        ";function wn(e,t,n=!1,i=32,s=!1,r=32,a=!1,u=!1){const l=e[1]*t[1],h=e[0]*t[0],c=n?l:i,d=n?i:l;o.Ed.assert(d%t[1]==0&&c%t[0]==0&&i%t[1]==0,(()=>`tileAHight ${d} must be divisible by workgroupSize[1]${t[1]}, tileAWidth ${c} must be divisible by workgroupSize[0]${t[0]}, tileInner ${i} must be divisible by workgroupSize[1]${t[1]}`));const p=d/t[1],f=c/t[0],m=i/t[1],g=e[1],y=e[0],x=a?`\n      let localRow = i32(localId.y);\n      let localCol = i32(localId.x);\n      let globalRowStart = i32(workgroupId.y) * ${l};\n      let globalColStart = i32(workgroupId.x) * ${h};\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        for (var inputRow = localRow; inputRow < ${d}; inputRow = inputRow + ${t[1]}) {\n          for (var inputCol = localCol; inputCol < ${c}; inputCol = inputCol + ${t[0]}) {\n            ${vn(n)}\n          }\n        }\n        // Load one tile of B into local memory.\n        for (var inputRow = localRow; inputRow < ${i}; inputRow = inputRow + ${t[1]}) {\n              for (var inputCol = localCol; inputCol < ${h}; inputCol = inputCol + ${t[0]}) {\n            mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n              kStart + inputRow,\n              globalColStart + inputCol);\n          }\n        }\n        kStart = kStart + ${i};\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        var BCached : array<f32, ${y}>;\n        for (var k = 0; k < ${i}; k++) {\n          for (var inner = 0; inner < ${y}; inner++) {\n            BCached[inner] = mm_Bsub[k][localCol + inner * ${t[0]}];\n          }\n          for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n            let ACached = ${n?`mm_Asub[k][localRow + innerRow * ${t[1]}];`:`mm_Asub[localRow + innerRow * ${t[1]}][k];`}\n            for (var innerCol = 0; innerCol < ${y}; innerCol++) {\n              acc[innerRow][innerCol] = acc[innerRow][innerCol] +\n                  ACached * BCached[innerCol];\n            }\n          }\n        }\n        workgroupBarrier();\n      }\n      for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n        let gRow = globalRowStart + localRow + innerRow * ${t[1]};\n        for (var innerCol = 0; innerCol < ${y}; innerCol++) {\n          let gCol = globalColStart + localCol + innerCol * ${t[0]};\n          mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);\n        }\n      }\n      `:`\n  let tileRow = i32(localId.y) * ${g};\n  let tileCol = i32(localId.x) * ${y};\n\n  let globalRow = i32(globalId.y) * ${g};\n  let globalCol = i32(globalId.x) * ${y};\n  let globalRowStart = i32(workgroupId.y) * ${l};\n\n  let tileRowA = i32(localId.y) * ${p};\n  let tileColA = i32(localId.x) * ${f};\n  let tileRowB = i32(localId.y) * ${m};\n  // Loop over shared dimension.\n  for (var t = 0; t < numTiles; t++) {\n    // Load one tile of A into local memory.\n    for (var innerRow = 0; innerRow < ${p}; innerRow++) {\n      for (var innerCol = 0; innerCol < ${f}; innerCol++) {\n        let inputRow = tileRowA + innerRow;\n        let inputCol = tileColA + innerCol;\n        ${vn(n)}\n      }\n    }\n\n    // Load one tile of B into local memory.\n    for (var innerRow = 0; innerRow < ${m}; innerRow++) {\n      for (var innerCol = 0; innerCol < ${y}; innerCol++) {\n        let inputRow = tileRowB + innerRow;\n        let inputCol = tileCol + innerCol;\n        mm_Bsub[inputRow][inputCol] = mm_readB(batchB,\n          kStart + inputRow,\n          globalCol + innerCol);\n      }\n    }\n    kStart = kStart + ${i};\n    workgroupBarrier();\n\n    // Compute acc values for a single thread.\n    var BCached : array<f32, ${y}>;\n    for (var k = 0; k < ${i}; k++) {\n      for (var inner = 0; inner < ${y}; inner++) {\n        BCached[inner] = mm_Bsub[k][tileCol + inner];\n      }\n\n      for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n        ${(e=>e?"let ACached = mm_Asub[k][tileRow + innerRow];":"let ACached = mm_Asub[tileRow + innerRow][k];")(n)}\n        for (var innerCol = 0; innerCol < ${y}; innerCol++) {\n          acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];\n        }\n      }\n    }\n\n    workgroupBarrier();\n  }\n\n  for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n    for (var innerCol = 0; innerCol < ${y}; innerCol++) {\n      mm_write(batch, globalRow + innerRow, globalCol + innerCol,\n          acc[innerRow][innerCol]);\n    }\n  }\n  `;return`\n    var<workgroup> mm_Asub : array<array<f32, ${c}>, ${d}>;\n    var<workgroup> mm_Bsub : array<array<f32, ${h}>, ${i}>;\n\n    ${Nt()} {\n      let batch = ${s?"0":"i32(globalId.z)"};\n      let batchA = ${s||!u?"batch":"batch % uniforms.aShape[0]"};\n      let batchB = ${s||!u?"batch":"batch % uniforms.bShape[0]"};\n      let numTiles = ${s?""+Math.ceil(r/i):`(uniforms.dimInner - 1) / ${i} + 1`};\n      var kStart = ${s?"i32(globalId.z) * "+r:"0"};\n\n      var acc : array<array<f32, ${y}>, ${g}>;\n\n      // Without this initialization strange values show up in acc.\n      for (var innerRow = 0; innerRow < ${g}; innerRow++) {\n        for (var innerCol = 0; innerCol < ${y}; innerCol++) {\n          acc[innerRow][innerCol] = 0.0;\n        }\n      }\n      ${x}\n    }\n  `}class kn{constructor(e,t,n=!1,r=!1,i=null,s=null,o=null,a=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=t,this.dispatchLayout={x:[2],y:[1],z:[0]};const u=n?e[1]:e[2];if(this.isVec4=(u%4==0&&!n||t[1]%4==0&&n)&&t[2]%4==0&&!r,this.isVectorA=1===t[1]&&!n,!this.isVec4&&this.isVectorA)this.elementsPerThread=[1,1,1],this.workgroupSize=[32,1,1];else{const e=function(e,t,n,r=!1){const i=[8,8,1],s=[4,4,1];return r||(e<=8&&(s[1]=1),t<=16&&n<=16&&(i[0]=4)),{workgroupSize:i,elementsPerThread:s}}(t[1],u,t[2],n);this.workgroupSize=e.workgroupSize,this.elementsPerThread=e.elementsPerThread}this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread);const l=null!=i,h=null!=o;l&&this.variableNames.push("bias"),h&&this.variableNames.push("preluActivationWeights"),this.sequentialAccessByThreads=a,this.transposeA=n,this.transposeB=r,this.addBias=l,this.activation=s,this.hasPreluActivationWeights=h,[this.fitAOuter,this.fitBOuter,this.fitInner]=this.getShapeFit(t[1],t[2],u),this.shaderKey=`matMulPacked_${this.elementsPerThread}_${n}_${r}_${this.activation}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.isVectorA}_${this.sequentialAccessByThreads}`}getShapeFit(e,t,n){const r=this.workgroupSize[1]*this.elementsPerThread[1],i=this.workgroupSize[0]*this.elementsPerThread[0];return!this.isVec4&&this.isVectorA?this.tileInner=4*this.workgroupSize[0]:this.tileInner=i,[e%r==0,t%i==0,n%this.tileInner==0]}getUserCode(){return`\n      ${mn(this.activation,this.hasPreluActivationWeights,this.isVec4)}\n      ${yn(this.addBias,this.activation,!1,this.transposeB,this.fitAOuter,this.fitBOuter,this.fitInner,this.isVec4?4:1)}\n      ${this.isVec4?xn(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.isVectorA,!0):this.isVectorA?function(e,t=!1){o.Ed.assert(1===e[1]&&1===e[2],(()=>`A linear work group size is required. But got ${e}.`));const n=4*e[0];return`\n    var<workgroup> mm_Asub : array<vec4<f32>, ${e[0]}>;\n\n    ${Nt()} {\n      let tileCol = i32(localId.x);\n      let globalCol = i32(globalId.x);\n      let globalRow = i32(globalId.y);\n\n      let numTiles = (uniforms.dimInner - 1) / ${n} + 1;\n      let batch = i32(globalId.z);\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      // Without this initialization strange values show up in acc.\n      var acc = 0.0;\n\n      // Loop over shared dimension.\n      for (var t = 0; t < numTiles; t++) {\n        // Load one tile of A into local memory.\n        let colA = t * ${n} + tileCol * 4;\n        mm_Asub[tileCol] = vec4<f32>(${(e=>e?"\n      mm_readA(batchA, colA, globalRow),\n      mm_readA(batchA, colA + 1, globalRow),\n      mm_readA(batchA, colA + 2, globalRow),\n      mm_readA(batchA, colA + 3, globalRow)\n  ":"\n      mm_readA(batchA, globalRow, colA),\n      mm_readA(batchA, globalRow, colA + 1),\n      mm_readA(batchA, globalRow, colA + 2),\n      mm_readA(batchA, globalRow, colA + 3)\n  ")(t)});\n        workgroupBarrier();\n\n        // Compute acc values for a single thread.\n        for (var k = 0; k < ${n/4}; k++) {\n          let rowB = t * ${n} + k * 4;\n          let BCached = vec4<f32>(mm_readB(batchB, rowB, globalCol),\n                              mm_readB(batchB, rowB + 1, globalCol),\n                              mm_readB(batchB, rowB + 2, globalCol),\n                              mm_readB(batchB, rowB + 3, globalCol));\n\n          let ACached = mm_Asub[k];\n          acc = acc + dot(ACached, BCached);\n        }\n\n        workgroupBarrier();\n      }\n\n      mm_write(batch, globalRow, globalCol, acc);\n    }\n  `}(this.workgroupSize,this.transposeA):wn(this.elementsPerThread,this.workgroupSize,this.transposeA,this.tileInner,!1,null,this.sequentialAccessByThreads,!0)}\n    `}}class Sn{constructor(e,t=!1,n=!1,r=null,i=null,s=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout={x:[],y:[1,2],z:[0]},this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize);const o=null!=r,a=null!=s;o&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),this.transposeA=t,this.transposeB=n,this.addBias=o,this.activation=i,this.hasPreluActivationWeights=a,this.shaderKey=`matMulReduce_${this.activation}_${t}_${n}`}getUserCode(){var e;return`\n      ${mn(this.activation,this.hasPreluActivationWeights)}\n      ${yn(this.addBias,this.activation,this.transposeA,this.transposeB)}\n      ${e=this.workgroupSize[0],`\n    var<workgroup> sumValues : array<f32, ${e}>;\n    ${Nt()} {\n      let coords = getOutputCoords();\n      let batch = coords[0];\n      let batchA = batch % uniforms.aShape[0];\n      let batchB = batch % uniforms.bShape[0];\n      let row = coords[1];\n      let col = coords[2];\n      var sum = 0.0;\n      let Length = uniforms.dimInner;\n      for (var k = i32(localId.x); k < Length; k = k + ${e}) {\n        let dataA = mm_readA(batchA, row, k);\n        let dataB = mm_readB(batchB, k, col);\n        sum = sum + dataA * dataB;\n      }\n      sumValues[localId.x] = sum;\n      workgroupBarrier();\n\n      for(var currentSize = ${e/2}u; currentSize > 1u;\n          currentSize = currentSize / 2u) {\n        if (localId.x < currentSize)\n        {\n          sumValues[localId.x] = sumValues[localId.x] + sumValues[localId.x + currentSize];\n        }\n        workgroupBarrier();\n      }\n\n      if (localId.x == 0u) {\n        sum = sumValues[0] + sumValues[1];\n        mm_write(batch, row, col, sum);\n      }\n    }\n  `}\n    `}}class In{constructor(e,t,n,r=!1,i=!1,s=null,o=null,a=null){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[16,8,1],this.outputShape=n,this.dispatchLayout={x:[2],y:[1],z:[0]},this.dispatch=[Math.ceil(n[2]/this.workgroupSize[0]),Math.ceil(n[1]/this.workgroupSize[1]),n[0]];const u=null!=s;u&&this.variableNames.push("bias");const l=null!=a;l&&this.variableNames.push("preluActivationWeights"),this.transposeA=r,this.transposeB=i,this.addBias=u,this.activation=o,this.hasPreluActivationWeights=l,this.shaderKey=`matMulSmallOutputSize_${this.activation}_${r}_${i}`}getUserCode(){return`\n      ${mn(this.activation,this.hasPreluActivationWeights)}\n      ${yn(this.addBias,this.activation,this.transposeA,this.transposeB)}\n      ${function(e){const t=e[1],n=e[0],r=t>n?t:n;return`\n  var<workgroup> mm_Asub : array<array<f32, ${r}>, ${t}>;\n  var<workgroup> mm_Bsub : array<array<f32, ${n}>, ${r}>;\n\n  // If the output size is small for matrix multiplication, avoid to use vec4\n  // and handle some elements per thread to optimally utilize the ALU.\n  // Read data from global memory to registers firstly, then store them into\n  // shared memory, so it is instruction-Level parallelism for arithmetic\n  // operations and others handle IO operations between barrier api, makes ALU\n  // and load/store units work simultaneously, could improves the performance.\n  ${Nt()} {\n    let tileRow = i32(localId.y);\n    let tileCol = i32(localId.x);\n    let globalRow = i32(globalId.y);\n    let globalCol = i32(globalId.x);\n    let batch = i32(globalId.z);\n    let batchA = batch % uniforms.aShape[0];\n    let batchB = batch % uniforms.bShape[0];\n\n    // uniforms.dimInner should be greater than 0.\n    let numTiles = (uniforms.dimInner - 1) / ${r} + 1;\n    var acc = 0.0;\n\n    var globalColA = tileCol;\n    var globalRowB = 0;\n    var regA = mm_readA(batchA, globalRow, globalColA);\n    var regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n    var regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n    globalColA = globalColA + ${r};\n    globalRowB = globalRowB + ${r};\n\n    for (var t = 0; t < numTiles; t = t + 1) {\n      mm_Asub[tileRow][tileCol] = regA;\n      mm_Bsub[2 * tileRow][tileCol] = regB0;\n      mm_Bsub[2 * tileRow + 1][tileCol] = regB1;\n\n      workgroupBarrier();\n\n      regA = mm_readA(batchA, globalRow, globalColA);\n      regB0 = mm_readB(batchB, globalRowB + 2 * tileRow, globalCol);\n      regB1 = mm_readB(batchB, globalRowB + 2 * tileRow + 1, globalCol);\n      globalColA = globalColA + ${r};\n      globalRowB = globalRowB + ${r};\n\n      for (var k = 0; k < ${r}; k = k + 1) {\n        acc = acc + mm_Asub[tileRow][k] * mm_Bsub[k][tileCol];\n      }\n      workgroupBarrier();\n    }\n\n    mm_write(batch, globalRow, globalCol, acc);\n  }\n  `}(this.workgroupSize)}\n    `}}class Cn{constructor(e,t,n=!1,i=!1){this.variableNames=["A","B"],this.uniforms="dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.workgroupSize=[8,8,1],this.atomic=!0,this.isVec4=!1,this.splitedDimInner=128,o.Ed.assert(1===e[0],(()=>"MatMulSplitKProgram only supports batch = 1.")),this.outputShape=e,this.dispatchLayout={x:[2],y:[1],z:[0,3]},this.isVec4=(n&&this.outputShape[1]%4==0||!n&&t%4==0)&&this.outputShape[2]%4==0,this.elementsPerThread=[4,4,this.splitedDimInner],this.isVec4||(this.outputShape[1]<16&&(this.elementsPerThread[1]=1),this.outputShape[2]<16&&(this.elementsPerThread[0]=1)),this.dispatch=Gt(this.dispatchLayout,[this.outputShape[0],this.outputShape[1],this.outputShape[2],t],this.workgroupSize,this.elementsPerThread),this.transposeA=n,this.transposeB=i,this.shaderKey=`matMulSplitK_${n}_${i}_${this.elementsPerThread}_${this.isVec4}`}getUserCode(){const e=this.isVec4?4:1;return`\n      ${bn(!1,this.transposeB,!1,!1,!1,e)}\n      fn mm_write(batch: i32, row : i32, colIn : i32, value : ${fn(e)}) {\n        let col = colIn * ${e};\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter) {\n          let coords = vec3<i32>(batch, row, col);\n          let flatIndex = getOutputIndexFromCoords(coords);\n          // The problem is that we should initialize output to zero before using.\n          // Otherwise, the original value will be added to the result.\n          for (var i = 0; i < ${e}; i = i + 1) {\n            ${$t("&result[flatIndex + i]",e>1?"value[i]":"value","float32")}\n          }\n        }\n      }\n      ${this.isVec4?xn(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner):wn(this.elementsPerThread,this.workgroupSize,this.transposeA,32,!0,this.splitedDimInner)}\n    `}}class On{constructor(e,t=null,n=null,r=null){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=null!=t,this.hasPreluActivationWeights=null!=r,this.activation=n,this.addBias&&this.variableNames.push("bias"),this.hasPreluActivationWeights&&this.variableNames.push("preluActivationWeights"),this.shaderKey="biasActivation_"+n}getUserCode(){return`\n    ${mn(this.activation,this.hasPreluActivationWeights)}\n    ${Nt("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        var value = getXByOutputIndex(index);\n        ${gn(this.addBias,this.activation)}\n        setOutputAtIndex(index, value);\n      }\n    }\n    `}}class An{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="value : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="fill"}getUserCode(){return`\n    ${Nt("index")} {\n      if (index < uniforms.size) {\n        setOutputAtIndex(index, uniforms.value);\n      }\n    }\n  `}}function Tn(e){const{backend:t,attrs:n}=e,{shape:i,value:s}=n;let{dtype:r}=n;if(r=r||o.Ed.inferDtype(s),"string"===r){const e=o.Ed.getArrayFromDType(r,o.Ed.sizeFromShape(i));return e.fill(s),t.makeTensorInfo(i,r,e)}{const e=new An(i),n=[{type:"float32",data:[s]}];return t.runWebGPUProgram(e,[],r,n)}}const En={kernelName:o.U,backendName:"webgpu",kernelFunc:Tn};function Rn(e){const{inputs:t,attrs:n}=e,{x:i}=t,{shape:s}=n,r=o.Ed.sizeFromShape(i.shape),a=o.Ed.inferFromImplicitShape(s,r),u=o.Ed.sizeFromShape(a);return o.Ed.assert(r===u,(()=>`The new shape (${a}) has ${u} elements and the old shape (${i.shape}) has ${r} elements. The new shape and old shape must have the same number of elements.`)),e.backend.incRef(i.dataId),{dataId:i.dataId,shape:a,dtype:i.dtype}}const Pn={kernelName:o.Xb,backendName:"webgpu",kernelFunc:Rn};function $n({a:e,b:t,transposeA:n,transposeB:i,backend:s,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:u=0,activation:l=null}){const h=e.shape.length,c=t.shape.length,d=n?e.shape[h-2]:e.shape[h-1],p=i?t.shape[c-1]:t.shape[c-2],f=n?e.shape[h-1]:e.shape[h-2],m=i?t.shape[c-2]:t.shape[c-1],g=e.shape.slice(0,-2),y=t.shape.slice(0,-2),x=o.Ed.sizeFromShape(g),b=o.Ed.sizeFromShape(y),v=o.Qc.assertAndGetBroadcastShape(e.shape.slice(0,-2),t.shape.slice(0,-2)).concat([f,m]);o.Ed.assert(d===p,(()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${e.shape} and ${t.shape} and transposeA=${n} and transposeB=${i} must match.`));const w=n?[x,d,f]:[x,f,d],k=i?[b,m,p]:[b,p,m],S=Rn({inputs:{x:e},backend:s,attrs:{shape:w}}),I=Rn({inputs:{x:t},backend:s,attrs:{shape:k}}),C=[S,I],O=Math.max(x,b),A=[S,I],T=[{type:"int32",data:[f]},{type:"int32",data:[m]},{type:"int32",data:[d]}];let E,R;const P=[O,f,m];let $=Object(o.ad)().get("WEBGPU_MATMUL_PROGRAM_TYPE");if($<0){const e=Object(o.ad)().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),t=e>0?e:s.thresholdToIncreaseWorkgroups,n=O*Math.ceil(f/32)*Math.ceil(m/32);$=n<=t||f<=8&&n<=2*t?O*f*m<=128?Qt.MatMulReduceProgram:1===O&&p>=2e3?Qt.MatMulSplitKProgram:Qt.MatMulSmallOutputSizeProgram:Qt.MatMulPackedProgram}switch($){case Qt.MatMulReduceProgram:E=new Sn(P,n,i,r,l,a);break;case Qt.MatMulSplitKProgram:if(R=Tn({backend:s,attrs:{shape:P,value:0,dtype:e.dtype}}),E=new Cn(P,p,n,i),r||l){R=s.runWebGPUProgram(E,A,e.dtype,T,R);const t=new On(R.shape,r,l,a);let n=null;const o=[R];r&&o.push(r),a&&o.push(a),"leakyrelu"===l&&(n=[{type:"float32",data:[u]}],t.uniforms+=" alpha : f32,");const i=s.runWebGPUProgram(t,o,R.dtype,n);C.push(R);const h=Rn({inputs:{x:i},backend:s,attrs:{shape:v}});C.push(i);for(const e of C)s.disposeData(e.dataId);return h}break;case Qt.MatMulSmallOutputSizeProgram:E=new In(w,k,P,n,i,r,l,a);break;case Qt.MatMulPackedProgram:const t=s.adapterInfo.isIntel();E=new kn(w,P,n,i,r,l,a,t);break;default:throw new Error(`Unsupported MatMulProgramType ${$}.`)}r&&A.push(r),a&&A.push(a),"leakyrelu"===l&&(T.push({type:"float32",data:[u]}),E.uniforms+=" alpha : f32,"),R=s.runWebGPUProgram(E,A,e.dtype,T,R);const F=Rn({inputs:{x:R},backend:s,attrs:{shape:v}});C.push(R);for(const e of C)s.disposeData(e.dataId);return F}const Fn={kernelName:o.Kc,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:i,b:s,bias:o,preluActivationWeights:a}=t,{transposeA:u,transposeB:l,activation:h,leakyreluAlpha:c}=r;return $n({a:i,b:s,transposeA:u,transposeB:l,backend:n,bias:o,preluActivationWeights:a,leakyreluAlpha:c,activation:h})}};class _n{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=o.Oc.assertAndGetBroadcastShape(t,n),this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="binaryOpComplex_"+e,this.op=e}getUserCode(){return`\n      fn binaryOpComplex(\n          areal : f32, aimag : f32, breal : f32, bimag : f32) -> f32 {\n        ${ln(this.op,!1)}\n      }\n\n      ${Nt("index")} {\n        if(index < uniforms.size) {\n          let areal = getARealByOutputIndex(index);\n          let aimag = getAImagByOutputIndex(index);\n          let breal = getBRealByOutputIndex(index);\n          let bimag = getBImagByOutputIndex(index);\n          setOutputAtIndex(index, binaryOpComplex(areal, aimag, breal, bimag));\n        }\n      }\n    `}}class Nn{constructor(e,t,n){this.size=!0,this.variableNames=["A","B"],this.outputShape=o.Oc.assertAndGetBroadcastShape(t,n),this.dispatchLayout=Xt(this.outputShape),this.op=e,this.useSharedMemoryWithA=t.length<=1&&n.length>1&&t[0]<128,this.useSharedMemoryWithB=n.length<=1&&t.length>1&&n[0]<128,this.useSharedMemoryWithA||this.useSharedMemoryWithB?(this.isVec4=!1,this.lastDimensionSize=this.useSharedMemoryWithB?n[0]:t[0],this.shaderKey=`binary_${this.type}_${e}_${this.lastDimensionSize}_${this.useSharedMemoryWithB}`,this.type="shared",this.workgroupSize=[256,1,1],this.workPerThread=1):(o.Ed.arraysEqual(t,n)&&o.Ed.sizeFromShape(t)%4==0?(this.isVec4=!0,this.type="vec4",this.workPerThread=4):(this.isVec4=!1,this.type="plain",this.workPerThread=1),this.shaderKey=`binary_${this.type}_${e}`,this.workgroupSize=[128,1,1]),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1])}getUserCode(){let e;const t=this.isVec4?"vec4<f32>":"f32",n=`\n    fn binaryOperation(a : ${t}, b : ${t}) -> ${t} {\n      let isNaN = false;\n      {\n        ${ln(this.op,this.isVec4)}\n      }\n    };\n    `;if("shared"===this.type){const t=this.lastDimensionSize>1?`coords[${this.outputShape.length-1}]`:"0",r=this.useSharedMemoryWithB?`let a = getAByOutputIndex(index);\n          let b = sharedBuf[${t}];`:`let a = sharedBuf[${t}];\n          let b = getBByOutputIndex(index);`;e=`\n        ${n}\n        var<workgroup> sharedBuf : array<f32, ${this.lastDimensionSize}>;\n        ${Nt("index")} {\n          // Fill in the shared memory buffer.\n          let localIndex = i32(localId.x);\n          if(localIndex < ${this.lastDimensionSize}) {\n            sharedBuf[localIndex] = f32(${this.useSharedMemoryWithB?"B":"A"}[localIndex]);\n          }\n          workgroupBarrier();\n\n          if(index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            ${r}\n            setOutputAtIndex(index, binaryOperation(a, b));\n          }\n        }\n        `}else e=`\n       ${n}\n       ${Nt("index")} {\n         if (index < uniforms.size) {\n           let a = getAByOutputIndex(index);\n           let b = getBByOutputIndex(index);\n           setOutputAtIndex(index, binaryOperation(a, b));\n         }\n       }\n       `;return e}}function zn(e){const{inputs:t}=e,{x:n}=t;return e.backend.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}const Mn={kernelName:o.hb,backendName:"webgpu",kernelFunc:zn};function Ln(e){const{inputs:t,backend:n}=e,{real:r,imag:i}=t,s=n.makeTensorInfo(r.shape,"complex64"),o=n.tensorMap.get(s.dataId),a=zn({inputs:{x:r},backend:n}),u=zn({inputs:{x:i},backend:n});return o.complexTensorInfos={real:a,imag:u},s}const Bn={kernelName:o.w,backendName:"webgpu",kernelFunc:Ln};class Un{constructor(e,t,n=""){this.variableNames=["A"],this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=e,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.op=t,""!==n&&(this.uniforms=n),this.shaderKey="unary_"+t}getUserCode(){return`\n      fn unaryOperation(a : f32) -> f32 {\n        ${pn(this.op,!1)}\n      }\n      ${Nt("index")} {\n        if (index < uniforms.size) {\n          let a = getAByOutputIndex(index);\n          setOutputAtIndex(index, unaryOperation(a));\n        }\n      }\n      `}}function Dn({opType:e,cpuKernelImpl:t,dtype:n}){return({inputs:r,backend:i})=>{const{x:s}=r,o=i,a=n||s.dtype;if(o.shouldExecuteOnCPU([s])&&null!=t){const e=o.tensorMap.get(s.dataId),n=t(e.values,a);return o.makeTensorInfo(s.shape,a,n)}const u=new Un(s.shape,e);return o.runWebGPUProgram(u,[s],a)}}function jn({opType:e,cpuKernelImpl:t,supportsComplex:n=!1,dtype:r}){return({inputs:i,backend:s})=>{const{a:l,b:a}=i,u=s;if(n&&"complex64"===l.dtype){const t=u.tensorMap.get(l.dataId),n=u.tensorMap.get(a.dataId);let r,i;if(e!==en.MUL)[r,i]=[[t.complexTensorInfos.real,n.complexTensorInfos.real],[t.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((t=>{const[n,r]=t,i={dataId:n.dataId,dtype:n.dtype,shape:l.shape},s={dataId:r.dataId,dtype:r.dtype,shape:a.shape},h=new Nn(e,l.shape,a.shape);return u.runWebGPUProgram(h,[i,s],Object(o.Dd)(n.dtype,r.dtype))}));else{const e=new _n(en.COMPLEX_MULTIPLY_REAL,l.shape,a.shape),s=new _n(en.COMPLEX_MULTIPLY_IMAG,l.shape,a.shape),o=[{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:l.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:l.shape},{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:a.shape},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:a.shape}];r=u.runWebGPUProgram(e,o,"float32"),i=u.runWebGPUProgram(s,o,"float32")}const s=Ln({inputs:{real:r,imag:i},backend:u});return u.disposeData(r.dataId),u.disposeData(i.dataId),s}const h=r||Object(o.Dd)(l.dtype,a.dtype);if(("string"===l.dtype||"string"===a.dtype||u.shouldExecuteOnCPU([l,a]))&&null!=t){const e=u.tensorMap.get(l.dataId).values,n=u.tensorMap.get(a.dataId).values,r="string"===l.dtype?o.Oc.fromUint8ToStringArray(e):e,i="string"===l.dtype?o.Oc.fromUint8ToStringArray(n):n,[s,c]=t(l.shape,a.shape,r,i,h);return u.makeTensorInfo(c,h,s)}const c=new Nn(e,l.shape,a.shape);return u.runWebGPUProgram(c,[l,a],h)}}function Wn(e){return(t,n,i,s,r)=>{const a=o.Oc.assertAndGetBroadcastShape(t,n),u=a.length,l=o.Ed.computeStrides(a),h=o.Ed.sizeFromShape(a),c=o.Ed.getTypedArrayFromDType(r,h),d=t.length,p=n.length,f=o.Ed.computeStrides(t),m=o.Ed.computeStrides(n),g=o.Oc.getBroadcastDims(t,a),y=o.Oc.getBroadcastDims(n,a);if(g.length+y.length===0)for(let t=0;t<c.length;++t)c[t]=e(i[t%i.length],s[t%s.length]);else for(let t=0;t<c.length;++t){const n=o.Ed.indexToLoc(t,u,l),r=n.slice(-d);g.forEach((e=>r[e]=0));const a=o.Ed.locToIndex(r,d,f),h=n.slice(-p);y.forEach((e=>h[e]=0));const x=o.Ed.locToIndex(h,p,m);c[t]=e(i[a],s[x])}return[c,a]}}const Vn=Wn(((e,t)=>e+t));function Gn(e){return(t,n,i)=>{const s=o.Ed.getTypedArrayFromDType(n,t.length);for(let n=0;n<t.length;++n)s[n]=e(t[n],i);return s}}const Hn=Gn((e=>Math.ceil(e))),Kn=Wn(((e,t)=>e===t?1:0)),Xn=Gn((e=>Math.exp(e))),Yn=Gn((e=>Math.expm1(e))),qn=Gn((e=>Math.floor(e))),Qn=Wn(((e,t)=>e>t?1:0)),Zn=Wn(((e,t)=>e>=t?1:0)),Jn=Wn(((e,t)=>e<t?1:0)),er=Wn(((e,t)=>e<=t?1:0)),nr=Gn((e=>Math.log(e))),rr=Wn(((e,t)=>Math.max(e,t))),ir=Wn(((e,t)=>Math.min(e,t))),or=Wn(((e,t)=>e*t)),ar=Wn(((e,t)=>e!==t?1:0));function sr(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let r=t;r<e.length;r++)n[t-1]*=e[r];return n}var ur=o.Oc.RowPartitionType;class lr{constructor(e,t,n,r,i,s,l,a,u,h){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=r,this.valuesDType=i,this.defaultValue=s,this.defaultValueShape=l,this.rowPartitionValues=a,this.rowPartitionValuesShapes=u,this.rowPartitionTypes=o.Oc.getRowPartitionTypesHelper(h),this.raggedRank=o.Oc.getRaggedRank(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===ur.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===ur.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case ur.VALUE_ROWIDS:return lr.getMaxWidthValueRowID(t);case ur.ROW_SPLITS:return lr.getMaxWidthRowSplit(t);default:throw new Error("Cannot handle partition type "+ur[this.getRowPartitionTypeByDimension(e-1)])}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let r=0;r<t-1;++r){const t=e[r+1]-e[r];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,r=e[0],i=0;for(let s=1;s<t;++s){const t=e[s];t!==r&&(r=t,i=Math.max(s-n,i),n=s)}return Math.max(t-n,i)}tensorShapeFromTensor(e,t,n=!0){if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return dr(e,n)}calculateOutputSize(e){const t=this.valuesShape,n=this.defaultValueShape;o.Oc.validateDefaultValueShape(n,t);const r=this.tensorShapeFromTensor(this.shape,this.shapeShape),i=o.Oc.combineRaggedTensorToTensorShapes(this.raggedRank,r,t);i[0]<0&&(i[0]=e);for(let e=1;e<=this.raggedRank;++e)i[e]<0&&(i[e]=this.getMaxWidth(e));return i}calculateFirstParentOutputIndex(e,t,n){const i=Math.min(e,n),s=[];let r=0;for(let e=0;e<i;++e,r+=t)s.push(r);for(let t=i;t<e;++t)s.push(-1);return o.Ed.assert(s.length===e,(()=>"Final length of result must be equal to firstDimension.")),s}calculateOutputIndexRowSplit(e,t,n,r){const i=e.length,s=[];for(let o=0;o<i-1;++o){const i=e[o+1]-e[o];let a=Math.min(r,i),u=t[o];-1===u&&(a=0);for(let e=0;e<a;++e)s.push(u),u+=n;for(let e=0;e<i-a;++e)s.push(-1)}if(i>0&&s.length!==e[i-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(e,t,n,r){const i=e.length,s=[];if(0===i)return[];let o=0,a=e[0];if(a>=t.length)throw new Error(`Got currentValueRowId=${a}, which is not less than ${t.length}`);let u=t[a];s.push(u);for(let l=1;l<i;++l){const i=e[l];if(i===a)u>=0&&(++o,o<r?u+=n:u=-1);else{if(o=0,a=i,i>=t.length)throw new Error(`Got nextValueRowId=${i} which is not less than ${t.length}`);u=t[i]}s.push(u)}if(s.length!==e.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(e,t,n,r){const i=this.getRowPartitionTensor(e),s=this.getRowPartitionTypeByDimension(e);switch(s){case ur.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(i,t,n,r);case ur.ROW_SPLITS:if(i.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${i.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(i,t,n,r);default:throw new Error("Unsupported partition type: "+ur[s])}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case ur.FIRST_DIM_SIZE:return e[0];case ur.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case ur.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type "+ur[t])}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let e=n.length-2;e>=0;--e)n[e]=n[e+1]*t[e+1];const i=dr(t,!1),s=o.Ed.getArrayFromDType(this.valuesDType,o.Ed.sizeFromShape(i));if(n[0]*t[0]>0){let r=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e)r=this.calculateOutputIndex(e-1,r,n[e],t[e]);this.setOutput(this.raggedRank,r,s,i)}return[i,s]}setOutput(e,t,n,s){if(0===n.length)return;const r=this.values,a=n;let u=s.slice();u=u.slice(e+1);const l=o.Ed.sizeFromShape(u),h=t.length;let c=this.defaultValue;if(c.length!==l&&1!==c.length){const e=this.defaultValueShape;Object(o.Bd)((()=>{const t=Object(o.od)(c,e),n=Object(o.Pc)(t,u);c=n.dataSync()}))}let d=0,p=0,f=0;for(let e=0;e<=h;++e){let o=e<h?t[e]:-1;if(o!==f){if(p<f){const e=r.subarray(d*l);cr(a.subarray(p*l),e,(f-p)*l)}if(e>=h){const e=n.length;o=Math.floor(e/l)}if(o>f)if(1===this.defaultValue.length)a.subarray(f*l,o*l).fill(this.defaultValue[0]),f=o;else for(;o>f;)cr(a.slice(f*l),c,l),++f;o<0?(d=e+1,p=f):(d=e,p=f,f=p+1)}else++f}}}function cr(e,t,n){for(let r=0;r<n;r++)e[r]=t[r]}function dr(e,t){const n=[];for(let r of e){if(r<0){if(!t)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}const pr=Gn((e=>1/Math.sqrt(e))),fr=Gn((e=>1/(1+Math.exp(-e)))),mr=Gn((e=>Math.sqrt(e))),gr=Wn(((e,t)=>{const n=e-t;return n*n}));class yr{constructor(e,t,n,i,s,r){this.separator=o.Ed.encodeString(e),this.nGramWidths=t,this.leftPad=o.Ed.encodeString(n),this.rightPad=o.Ed.encodeString(i),this.padWidth=s,this.preserveShort=r}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,r,i,s){for(let o=0;o<i;++o){const a=this.getPadWidth(s),u=Math.max(0,a-o),l=Math.max(0,a-(i-(o+1))),h=s-(u+l),c=t+(u>0?0:o-a);let d=0;d+=u*this.leftPad.length;for(let t=0;t<h;++t)d+=e[c+t].length;d+=l*this.rightPad.length,d+=(u+l+h-1)*this.separator.length,n[r+o]=new Uint8Array(d);const p=n[r+o];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<u;++e)m(this.leftPad),m(this.separator);for(let t=0;t<h-1;++t)m(e[c+t]),m(this.separator);if(h>0){m(e[c+h-1]);for(let e=0;e<l;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<l-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,i=t.length;if(i>0){let e=t[0];if(0!==e)throw new Error("First split value must be 0, got "+e);for(let r=1;r<i;++r){let i=t[r]>=e;if(i=i&&t[r]<=n,!i)throw new Error(`Invalid split value ${t[r]}, must be in [${e}, ${n}]`);e=t[r]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const s=i-1,r=o.Ed.getArrayFromDType("int32",i);if(0===n||0===i){const e=new Array(n);for(let e=0;e<=s;++e)r[e]=0;return[e,r]}r[0]=0;for(let e=1;e<=s;++e){const n=t[e]-t[e-1];let o=0;this.nGramWidths.forEach((e=>{o+=this.getNumNGrams(n,e)})),this.preserveShort&&n>0&&0===o&&(o=1),r[e]=r[e-1]+o}const a=new Array(r[s]);for(let n=0;n<s;++n){const o=t[n];let i=r[n];if(this.nGramWidths.forEach((s=>{const r=t[n+1]-t[n],u=this.getNumNGrams(r,s);this.createNGrams(e,o,a,i,u,s),i+=u})),this.preserveShort&&i===r[n]){const s=t[n+1]-t[n];if(0===s)continue;const r=s+2*this.padWidth,u=1;this.createNGrams(e,o,a,i,u,r)}}return[a,r]}}function xr(e,t,n,r){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)r.push(e.subarray(t,t+1));return}if(1===t.length){const i=t[0];let s=e.indexOf(i);for(;-1!==s;){const t=e.subarray(0,s);n&&0===t.length||r.push(t),s=(e=e.subarray(s+1)).indexOf(i)}return void(n&&0===e.length||r.push(e))}let i=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){const t=e.subarray(i,s);n&&0===t.length||r.push(t),i=s+1}}const vr=Wn(((e,t)=>e-t)),wr=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function kr(e,t,n=0,i=e.length-1){for(;i>n;){if(i-n>600){const r=i-n+1,s=t-n+1,o=Math.log(r),a=.5*Math.exp(2*o/3),u=.5*Math.sqrt(o*a*(r-a)/r)*Math.sign(s-r/2);kr(e,t,Math.max(n,Math.floor(t-s*a/r+u)),Math.min(i,Math.floor(t+(r-s)*a/r+u)))}const s=e[t];let r=n,a=i;for(o.Ed.swap(e,n,t),wr(e[i],s)>0&&o.Ed.swap(e,n,i);r<a;){for(o.Ed.swap(e,r,a),r++,a--;wr(e[r],s)<0;)r+=1;for(;wr(e[a],s)>0;)a-=1}0===wr(e[n],s)?o.Ed.swap(e,n,a):(a+=1,o.Ed.swap(e,a,i)),a<=t&&(n=a+1),t<=a&&(i=a-1)}}var Sr=Object.freeze({__proto__:null,simpleAbsImpl:function(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t},addImpl:Vn,bincountImpl:function(e,t,n,i,s){const r=o.Ed.sizeFromShape(i),a=o.Ed.makeZerosTypedArray(s,n);for(let n=0;n<e.length;n++){const o=e[n];if(o<0)throw new Error("Input x must be non-negative!");o>=s||(a[o]+=r>0?t[n]:1)}return a},bincountReduceImpl:function(e,t,n,r=!1){const i=e.shape[0],s=e.shape[1],l=Object(o.Sc)([i,n],t.dtype);for(let a=0;a<i;a++)for(let i=0;i<s;i++){const s=e.get(a,i);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(r?l.set(1,a,s):t.size>0?l.set(l.get(a,s)+t.get(a,i),a,s):l.set(l.get(a,s)+1,a,s))}return l},castImpl:function(e,t,n,i){if("int32"===i)return[t,"int32",Int32Array.from(e)];if("bool"===i){const i=o.Ed.toTypedArray([0],n),[s,r]=Wn(((e,t)=>e!==t?1:0))(t,[],e,i,"bool");return[r,"bool",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${i}`)},ceilImpl:Hn,concatImpl:function(e,t,n,i){const s=o.Ed.getArrayFromDType(n,o.Ed.sizeFromShape(t));if(i&&"string"!==n){let t=0;e.forEach((e=>{const n=o.Ed.sizeFromShape(e.shape);s.set(e.vals,t),t+=n}))}else{let r=0;e.forEach((e=>{const i="string"===n?o.Oc.fromUint8ToStringArray(e.vals):e.vals;let l=0;for(let n=0;n<e.shape[0];++n){const a=n*t[1]+r;for(let t=0;t<e.shape[1];++t)s[a+t]=i[l++]}r+=e.shape[1]}))}return s},equalImpl:Kn,expImpl:Xn,expm1Impl:Yn,floorImpl:qn,gatherNdImpl:function(e,t,n,r,i,s,l,a,u){const h=Object(o.Sc)([r,s],n);for(let n=0;n<r;n++){const r=[];let o=0;for(let t=0;t<i;t++){const s=e[n*i+t];o+=s*l[t],r.push(s)}if(o<0||o>=u/s)throw new Error(`Invalid indices: ${r} does not index into ${a}`);for(let e=0;e<s;e++)h.values[n*s+e]=t.get(...t.indexToLoc(o*s+e))}return h},gatherV2Impl:function(e,t,n){const r=Object(o.Sc)(n,e.dtype);for(let n=0;n<r.size;++n){const i=r.indexToLoc(n).slice(),s=i[0],o=i[2],a=t.locToIndex([s,o]);i[2]=t.values[a];const u=e.locToIndex(i);0<=u&&u<e.values.length&&(r.values[n]=e.values[u])}return r},greaterImpl:Qn,greaterEqualImpl:Zn,lessImpl:Jn,lessEqualImpl:er,linSpaceImpl:function(e,t,n){const i=(t-e)/(n-1),s=o.Ed.makeZerosTypedArray(n,"float32");s[0]=e;for(let e=1;e<s.length;e++)s[e]=s[e-1]+i;return s},logImpl:nr,maxImpl:function(e,t,n,i){const s=o.Ed.getTypedArrayFromDType(i,o.Ed.sizeFromShape(n));for(let n=0;n<s.length;++n){const r=n*t;let i=e[r];for(let n=0;n<t;++n){const t=e[r+n];(Number.isNaN(t)||t>i)&&(i=t)}s[n]=i}return s},maximumImpl:rr,minimumImpl:ir,multiplyImpl:or,negImpl:function(e,t,n){const i=o.Ed.createScalarValue(-1,n);return or([],t,i,e,n)},notEqualImpl:ar,prodImpl:function(e,t,n,i){const[s,r]=o.Oc.computeOutAndReduceShapes(e,i),a=Object(o.Dd)(t,"int32"),u=o.Ed.makeZerosTypedArray(o.Ed.sizeFromShape(s),a),l=o.Ed.sizeFromShape(r);for(let e=0;e<u.length;++e){const t=e*l;let r=1;for(let e=0;e<l;++e)r*=n[t+e];u[e]=r}return{outVals:u,outShape:s,outDtype:a}},raggedGatherImpl:function(e,t,n,i,s,r,a,u){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,i)=>{if(e<0||e>=n){const s=o.Ed.indexToLoc(i,t.length,o.Ed.computeStrides(t)).join(",");throw new Error(`indices[${s}] = ${e} is not in [0, ${n})`)}}))}(r,a,t[0][0]-1),0===i.length)throw new Error("params.rank must be nonzero");const l=i[0],{outSplits:h,valueSlices:c,numValues:d}=function(e,t,n,r){const i=[];let s=0;const o=t.length-1+n.length,a=new Array(o).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const r=e[n],i=n===e.length-1?t:e[n+1].length;if(0===r.length)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>i)throw new Error("Ragged splits must not point past values");for(let e=1;e<r.length;++e)if(r[e-1]>r[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,r);let u=1;for(let e=0;e<t.length-1;++e){u*=t[e];const n=t[e+1];for(let t=1;t<u+1;++t)a[e].push(t*n)}for(let r=0;r<e.length;++r){let o=e[r],u=e[r]+1;for(let e=0;e<n.length;++e){const r=n[e],i=e+t.length-1;if(i>=0){const e=a[i],t=e[e.length-1]-r[o];for(let e=o;e<u;++e)a[i].push(r[e+1]+t)}o=r[o],u=r[u]}u!==o&&(i.push([o,u]),s+=u-o)}return{outSplits:a,valueSlices:i,numValues:s}}(r,a,e,l),p=function(e){const t=[];for(let n=0;n<e.length;++n){const i=e[n].length,s=o.Ed.getArrayFromDType("int32",i);t.push(s),e[n].forEach(((e,t)=>s[t]=e))}return t}(h),f=function(e,t,n,i,s){const r=t.slice();r[0]=s;const a=o.Ed.getArrayFromDType(n,o.Ed.sizeFromShape(r)),u=e.length;return function(e,t,n,r,i,s){const o=sr(t,2)[1],a=sr(s,2)[1];let u=0;for(const t of n)for(let n=t[0];n<t[1];++n){for(let t=0;t<r;++t)i[u*a+t]=e[n*o+t];++u}}(e,t,i,0===u?0:u/t[0],a,r),[a,r]}(n,i,s,c,d);return[p,f[0],f[1]]},raggedRangeImpl:function(e,t,n,i,s,r,a){if(t.length>1)throw new Error("starts must be a scalar or vector");if(s.length>1)throw new Error("limits must be a scalar or vector");if(a.length>1)throw new Error("deltas must be a scalar or vector");const u=0===t.length,l=0===s.length,h=0===a.length,c=[];u||c.push(t[0]),l||c.push(s[0]),h||c.push(a[0]);for(let e=1;e<c.length;++e)if(c[e]!==c[e-1])throw new Error("starts, limits, and deltas must have the same shape");const d=0===c.length?1:c[0],p=o.Ed.getArrayFromDType("int32",d+1);p[0]=0;for(let t=0;t<d;++t){const n=u?e[0]:e[t],o=l?i[0]:i[t],s=h?r[0]:r[t];if(0===s)throw new Error("Requires delta != 0");let a;if(s>0&&o<n||s<0&&o>n)a=0;else if(a=Math.ceil(Math.abs((o-n)/s)),a>2147483647)throw new Error("Requires ((limit - start) / delta) <= 2147483647");p[t+1]=p[t]+a}const f=p[d],m=o.Ed.getArrayFromDType(n,f);let g=0;for(let t=0;t<d;++t){const n=p[t+1]-p[t];let o=u?e[0]:e[t];const i=h?r[0]:r[t];for(let e=0;e<n;++e)m[g++]=o,o+=i}return[p,m]},raggedTensorToTensorImpl:function(e,t,n,r,i,s,o,a,u,l){return new lr(e,t,n,r,i,s,o,a,u,l).compute()},rangeImpl:function(e,t,n,i){if(e===t||e<t&&n<0||t<e&&n>1)return o.Ed.makeZerosTypedArray(0,i);const s=Math.abs(Math.ceil((t-e)/n)),r=o.Ed.makeZerosTypedArray(s,i);t<e&&1===n&&(n=-1),r[0]=e;for(let e=1;e<r.length;e++)r[e]=r[e-1]+n;return r},rsqrtImpl:pr,scatterImpl:function(e,t,n,r,i,s,l,a,u,h){const c=[r/i,i],d=e.values,f=t.values;if(0===r)return Object(o.Sc)(n,t.dtype);const p=Object(o.Sc)(c,t.dtype);"string"==typeof u||"number"==typeof u?p.values.fill(u):"boolean"==typeof u&&p.values.fill(+u);for(let e=0;e<s;e++){const s=[];let u=0;for(let t=0;t<l;t++){const n=d[e*l+t];s.push(n),u+=n*a[t]}if(u<0||u>=r/i)throw new Error(`Invalid indices: ${s} does not index into ${n}`);for(let n=0;n<i;n++)h?p.values[u*i+n]+=f[e*i+n]:p.values[u*i+n]=0===t.rank?f[0]:f[e*i+n]}return p},sigmoidImpl:fr,sliceImpl:function(e,t,n,i,s){const r=o.sd.isSliceContinous(i,t,n),a=o.Ed.sizeFromShape(n),u=o.Ed.computeStrides(i);if(r){const n=o.sd.computeFlatOffset(t,u);return"string"===s?e.slice(n,n+a):e.subarray(n,n+a)}const l="string"===s?o.Oc.fromUint8ToStringArray(e):e,h=Object(o.Sc)(i,s,l),c=Object(o.Sc)(n,s);for(let e=0;e<c.size;++e){const n=c.indexToLoc(e),r=n.map(((e,n)=>e+t[n]));c.set(h.get(...r),...n)}return"string"===s?o.Oc.fromStringArrayToUint8(c.values):c.values},sparseFillEmptyRowsImpl:function(e,t,n,i,s,r,a){const u=t[0],l=r[0],h=new Array(l),c=new Array(u),d=t[1];if(0===l){if(0!==u)throw new Error(o.Oc.getSparseFillEmptyRowsIndicesDenseShapeMismatch(u));return[o.Ed.getArrayFromDType(n,0),[0,d],o.Ed.getArrayFromDType(s,0),h,c]}let p=!0,f=0;const m=new Array(l).fill(0);for(let t=0;t<u;++t){const n=e[t*d];if(n<0)throw new Error(o.Oc.getSparseFillEmptyRowsNegativeIndexErrorMessage(t,n));if(n>=l)throw new Error(o.Oc.getSparseFillEmptyRowsOutOfRangeIndexErrorMessage(t,n,l));++m[n],p=p&&n>=f,f=n}let g=!0;for(let e=0;e<l;++e){const t=0===m[e];h[e]=t,g=g&&!t,m[e]=Math.max(m[e],1),e>0&&(m[e]+=m[e-1])}if(g&&p){const t=e,n=i;for(let e=0;e<u;++e)c[e]=e;return[t,[u,d],n,h,c]}{const t=m[l-1],r=o.Ed.getArrayFromDType(n,t*d),p=o.Ed.getArrayFromDType(s,t),f=new Array(l).fill(0);for(let t=0;t<u;++t){const n=e[t*d],o=f[n],s=(0===n?0:m[n-1])+o;f[n]++;for(let n=0;n<d;++n)r[s*d+n]=e[t*d+n];p[s]=i[t],c[t]=s}for(let e=0;e<l;++e)if(0===f[e]){const t=0===e?0:m[e-1];r[t*d+0]=e;for(let e=1;e<d;++e)r[t*d+e]=0;p[t]=a}return[r,[t,d],p,h,c]}},sparseReshapeImpl:function(e,t,n,i,s){const r=o.Ed.sizeFromShape(i),a=t[0],u=s.length,l=[];let h=1,c=-1;for(let e=0;e<u;++e){const t=s[e];if(-1===t){if(-1!==c)throw new Error(o.Oc.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(c,e));c=e,l.push(1)}else{if(t<0)throw new Error(o.Oc.getSparseReshapeNegativeOutputDimErrorMessage(e,t));h*=t,l.push(t)}}if(-1!==c){if(h<=0)throw new Error(o.Oc.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());const e=Math.trunc(r/h);if(h*e!==r)throw new Error(o.Oc.getSparseReshapeInputOutputMultipleErrorMessage(i,l));l[c]=e}if(o.Ed.sizeFromShape(l)!==r)throw new Error(o.Oc.getSparseReshapeInputOutputMismatchErrorMessage(i,l));const d=i.length,p=[];if(d>0){p[d-1]=1;for(let e=d-2;e>=0;--e)p[e]=p[e+1]*i[e+1]}const f=[];if(u>0){f[u-1]=1;for(let e=u-2;e>=0;--e)f[e]=f[e+1]*l[e+1]}const m=o.Ed.getArrayFromDType(n,a*u);for(let t=0;t<a;++t){let n=0;for(let r=0;r<d;++r)n+=e[t*d+r]*p[r];for(let e=0;e<u;++e)m[t*u+e]=Math.trunc(n/f[e]),n%=f[e]}return[m,[a,u],l]},sparseSegmentReductionImpl:function(e,t,n,i,s,r=!1,a=0){const u=i.length,l=[t[0],e.length/t[0]],h=l[1],c=u>0?s[u-1]+1:0;if(c<0)throw new Error(o.Oc.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());const d=t.slice();d[0]=c;const p=d.reduce(((e,t)=>e*t),1),f=o.Ed.getArrayFromDType(n,p);if(0===u)return c>0&&f.fill(a),[f,d];if(c<=0)throw new Error(o.Oc.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());let m=0,g=1,y=0,x=s[m];for(;;){let t=0;if(g<u){if(t=s[g],x===t){++g;continue}if(x>=t)throw new Error(o.Oc.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage())}if(x<0||x>=c)throw new Error(o.Oc.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(x,c));x>y&&f.fill(a,y*h,x*h);for(let t=m;t<g;++t){const n=i[t];if(n<0||n>=l[0])throw new Error(o.Oc.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(t,i[t],l[0]));for(let t=0;t<h;t++)f[x*h+t]+=e[n*h+t]}if(r)for(let e=0;e<h;e++)f[x*h+e]/=g-m;if(m=g,++g,y=x+1,x=t,g>u)break}return y<c&&f.fill(a,y*h,c*h),[f,d]},sqrtImpl:mr,squaredDifferenceImpl:gr,stridedSliceImpl:function(e,t,n,r){const i=Object(o.Sc)(e,t.dtype);for(let e=0;e<i.size;e++){const s=i.indexToLoc(e),o=new Array(s.length);for(let e=0;e<o.length;e++)o[e]=s[e]*n[e]+r[e];i.set(t.get(...o),...s)}return i},stringNGramsImpl:function(e,t,n,r,i,s,o,a){return new yr(n,r,i,s,o,a).compute(e,t)},stringSplitImpl:function(e,t,n){const i=e.length,s=[];let r=0,a=0;const u=new Array(i);for(let o=0;o<i;++o){const i=s.length;xr(e[o],t,n,s);const l=s.length-i;u[o]=l,r+=l,a=Math.max(a,l)}const l=o.Ed.getArrayFromDType("int32",2*r),h=new Array(r),c=[i,a];let d=0;for(let e=0;e<i;++e)for(let t=0;t<u[e];++t)l[2*d]=e,l[2*d+1]=t,h[d]=s[d],++d;return[l,h,c]},stringToHashBucketFastImpl:function(e,t){const n=o.Ed.getArrayFromDType("int32",e.length);for(let i=0;i<e.length;++i)n[i]=o.Ed.fingerPrint64(e[i]).modulo(t).getLowBitsUnsigned();return n},subImpl:vr,tileImpl:function(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const r=Object(o.Sc)(n,e.dtype);for(let t=0;t<r.values.length;++t){const n=r.indexToLoc(t),i=new Array(e.rank);for(let t=0;t<i.length;t++)i[t]=n[t]%e.shape[t];const s=e.locToIndex(i);r.values[t]=e.values[s]}return r},topKImpl:function(e,t,n,i,s){const r=t[t.length-1],[a,u]=[e.length/r,r],l=o.Ed.getTypedArrayFromDType(n,a*i),h=o.Ed.getTypedArrayFromDType("int32",a*i);for(let t=0;t<a;t++){const n=t*u,r=e.subarray(n,n+u);let o=new Array(r.length);r.forEach(((e,t)=>o[t]={value:e,index:t})),i<o.length&&(kr(o,i),o=o.slice(0,i)),s&&o.sort(wr);const a=t*i,c=l.subarray(a,a+i),d=h.subarray(a,a+i);for(let e=0;e<i;e++)c[e]=o[e].value,d[e]=o[e].index}const c=t.slice();return c[c.length-1]=i,[Object(o.Sc)(c,n,l),Object(o.Sc)(c,"int32",h)]},transposeImpl:function(e,t,n,i,s){const r=t.length,a=o.Ed.sizeFromShape(t),u=o.Ed.computeStrides(t),l=o.Ed.computeStrides(s),h=o.Ed.getTypedArrayFromDType(n,o.Ed.sizeFromShape(s));for(let t=0;t<a;++t){const n=o.Ed.indexToLoc(t,r,u),s=new Array(n.length);for(let e=0;e<s.length;e++)s[e]=n[i[e]];h[o.Ed.locToIndex(s,r,l)]=e[t]}return h},uniqueImpl:function(e,t,n,i){const s=o.Ed.parseAxisParam(t,n)[0],r=[1,n[0],1];for(let e=0;e<s;e++)r[0]*=n[e];r[1]=n[s];for(let e=s+1;e<n.length;e++)r[2]*=n[e];const a={},u=new Int32Array(n[s]),l=new o.Dc(r,i,e),h=[],c=1===r[0]&&1===r[2];for(let t=0;t<n[s];t++){let n;if(c)n=e[t].toString();else{const e=[];for(let n=0;n<r[0];n++)for(let o=0;o<r[2];o++)e.push(l.get(n,t,o));n=e.join(",")}if(void 0!==a[n])u[t]=a[n];else{const e=Object.keys(a).length;a[n]=e,u[t]=e,h.push(t)}}const d=r.slice();d[1]=Object.keys(a).length;const p=new o.Dc(d,i);h.forEach(((e,t)=>{for(let n=0;n<r[0];n++)for(let o=0;o<r[2];o++)p.set(l.get(n,e,o),n,t,o)}));const f=n.slice();return f[s]=d[1],{outputValues:p.values,outputShape:f,indices:u}}});const{addImpl:Ir,castImpl:Cr,ceilImpl:Or,concatImpl:Ar,equalImpl:Tr,expImpl:Er,expm1Impl:Rr,floorImpl:Pr,gatherNdImpl:$r,gatherV2Impl:Fr,greaterEqualImpl:_r,greaterImpl:Nr,lessEqualImpl:zr,lessImpl:Mr,logImpl:Lr,maxImpl:Br,maximumImpl:Ur,minimumImpl:Dr,multiplyImpl:jr,negImpl:Wr,notEqualImpl:Vr,prodImpl:Gr,rangeImpl:Hr,rsqrtImpl:Kr,scatterImpl:Xr,simpleAbsImpl:Yr,sliceImpl:qr,stridedSliceImpl:Qr,stringNGramsImpl:Zr,subImpl:Jr,tileImpl:ei,topKImpl:ti,transposeImpl:ni,uniqueImpl:ri}=Sr,ii={kernelName:o.a,backendName:"webgpu",kernelFunc:Dn({opType:hn.ABS,cpuKernelImpl:Yr})},oi={kernelName:o.b,backendName:"webgpu",kernelFunc:Dn({opType:hn.ACOS})},ai={kernelName:o.c,backendName:"webgpu",kernelFunc:Dn({opType:hn.ACOSH})},si={kernelName:o.d,backendName:"webgpu",kernelFunc:jn({opType:en.ADD,cpuKernelImpl:Ir,supportsComplex:!0})};class ui{constructor(e){this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e[0],this.variableNames=e.map(((e,t)=>"T"+t)),this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="addN"}getUserCode(){const e=[];this.variableNames.forEach((t=>{e.push(`let v${t} = get${t}ByOutputCoords(coords);`)}));const t=this.variableNames.map((e=>"v"+e)).join(" + ");return`\n      ${Nt("index")} {\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if (flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            ${e.join("\n        ")}\n            setOutputAtIndex(flatIndex, ${t});\n          }\n        }\n      }\n    `}}const hi={kernelName:o.e,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,r=t;if(1===r.length)return zn({inputs:{x:r[0]},backend:n});const i=r.map((e=>e.dtype)).reduce(((e,t)=>Object(o.Dd)(e,t))),s=r.map((e=>e.shape)),l=new ui(s);return n.runWebGPUProgram(l,r,i)}};class ci{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[16,16,1];const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.dispatchLayout={x:[0],y:[1]},this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize,[1,1,1]),this.shaderKey="transposeShared"}getUserCode(){o.Ed.assert(this.workgroupSize[0]===this.workgroupSize[1],(()=>`Must be a square tile, current tile shape is ${this.workgroupSize[0]} x ${this.workgroupSize[1]}`));const e=this.workgroupSize[0];return`\n      var<workgroup> tile : array<array<f32, ${this.workgroupSize[0]+1}>, ${this.workgroupSize[0]}>;\n      ${Nt()} {\n        var x = i32(workgroupId.x) * ${e} + i32(localId.x);\n        var y = i32(workgroupId.y) * ${e} + i32(localId.y);\n        let width = uniforms.outShape[0];\n        let height = uniforms.outShape[1];\n        if (x < width && y < height) {\n          tile[localId.y][localId.x] = f32(A[y * width + x]);\n        }\n        workgroupBarrier();\n\n        x = i32(workgroupId.y) * ${e} + i32(localId.x);\n        y = i32(workgroupId.x) * ${e} + i32(localId.y);\n        if (x < height && y < width) {\n          setOutputAtIndex((y * height + x), tile[localId.x]\n            [localId.y]);\n        }\n      }\n    `}}class di{constructor(e,t){this.variableNames=["A"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[t[r]];this.outputShape=n,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.newDim=t,this.shaderKey="transpose_"+t}getUserCode(){const e=Ft(this.outputShape.length),t=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=new Array(t);for(let t=0;t<e.length;t++)n[e[t]]="resRC."+_t(t);return n.join()}(this.newDim);return`\n      ${Nt("index")} {\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let resRC = getCoordsFromIndex(flatIndex);\n            setOutputAtIndex(flatIndex, A[getIndexFromCoords${this.outputShape.length}D(\n              ${e}(${t}), uniforms.aShape)]);\n          }\n        }\n      }\n    `}}function pi(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{perm:r}=i,a=n,u=s.shape.length,l=new Array(u);for(let e=0;e<l.length;e++)l[e]=s.shape[r[e]];if(n.shouldExecuteOnCPU([s])){const e=a.tensorMap.get(s.dataId).values,t=ni(e,s.shape,s.dtype,r,l);return n.makeTensorInfo(l,s.dtype,t)}if(2===s.shape.length&&o.Ed.arraysEqual(r,[1,0])){const e=new ci(s.shape,r);return a.runWebGPUProgram(e,[s],s.dtype)}const h=new di(s.shape,r);return a.runWebGPUProgram(h,[s],s.dtype)}const fi={kernelName:o.Hc,backendName:"webgpu",kernelFunc:pi};class mi{constructor(e,t){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="reduceSize : i32,",this.size=!0,this.inputShape=[e.batchSize,e.inSize];const[n]=o.Oc.computeOutAndReduceShapes(this.inputShape,[1]);this.outputShape=0===n.length?[1]:n,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,[1,1,1]),this.reduceType=t,this.shaderKey="reduce_"+t}getUserCode(){let e="",t="0.0";const n=this.workgroupSize[0];"min"===this.reduceType||"max"===this.reduceType?(e=`\n         if (isnan(candidate)) {\n          bestValue = uniforms.NAN;\n         } else if (!isnan(bestValue) && candidate ${"min"===this.reduceType?"<":">"} bestValue)\n           {  bestValue = candidate; }`,t="f32(x[offset])"):"sum"===this.reduceType||"mean"===this.reduceType?e=" bestValue = bestValue + candidate; ":"prod"===this.reduceType?(e=" bestValue = bestValue * candidate; ",t="1.0"):"all"===this.reduceType?(e=" bestValue = f32(bestValue >= 1.0 && candidate >= 1.0); ",t="1.0"):"any"===this.reduceType&&(e=" bestValue = f32(bestValue >= 1.0 || candidate >= 1.0); ",t="0.0");const r="mean"===this.reduceType?"setOutputAtIndex(outputIndex, bestValue / f32(uniforms.reduceSize));":"setOutputAtIndex(outputIndex, bestValue);";return`\n       fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n       }\n\n       \n         var<workgroup> xBestValues : array<f32, ${n}>;\n       \n       fn getOffset(outputIndex : i32) -> i32 {\n         let outputCoords = getCoordsFromIndex(outputIndex);\n         let offset = ${1===this.outputShape.length?"outputCoords":"outputCoords[0]"} * uniforms.reduceSize;\n          return offset;\n       }\n       ${Nt("index")} {\n         let outputIndex = index / ${n};\n         let offset = getOffset(outputIndex);\n         var bestValue = ${t};\n         let Length = uniforms.reduceSize;\n         let WorkPerThread = DIV_CEIL(u32(Length), ${n}u);\n         for (var k = i32(localId.x); k < Length && outputIndex < uniforms.size;\n             k = k + ${n}) {\n           let candidate = f32(x[offset + k]);\n           ${e}\n         }\n         xBestValues[localId.x] = bestValue;\n         workgroupBarrier();\n\n         var reduceSize = min(u32(Length), ${n}u);\n         for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n             currentSize = reduceSize / 2u) {\n           let interval = DIV_CEIL(reduceSize, 2u);\n           if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            ${e}\n            xBestValues[localId.x] = bestValue;\n           }\n           reduceSize = interval;\n           workgroupBarrier();\n         }\n\n         if (localId.x == 0u && outputIndex < uniforms.size) {\n          ${r}\n        }\n       }\n     `}}function gi(e,t,n,i,s){const r=e.shape.length,a=[],u=o.Ed.parseAxisParam(t,e.shape);let l=u;const h=o.Oc.getAxesPermutation(l,r);let c=e;null!=h&&(c=pi({inputs:{x:e},attrs:{perm:h},backend:s}),l=o.Oc.getInnerMostAxes(l.length,r),a.push(c)),o.Oc.assertAxesAreInnerMostDims(i,l,r);const[d,p]=o.Oc.computeOutAndReduceShapes(c.shape,l);let f,m=d;if(n&&(m=o.Oc.expandShapeToKeepDim(d,u)),"max"!==i&&"prod"!==i||!s.shouldExecuteOnCPU([c])){const t=o.Ed.sizeFromShape(p),n={windowSize:t,inSize:t,batchSize:o.Ed.sizeFromShape(c.shape)/t,outSize:1},r="mean"===i?"float32":Object(o.xd)(e.dtype),u=[{type:"int32",data:[t]}],l=new mi(n,i),h=s.runWebGPUProgram(l,[c],r,u);a.push(h),f=Rn({inputs:{x:h},attrs:{shape:m},backend:s})}else{const t=s.tensorMap.get(c.dataId).values;switch(i){case"max":const n=Br(t,o.Ed.sizeFromShape(p),m,e.dtype);f=s.makeTensorInfo(m,e.dtype,n);break;case"prod":const{outVals:r,outShape:a,outDtype:u}=Gr(c.shape,c.dtype,t,l);f=s.makeTensorInfo(a,u,r);break;default:throw new Error(i+" CPU implementation is not yet supported.")}}return a.forEach((e=>s.disposeData(e.dataId))),f}const bi={kernelName:o.f,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{keepDims:s,axis:o}=r;return gi(i,o,s,"all",n)}},yi={kernelName:o.g,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{keepDims:s,axis:o}=r;return gi(i,o,s,"any",n)}};class xi{constructor(e,t,n){this.workgroupSize=[64,1,1],this.variableNames=["x"],this.uniforms="infinityValue : f32,",this.size=!0;const i=[t];this.op="min"===n?"<":">";const[s,r]=o.Oc.computeOutAndReduceShapes(e,i);this.outputShape=0===s.length?[1]:s,this.dispatchLayout=Xt(this.outputShape),o.Ed.sizeFromShape(r)<32||o.Ed.sizeFromShape(s)>1e3?(this.type="plain",this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize)):(this.type="shared",this.dispatch=Gt(this.dispatchLayout,this.outputShape,[1,1,1])),this.inputShape=e,this.shaderKey=`argMinMax_${this.op}_${this.type}`}getUserCode(){const e=this.workgroupSize[0],t=()=>1===this.inputShape.length?"uniforms.xShape":"uniforms.xShape."+_t(this.inputShape.length-1),n=()=>{let e="";if(1===this.outputShape.length)1!==this.inputShape.length&&(e+="outputCoords,");else for(let t=0;t<this.outputShape.length;t++)e+=`outputCoords.${_t(t)},`;return e};return"shared"===this.type?`\n      fn DIV_CEIL(a : u32, b : u32) -> u32 {\n        return ((a - 1u) / b + 1u);\n      }\n\n      \n      var<workgroup> xBestIndices : array<i32, ${e}>;\n      var<workgroup> xBestValues : array<f32, ${e}>;\n    \n\n      ${Nt("index")} {\n        let outputIndex = index / ${e};\n        let reduceLength = ${t()};\n\n        var bestIndex = i32(localId.x);\n        var bestValue = uniforms.infinityValue;\n        let outputCoords = getCoordsFromIndex(outputIndex);\n        for (var k = i32(localId.x); k < reduceLength && outputIndex < uniforms.size;\n            k = k + ${e}) {\n          let candidate = getX(${n()} k);\n          if (!isnan(candidate) && candidate ${this.op} bestValue) {\n            bestValue = candidate;\n            bestIndex = k;\n          }\n        }\n        xBestValues[localId.x] = bestValue;\n        xBestIndices[localId.x] = bestIndex;\n        workgroupBarrier();\n\n        var reduceSize = min(u32(reduceLength), ${e}u);\n        for (var currentSize = reduceSize / 2u; reduceSize > 1u;\n            currentSize = reduceSize / 2u) {\n          let interval = DIV_CEIL(reduceSize, 2u);\n          if (localId.x < currentSize) {\n            let candidate = xBestValues[localId.x + interval];\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              xBestValues[localId.x] = bestValue;\n              xBestIndices[localId.x] = xBestIndices[localId.x + interval];\n            }\n          }\n          reduceSize = interval;\n          workgroupBarrier();\n        }\n\n        if (localId.x == 0u && outputIndex < uniforms.size) {\n          setOutputAtIndexI32(outputIndex, xBestIndices[localId.x]);\n        }\n      }\n    `:`\n      ${Nt("index")} {\n        if (index < uniforms.size) {\n          let outputCoords = getCoordsFromIndex(index);\n          var bestIndex = 0;\n          var bestValue = getX(${n()} 0);\n          let reduceLength = ${t()};\n          for (var i = 1; i < reduceLength; i++) {\n            let candidate = getX(${n()} i);\n            if (candidate ${this.op} bestValue) {\n              bestValue = candidate;\n              bestIndex = i;\n            }\n          }\n          setOutputAtIndexI32(index, bestIndex);\n        }\n      }\n      `}}const vi={kernelName:o.h,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{axis:r}=i;let a=o.Ed.parseAxisParam(r,s.shape);const u=o.Oc.getAxesPermutation(a,s.shape.length);let l=s;const h=[];null!=u&&(l=pi({inputs:{x:s},backend:n,attrs:{perm:u}}),h.push(l),a=o.Oc.getInnerMostAxes(a.length,l.shape.length)),o.Oc.assertAxesAreInnerMostDims("argMax",[a[0]],l.shape.length);const c=new xi(l.shape,a[0],"max"),d=[{type:"float32",data:[Number.NEGATIVE_INFINITY]}],p=n.runWebGPUProgram(c,[l],"int32",d);return h.forEach((e=>n.disposeData(e.dataId))),p}},wi={kernelName:o.i,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{axis:r}=i;let a=o.Ed.parseAxisParam(r,s.shape);const u=o.Oc.getAxesPermutation(a,s.shape.length);let l=s;const h=[];null!=u&&(l=pi({inputs:{x:s},backend:n,attrs:{perm:u}}),h.push(l),a=o.Oc.getInnerMostAxes(a.length,l.shape.length)),o.Oc.assertAxesAreInnerMostDims("argMin",[a[0]],l.shape.length);const c=new xi(l.shape,a[0],"min"),d=[{type:"float32",data:[Number.POSITIVE_INFINITY]}],p=n.runWebGPUProgram(c,[l],"int32",d);return h.forEach((e=>n.disposeData(e.dataId))),p}},ki={kernelName:o.j,backendName:"webgpu",kernelFunc:Dn({opType:hn.ASIN})},Si={kernelName:o.k,backendName:"webgpu",kernelFunc:Dn({opType:hn.ASINH})},Ii={kernelName:o.l,backendName:"webgpu",kernelFunc:Dn({opType:hn.ATAN})},Ci={kernelName:o.m,backendName:"webgpu",kernelFunc:jn({opType:en.ATAN2})},Oi={kernelName:o.n,backendName:"webgpu",kernelFunc:Dn({opType:hn.ATANH})};class Ai{constructor(e,t){this.variableNames=["x"],this.uniforms="stride : vec2<i32>, pad : vec2<i32>, dilation : vec2<i32>, convDims : vec2<i32>, filterDims : vec2<i32>,",this.workgroupSize=[128,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="pool2D_"+t,this.poolType=t}getUserCode(){let e="resultValue = max(value, resultValue);";"avg"===this.poolType&&(e="resultValue = resultValue + value; count = count + 1.0;");let t="resultValue";return"avg"===this.poolType&&(t="resultValue / max(count, 1.0)"),`\n      ${Nt("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.yz) * uniforms.stride - uniforms.pad;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          var resultValue = ${"avg"===this.poolType?"0.0":"-1.0 / pow(10.0, -20.0)"};\n          var count = 0.0;\n\n          for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + uniforms.dilation.x) {\n            let xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= uniforms.convDims.x) {\n              continue;\n            }\n\n            for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + uniforms.dilation.y) {\n              let xC = xCCorner + wC;\n              if (xC < 0 || xC >= uniforms.convDims.y) {\n                continue;\n              }\n\n              let value = getX(batch, xR, xC, coords[3]);\n              ${e}\n            }\n          }\n\n          setOutputAtIndex(index, ${t});\n        }\n      }\n    `}}class Ti{constructor(e){this.variableNames=["x"],this.uniforms="stride : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="poolWithFilterSizeEqualsOne"}getUserCode(){return`\n      ${Nt("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let batch = coords[0];\n          let d = coords[3];\n\n          let xRCCorner = coords.yz * uniforms.stride;\n          let xRCorner = xRCCorner.x;\n          let xCCorner = xRCCorner.y;\n\n          let value = getX(batch, xRCorner, xCCorner, d);\n          setOutputAtIndex(index, value);\n        }\n      }\n    `}}function Ei(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{reductionIndices:s,keepDims:o}=r;return gi(i,s,o,"max",n)}const Ri={kernelName:o.xb,backendName:"webgpu",kernelFunc:Ei};function Pi(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{keepDims:s,axis:o}=r;return gi(i,o,s,"mean",n)}const $i={kernelName:o.Ab,backendName:"webgpu",kernelFunc:Pi};function Fi(e,t,n,i){if(1===t.filterWidth&&1===t.filterHeight&&o.Ed.arraysEqual(t.inShape,t.outShape))return zn({inputs:{x:e},backend:i});if(t.filterWidth===t.inWidth&&t.filterHeight===t.inHeight&&1===t.batchSize&&"VALID"===t.padInfo.type){const s=e.shape.length,r=Rn({inputs:{x:e},backend:i,attrs:{shape:[e.shape[s-3]*e.shape[s-2],e.shape[s-1]]}});let a;"avg"===n?a=Pi({inputs:{x:r},backend:i,attrs:{axis:0,keepDims:!1}}):(o.Ed.assert("max"===n,(()=>"Invalid pool type "+n)),a=Ei({inputs:{x:r},backend:i,attrs:{reductionIndices:0,keepDims:!1}}));const u=Rn({inputs:{x:a},backend:i,attrs:{shape:t.outShape}});return i.disposeData(r.dataId),i.disposeData(a.dataId),u}let s;const r=[{type:"int32",data:[t.strideHeight,t.strideWidth]}];return 1===t.filterHeight&&1===t.filterWidth?s=new Ti(t):("avg"===n?s=new Ai(t,"avg"):(o.Ed.assert("max"===n,(()=>"Invalid pool type "+n)),s=new Ai(t,"max")),r.push({type:"int32",data:[t.padInfo.top,t.padInfo.left]},{type:"int32",data:[t.dilationHeight,t.dilationWidth]},{type:"int32",data:[t.inHeight,t.inWidth]},{type:"int32",data:[t.effectiveFilterHeight,t.effectiveFilterWidth]})),i.runWebGPUProgram(s,[e],e.dtype,r)}const _i={kernelName:o.o,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{filterSize:s,strides:l,pad:a,dimRoundingMode:u}=r;return Fi(i,o.Oc.computePool2DInfo(i.shape,s,l,1,a,u),"avg",n)}};class Ni{constructor(e){this.variableNames=["dy"],this.uniforms="stride : vec2<i32>, pads : vec2<i32>, dilation : vec2<i32>, filterDims : vec2<i32>,\n       outHeight : i32, outWidth : i32, avgMultiplier : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="avg_pool2d_backprop"}getUserCode(){return`\n      ${Nt("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d = coords[3];\n\n        let dyRCCorner = vec2<i32>(coords.yz) - uniforms.pads;\n        let dyRCorner = dyRCCorner.x;\n        let dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims[0]; wR = wR + uniforms.dilation[0]) {\n          let dyR = f32(dyRCorner + wR) / f32(uniforms.stride[0]);\n\n          if (dyR < 0.0 || dyR >= f32(uniforms.outHeight) || fract(dyR) > 0.0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims[1]; wC = wC + uniforms.dilation[1]) {\n            let dyC = f32(dyCCorner + wC) / f32(uniforms.stride[1]);\n\n            if (dyC < 0.0 || dyC >= f32(uniforms.outWidth) || fract(dyC) > 0.0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            let dyValue = getDy(batch, idyR, idyC, d);\n\n            dotProd = dotProd + dyValue * uniforms.avgMultiplier;\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n    `}}const zi={kernelName:o.p,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{dy:s,input:r}=t,a=r;var u;u=[s,r],Array.isArray(u)||(u=[u]),u.forEach((e=>{null!=e&&o.Ed.assert("complex64"!==e.dtype,(()=>"avgPoolGrad does not support complex64 tensors in the WebGPU backend."))}));const{filterSize:l,strides:h,pad:c}=i,p=o.Oc.computePool2DInfo(a.shape,l,h,1,c),d=new Ni(p),f=1/(p.filterHeight*p.filterWidth),g=[{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.effectiveFilterHeight-1-p.padInfo.top,p.effectiveFilterWidth-1-p.padInfo.left]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]},{type:"int32",data:[p.effectiveFilterHeight,p.effectiveFilterWidth]},{type:"int32",data:[p.outHeight]},{type:"int32",data:[p.outWidth]},{type:"float32",data:[f]}];return n.runWebGPUProgram(d,[s],a.dtype,g)}},Mi={kernelName:o.q,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{a:i,b:s}=t,{transposeA:o,transposeB:a}=r;return $n({a:i,b:s,transposeA:o,transposeB:a,backend:n})}};class Li{constructor(e,t){this.variableNames=["source"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.rank=t.length,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.start=e,this.uniforms=`start : ${Ft(e.length)}, `,this.shaderKey="slice"}getUserCode(){const e=Ft(this.rank),t=function(e){if(1===e)return"sourceLoc";if(e<=6)return Bi.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let n;return n=1===this.start.length?this.outputShape.map(((e,t)=>"sourceLoc = uniforms.start + coords;")):this.outputShape.map(((e,t)=>`sourceLoc.${Bi[t]} = uniforms.start.${_t(t)} + coords.${Bi[t]};`)),`\n      ${Nt("index")} {\n        if (index < uniforms.size) {\n          var sourceLoc : ${e};\n          let coords = getCoordsFromIndex(index);\n          ${n.join("\n")}\n          setOutputAtIndex(index, getSource(${t}));\n        }\n      }\n    `}}const Bi=["x","y","z","w","u","v"];function Ui(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{begin:r,size:a}=i,[u,l]=o.sd.parseSliceParams(s,r,a);if(o.sd.assertParamsValid(s,u,l),n.shouldExecuteOnCPU([s])||"string"===s.dtype){const e=n.tensorMap.get(s.dataId),t=qr(e.values,u,l,s.shape,s.dtype);return n.makeTensorInfo(l,s.dtype,t)}if(0===o.Ed.sizeFromShape(l))return n.makeTensorInfo(l,s.dtype,[]);const h=new Li(u,l),c=[{type:"int32",data:u}];return n.runWebGPUProgram(h,[s],s.dtype,c)}const Di={kernelName:o.mc,backendName:"webgpu",kernelFunc:Ui},ji={kernelName:o.r,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{blockShape:r,crops:a}=i;o.Ed.assert(s.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGPU backend not implemented yet"));const u=r.reduce(((e,t)=>e*t)),l=o.Oc.getReshaped(s.shape,r,u),h=o.Oc.getPermuted(l.length,r.length),c=o.Oc.getReshapedPermuted(s.shape,r,u),d=o.Oc.getSliceBeginCoords(a,r.length),p=o.Oc.getSliceSize(c,a,r.length),f=[],m=Rn({inputs:{x:s},backend:n,attrs:{shape:l}}),g=pi({inputs:{x:m},backend:n,attrs:{perm:h}}),y=Rn({inputs:{x:g},backend:n,attrs:{shape:c}}),x=Ui({inputs:{x:y},backend:n,attrs:{begin:d,size:p}});return f.push(m),f.push(g),f.push(y),f.forEach((e=>n.disposeData(e.dataId))),x}},Wi=`\n  fn bincount_write(index: i32, value: f32) {\n    ${$t("&result[index]","value","float32")}\n  }\n`;class Vi{constructor(e,t,n=!1){this.outputShape=[],this.variableNames=["x"],this.uniforms="binCountSize : i32,",this.workgroupSize=[64,1,1],this.atomic=!0,this.hasWeights=!0,this.binaryOutput=!1,this.outputShape=e,this.rank=e.length,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.binaryOutput=n,n&&(this.atomic=!1),this.hasWeights=t,this.hasWeights&&this.variableNames.push("w"),this.shaderKey=`bincount_${this.hasWeights}_${this.binaryOutput}_${this.rank}`}getUserCode(){return`\n    ${this.binaryOutput?"\n  fn bincount_write(index: i32, value: f32) {\n    atomicStore(&result[index], bitcast<i32>(value));\n  }\n":Wi}\n  ${Nt("index")} {\n    ${1===this.rank?`if (index < uniforms.xShape) {\n      let indexVal = i32(getX(index));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ${this.binaryOutput?1:this.hasWeights?"getW(index)":"1."};\n        bincount_write(indexVal, value);\n      }\n    }`:`let coord = getCoordsFromIndex(index);\n    if (coordsInBounds2D(coord, uniforms.xShape)) {\n      let indexVal = i32(getX(coord[0], coord[1]));\n      if (indexVal < uniforms.binCountSize) {\n        let value = ${this.binaryOutput?1:this.hasWeights?"getW(coord[0], coord[1])":"1."};\n        bincount_write(coord.x * uniforms.binCountSize + indexVal, value);\n      }\n    }`}\n  }\n  `}}const Gi={kernelName:o.s,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s,weights:r}=t,{size:a}=i,u=o.Ed.sizeFromShape(s.shape),l=o.Ed.sizeFromShape(r.shape)>0,h=[a],c=r.dtype,d=Tn({backend:n,attrs:{shape:h,value:0,dtype:c}}),p=new Vi([u],l),f=[{type:"int32",data:[a]}],m=l?[s,r]:[s];return n.runWebGPUProgram(p,m,c,f,d)}},Hi=jn({opType:en.NOT_EQUAL,dtype:"bool",cpuKernelImpl:Vr}),Ki={kernelName:o.Jb,backendName:"webgpu",kernelFunc:Hi};function Xi(e){const{inputs:t,backend:n}=e,{input:r}=t;return zn({inputs:{x:n.tensorMap.get(r.dataId).complexTensorInfos.real},backend:n})}const Yi={kernelName:o.Sb,backendName:"webgpu",kernelFunc:Xi},qi={kernelName:o.t,backendName:"webgpu",kernelFunc:function e(t){const{inputs:n,backend:i,attrs:s}=t,{x:r}=n,{dtype:a}=s;if("complex64"===a){if("complex64"===r.dtype)return zn({inputs:{x:r},backend:i});const t=Object(o.Fd)(r.shape),n=e({inputs:{x:r},backend:i,attrs:{dtype:"float32"}}),l=Ln({inputs:{real:n,imag:t},backend:i});return t.dispose(),i.disposeData(n.dataId),l}if("complex64"===r.dtype){const t=Xi({inputs:{input:r},backend:i}),n=e({inputs:{x:t},backend:i,attrs:{dtype:a}});return i.disposeData(t.dataId),n}if(!o.Ed.hasEncodingLoss(r.dtype,a)){const e=zn({inputs:{x:r},backend:i});return{dataId:e.dataId,shape:e.shape,dtype:a}}if(i.shouldExecuteOnCPU([r])){const e=i.tensorMap.get(r.dataId).values,[t,n,o]=Cr(e,r.shape,r.dtype,a);return i.makeTensorInfo(t,n,o)}if("int32"===a)return function(e,t){const n=new Un(e.shape,hn.TO_INT),r=t.runWebGPUProgram(n,[e],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}(r,i);if("bool"===a){const e=i.makeTensorInfo([],"bool",o.Ed.getTypedArrayFromDType("bool",1)),t=Hi({inputs:{a:r,b:e},backend:i});return i.disposeData(e.dataId),t}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${a}`)}},Qi={kernelName:o.u,backendName:"webgpu",kernelFunc:Dn({opType:hn.CEIL,cpuKernelImpl:Or})};class Zi{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workPerThread=4,this.workgroupSize=[64,1,1],this.isVec4=!0,this.size=!0,this.outputShape=e,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.shaderKey="clipVec4"}getUserCode(){return`\n      ${Nt("index")} {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          var clampedValue = clamp(\n              value, vec4<f32>(uniforms.minVal), vec4<f32>(uniforms.maxVal));\n          clampedValue = select(clampedValue, value, isnanVec4(value));\n          setOutputAtIndex(index, clampedValue);\n        }\n      }\n    `}}class Ji{constructor(e){this.variableNames=["A"],this.uniforms="minVal : f32, maxVal : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="clip"}getUserCode(){return`\n      ${Nt("index")} {\n        if(index < uniforms.size) {\n          let value = getAByOutputIndex(index);\n          if (isnan(value)) {\n            setOutputAtIndex(index, value);\n            return;\n          }\n          setOutputAtIndex(index, clamp(value, uniforms.minVal, uniforms.maxVal));\n        }\n      }\n    `}}const eo={kernelName:o.v,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{clipValueMin:r,clipValueMax:a}=i;let u;const l=[{type:"float32",data:[r]},{type:"float32",data:[a]}];return u=o.Ed.sizeFromShape(s.shape)%4==0?new Zi(s.shape):new Ji(s.shape),n.runWebGPUProgram(u,[s],s.dtype,l)}};class to{constructor(e){this.uniforms="",this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=o.Oc.computeOutShape(e,1),this.variableNames=e.map(((e,t)=>"T"+t)),this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]),this.offsetLength=e.length-1;for(let e=0;e<this.offsetLength;e++)this.uniforms+=`offset${e} : i32,`;this.shaderKey="concat"}getUserCode(){const e=[];if(this.offsetLength>0){e.push("if (yC < uniforms.offset0){ setOutputAtCoords(coords.x, coords.y, getT0(yR, yC)); }");for(let t=1;t<this.offsetLength;t++)e.push(`else if (yC < uniforms.offset${[t]}){ setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${t-1})); }`);const t=this.offsetLength,n=this.offsetLength-1;e.push(`else { setOutputAtCoords(coords.x, coords.y, getT${t}(yR, yC - uniforms.offset${n})); }`)}else e.push("setOutputAtCoords(coords.x, coords.y, getT0(yR, yC));");return`\n      ${Nt("index")} {\n        for(var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let flatIndex = index * ${this.workPerThread} + i;\n          if(flatIndex < uniforms.size) {\n            let coords = getCoordsFromIndex(flatIndex);\n            let yR = coords.x;\n            let yC = coords.y;\n\n            ${e.join("\n        ")}\n          }\n        }\n      }\n    `}}function no(e){const{inputs:t,backend:n}=e,{input:r}=t;return zn({inputs:{x:n.tensorMap.get(r.dataId).complexTensorInfos.imag},backend:n})}const ro={kernelName:o.ib,backendName:"webgpu",kernelFunc:no};function io(e,t,n){const i=e[0].dtype;if("complex64"===i){const r=e.map((e=>Xi({inputs:{input:e},backend:n}))),i=e.map((e=>no({inputs:{input:e},backend:n}))),s=io(r,t,n),o=io(i,t,n),a=Ln({inputs:{real:s,imag:o},backend:n});return r.forEach((e=>n.disposeData(e.dataId))),i.forEach((e=>n.disposeData(e.dataId))),n.disposeData(s.dataId),n.disposeData(o.dataId),a}let s=n.shouldExecuteOnCPU(e);if("string"===i&&(s=!0),s){const s=e.map((e=>{const i=o.Ed.sizeFromShape(e.shape.slice(t));return Rn({inputs:{x:e},backend:n,attrs:{shape:[-1,i]}})})),r=s.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),a=o.Oc.computeOutShape(s.map((e=>e.shape)),1),u=1===s[0].shape[0],l=Ar(r,a,i,u),h=o.Oc.computeOutShape(e.map((e=>e.shape)),t),c=n.makeTensorInfo(h,i,l);return s.forEach((e=>n.disposeData(e.dataId))),c}const r=n.device.limits.maxStorageBuffersPerShaderStage-1;if(e.length>r){const o=[];for(let i=0;i<e.length;i+=r){const s=e.slice(i,i+r);o.push(io(s,t,n))}const i=io(o,t,n);for(const e of o)n.disposeData(e.dataId);return i}const{tensors2D:a,outShape:u}=function(e,t,n){const i=o.Oc.computeOutShape(e.map((e=>e.shape)),t);return{tensors2D:e.map((e=>Rn({inputs:{x:e},backend:n,attrs:{shape:[o.Ed.sizeFromShape(e.shape.slice(0,t)),o.Ed.sizeFromShape(e.shape.slice(t))]}}))),outShape:i}}(e,t,n),l=a.map((e=>e.shape)),h=new to(l),c=[],d=new Array(l.length-1);if(d.length>0){d[0]=l[0][1],c.push({type:"int32",data:[d[0]]});for(let e=1;e<d.length;e++)d[e]=d[e-1]+l[e][1],c.push({type:"int32",data:[d[e]]})}const p=n.runWebGPUProgram(h,a,a[0].dtype,c);a.forEach((e=>n.disposeData(e.dataId)));const f=Rn({inputs:{x:p},backend:n,attrs:{shape:u}});return n.disposeData(p.dataId),f}function oo(e){const{inputs:t,backend:n,attrs:i}=e,{axis:s}=i,r=o.Ed.parseAxisParam(s,t[0].shape)[0],a=t.map((e=>e.shape));o.Oc.assertParamsConsistent(a,r);const u=o.Oc.computeOutShape(t.map((e=>e.shape)),r);if(0===o.Ed.sizeFromShape(u))return n.makeTensorInfo(u,t[0].dtype,[]);const l=t.filter((e=>o.Ed.sizeFromShape(e.shape)>0));return 1===l.length?zn({inputs:{x:l[0]},backend:n}):io(l,r,n)}const ao={kernelName:o.x,backendName:"webgpu",kernelFunc:oo};class so{constructor(e,t,n,r,i=!1,s=null,o=!1,a=!1){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.isVec4=((e.inChannels%4==0||e.inChannels%3==0)&&this.isChannelsLast||e.outWidth%4==0&&!this.isChannelsLast)&&e.outChannels%4==0,this.dispatchLayout=this.isChannelsLast?{x:[3],y:[1,2],z:[0]}:{x:[2,3],y:[1],z:[0]},this.workgroupSize=Ht(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=Kt(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4?(this.isChannelsLast&&e.inChannels%4!=0?(this.innerElementSize=3,this.variableTypes=["f32","vec4<f32>"]):(this.innerElementSize=4,this.variableTypes=["vec4<f32>","vec4<f32>"]),i&&(this.variableNames.push("bias"),this.variableTypes.push("vec4<f32>")),o&&(this.variableNames.push("preluActivationWeights"),this.variableTypes.push("vec4<f32>"))):(this.innerElementSize=this.elementsPerThread[0],i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights")),this.sequentialAccessByThreads=a,this.addBias=i,this.activation=s,this.hasPreluActivationWeights=o,this.tileAOuter=this.workgroupSize[1]*this.elementsPerThread[1],this.tileBOuter=this.workgroupSize[0]*this.elementsPerThread[0],this.tileInner=Math.max(this.workgroupSize[0]*this.innerElementSize,this.workgroupSize[1]),this.fitAOuter=t%this.tileAOuter==0,this.fitBOuter=n%this.tileBOuter==0,this.fitInner=r%this.tileInner==0,this.shaderKey=`conv2DMM_${this.elementsPerThread}_${this.activation}}_${this.fitAOuter}_${this.fitBOuter}_${this.fitInner}_${this.isVec4}_${this.innerElementSize}_${this.isChannelsLast}_${this.sequentialAccessByThreads}`}getUserCode(){const e=this.isVec4?xn(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner):wn(this.elementsPerThread,this.workgroupSize,!this.isChannelsLast,this.tileInner,!1,null,this.sequentialAccessByThreads),t=this.isVec4?[this.innerElementSize,4,4]:[1,1,1];return`\n    ${function(e,t,n,r,i=!1,s=null,o=!1,a=4,u=4,l=4){const h=e?"\n      let coord = vec4<i32>(batch, xRow, xCol, xCh);\n      ":"\n      let coord = vec4<i32>(batch, xCh, xRow, xCol);\n      ",c=e?"\n      let coords = vec4<i32>(\n        batch,\n        row / outWidth,\n        row % outWidth,\n        col);\n      ":"\n      let coords = vec4<i32>(\n        batch,\n        row,\n        col / outWidth,\n        col % outWidth);\n      ",d=e?"uniforms.xShape[1]":"uniforms.xShape[2]",p=e?"uniforms.xShape[2]":"uniforms.xShape[3]",f=e?"row":"col",m=e?"col":"row",g=`\n      let inChannels = uniforms.wShape[2];\n      let outWidth = ${e?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n      let outRow = ${f} / outWidth;\n      let outCol = ${f} % outWidth;\n\n      let WRow = ${m} / (uniforms.filterDims[1] * inChannels);\n      let WCol = ${m} / inChannels % uniforms.filterDims[1];\n      let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * WRow - uniforms.pad[0];\n      let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * WCol - uniforms.pad[1];\n      let xCh = ${m} % inChannels;\n      var resData = ${fn(a)}(0.0);\n      // The bounds checking is always needed since we use it to pad zero for\n      // the 'same' padding type.\n      if (xRow >= 0 && xRow < ${d} && xCol >= 0 && xCol < ${p}) {\n        ${h}\n        let xIndex = getIndexFromCoords4D(coord, uniforms.xShape);\n        ${(e=>{switch(e){case 1:return"resData = x[xIndex];";case 3:return"resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";case 4:return"resData = x[xIndex / 4];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(a)}\n      }\n      return resData;`,y=e?t&&r?`\n      let col = colIn * ${a};\n      ${g}`:`\n      let col = colIn * ${a};\n      if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        ${g}\n      }\n      return ${fn(a)}(0.0);`:r&&n?`\n      let col = colIn * ${a};\n      ${g}`:`\n      let col = colIn * ${a};\n      if (row < uniforms.dimInner && col < uniforms.dimBOuter) {\n        ${g}\n      }\n      return ${fn(a)}(0.0);`,x=""+(e=>{switch(e){case 1:return"return W[row * uniforms.wShape[3] + colIn];";case 4:return"return W[row * uniforms.wShape[3] / 4 + colIn];";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(u),b=fn(l),v=fn(e?a:u),w=fn(e?u:a);return`\n      ${mn(s,o,4===l,4)}\n      fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${v} {\n        ${e?y:x}\n      }\n\n      fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${w} {\n        ${e?x:y}\n      }\n\n      fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${b}) {\n        let col = colIn * ${l};\n        if (row < uniforms.dimAOuter && col < uniforms.dimBOuter)\n        {\n        var value = valueIn;\n        let outWidth = ${e?"uniforms.outShape[2]":"uniforms.outShape[3]"};\n        ${c}\n        ${gn(i,s)}\n        setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }`}(this.isChannelsLast,this.fitAOuter,this.fitBOuter,this.fitInner,this.addBias,this.activation,this.hasPreluActivationWeights,t[0],t[1],t[2])}\n    ${e}\n  `}}class uo{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms="filterDims: vec2<i32>, pad: vec2<i32>, stride: vec2<i32>, dilation: vec2<i32>,",this.workgroupSize=[4,4,8],this.outputShape=e.outShape,this.isChannelsLast="channelsLast"===e.dataFormat,this.dispatchLayout=this.isChannelsLast?{x:[2],y:[1],z:[0,3]}:{x:[3],y:[2],z:[0,1]},this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.addBias=t,this.activation=n,this.hasPreluActivationWeights=r,t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.shaderKey=`conv2dnaive_${this.activation}_${this.isChannelsLast}`}getUserCode(){return`\n       ${mn(this.activation,this.hasPreluActivationWeights,!1,4)}\n       fn readInp(batch : i32, row : i32, col : i32, chan : i32) -> f32{\n         let coords = vec4<i32>(batch, row, col, chan);\n         if (coordsInBounds4D(coords, uniforms.xShape)) {\n           return  getX(batch, row, col, chan);\n         } else {\n          return 0.0;\n         }\n       }\n       fn readFilt(row : i32, col : i32, xChannel : i32, outChannel : i32) -> f32{\n         let coords = vec4<i32>(row, col, xChannel, outChannel);\n         if(coordsInBounds4D(coords, uniforms.wShape)) {\n           return getW(row, col, xChannel, outChannel);\n          } else {\n            return 0.0;\n          }\n       }\n       fn writeResult(batch : i32, row : i32, col : i32, chan : i32, valueIn : f32) {\n         let coords = ${this.isChannelsLast?"vec4<i32>(batch, row, col, chan);":"vec4<i32>(batch, chan, row, col);"}\n         if (coordsInBounds4D(coords, uniforms.outShape)) {\n           var value = valueIn;\n           ${gn(this.addBias,this.activation)}\n           setOutputAtCoords(coords.x, coords.y, coords.z, coords.w, value);\n         }\n       }\n       ${Nt("index")} {\n         let coords = getOutputCoords();\n         let batch = coords[0];\n         let outChannel = ${this.isChannelsLast?"coords[3];":"coords[1];"}\n         let outRow = ${this.isChannelsLast?"coords[1];":"coords[2];"}\n         let outCol = ${this.isChannelsLast?"coords[2];":"coords[3];"}\n         var acc : f32 = 0.0;\n         for (var row = 0; row < uniforms.filterDims[0]; row = row + 1) {\n           for (var col = 0; col < uniforms.filterDims[1]; col = col + 1) {\n             let xRow = outRow * uniforms.stride[0] + uniforms.dilation[0] * row - uniforms.pad[0];\n             let xCol = outCol * uniforms.stride[1] + uniforms.dilation[1] * col - uniforms.pad[1];\n             for (var xChannel = 0; xChannel < ${this.isChannelsLast?"uniforms.xShape[3];":"uniforms.xShape[1];"} xChannel = xChannel + 1) {\n               ${this.isChannelsLast?"let v = readInp(batch, xRow, xCol, xChannel);":"let v = readInp(batch, xChannel, xRow, xCol);"}\n               let f = readFilt(row, col, xChannel, outChannel);\n               acc = acc + v * f;\n             }\n           }\n         }\n         writeResult(batch, outRow, outCol, outChannel, acc);\n       }\n     `}}class lo{constructor(e,t){this.variableNames=["x"],this.uniforms="pad : vec2<i32>, stride : vec2<i32>, dilation : vec2<i32>, outWidth : i32, itemsPerBlockRow : i32,\n       inChannels : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast=t,this.shaderKey="im2col_"+this.isChannelsLast}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?"coords[1]":"coords[2]",r=this.isChannelsLast?"coords[2]":"coords[1]",i=this.isChannelsLast?"getX(batch, xRow, xCol, ch)":"getX(batch, ch, xRow, xCol)";return`\n    ${Nt("index")} {\n      let coords = getCoordsFromIndex(index);\n      if(index < uniforms.size) {\n        let batch = coords[0];\n        let row = ${n};\n        let col = ${r};\n        let offsetY = (row / uniforms.outWidth) * uniforms.stride[0] - uniforms.pad[0];\n        let xRow = offsetY + uniforms.dilation[0] * (col / uniforms.itemsPerBlockRow);\n        var value = 0.0;\n        if(xRow < uniforms.xShape[${e}] && xRow >= 0) {\n          let offsetX = (row % uniforms.outWidth) * uniforms.stride[1] -\n              uniforms.pad[1];\n          let xCol = offsetX + uniforms.dilation[1] * ((col %\n              uniforms.itemsPerBlockRow) / uniforms.inChannels);\n          let ch = col % uniforms.inChannels;\n          if(xCol < uniforms.xShape[${t}] && xCol >= 0) {\n            value = ${i};\n          }\n        }\n        setOutputAtIndex(index, value);\n      }\n    }\n   `}}function ho(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function co({x:e,filter:t,convInfo:n,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:l=0,activation:a=null}){const u=null!=i,h=null!=s,c="channelsLast"===n.dataFormat,d=c&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&"VALID"===n.padInfo.type,f=Object(o.ad)().getBool("WEBGPU_USE_NAIVE_CONV2D_DEBUG");if(!f&&(d||1===n.filterHeight&&1===n.filterWidth&&1===n.dilationHeight&&1===n.dilationWidth&&1===n.strideHeight&&1===n.strideWidth&&("SAME"===n.padInfo.type||"VALID"===n.padInfo.type)))return function({x:e,filter:t,convInfo:n,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const u="channelsLast"===n.dataFormat,l=!u,h=[];let c,d;if(u&&n.filterHeight===n.inHeight&&n.filterWidth===n.inWidth&&"VALID"===n.padInfo.type){const i=n.inHeight*n.inWidth*n.inChannels;c=Rn({inputs:{x:e},backend:r,attrs:{shape:[1,n.batchSize,i]}}),d=Rn({inputs:{x:t},backend:r,attrs:{shape:[1,i,n.outChannels]}})}else c=Rn({inputs:{x:e},backend:r,attrs:{shape:u?[n.batchSize,n.inHeight*n.inWidth,n.inChannels]:[n.batchSize,n.inChannels,n.inHeight*n.inWidth]}}),d=Rn({inputs:{x:t},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});if(h.push(c),h.push(d),null!=s){const e=ho(s.shape,u);null!=e&&(s=Rn({inputs:{x:s},backend:r,attrs:{shape:e}}),h.push(s))}if(null!=i){const e=ho(i.shape,u);null!=e&&(i=Rn({inputs:{x:i},backend:r,attrs:{shape:e}}),h.push(i))}const p=$n({a:u?c:d,b:u?d:c,transposeA:l,transposeB:!1,backend:r,bias:i,activation:a,preluActivationWeights:s,leakyreluAlpha:o}),f=Rn({inputs:{x:p},backend:r,attrs:{shape:n.outShape}});h.push(p);for(const e of h)r.disposeData(e.dataId);return f}({x:e,filter:t,convInfo:n,backend:r,bias:i,activation:a,preluActivationWeights:s,leakyreluAlpha:l});const p=Object(o.ad)().getNumber("WEBGPU_THRESHOLD_TO_INCREASE_WORKGROUPS_FOR_MATMUL"),m=p>0?p:r.thresholdToIncreaseWorkgroups,y=n.batchSize*Math.ceil(n.outHeight*n.outWidth/32)*Math.ceil(n.outChannels/32);if(Object(o.ad)().getBool("WEBGPU_CONV_SEPARATE_IM2COL_SHADER")||y<=m)return function({x:e,filter:t,convInfo:n,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:u,filterHeight:l,inChannels:h,strideWidth:c,strideHeight:d,padInfo:p,outWidth:f,outHeight:m,dilationWidth:g,dilationHeight:y,dataFormat:x}=n,b="channelsLast"===x,v=u*l*h,w=m*f,k=b?[n.batchSize,w,v]:[n.batchSize,v,w],S=new lo(k,b),I=[{type:"int32",data:[p.top,p.left]},{type:"int32",data:[d,c]},{type:"int32",data:[y,g]},{type:"int32",data:[f]},{type:"int32",data:[h*u]},{type:"int32",data:[h]}],C=r.runWebGPUProgram(S,[e],e.dtype,I),O=[];O.push(C);const A=Rn({inputs:{x:t},backend:r,attrs:{shape:[1,v,-1]}});if(O.push(A),null!=s){const e=ho(s.shape,b);null!=e&&(s=Rn({inputs:{x:s},backend:r,attrs:{shape:e}}),O.push(s))}if(null!=i){const e=ho(i.shape,b);null!=e&&(i=Rn({inputs:{x:i},backend:r,attrs:{shape:e}}),O.push(i))}const T=$n({a:b?C:A,b:b?A:C,transposeA:!b,transposeB:!1,backend:r,bias:i,activation:a,preluActivationWeights:s,leakyreluAlpha:o}),E=Rn({inputs:{x:T},backend:r,attrs:{shape:n.outShape}});O.push(T);for(const e of O)r.disposeData(e.dataId);return E}({x:e,filter:t,convInfo:n,backend:r,bias:i,preluActivationWeights:s,leakyreluAlpha:l,activation:a});let g;const x=[n.padInfo.top,n.padInfo.left],v=[{type:"int32",data:[n.filterHeight,n.filterWidth]},{type:"int32",data:[...x]},{type:"int32",data:[n.strideHeight,n.strideWidth]},{type:"int32",data:[n.dilationHeight,n.dilationWidth]}];if(f)g=new uo(n,u,a,h);else{const e=c?n.outHeight*n.outWidth:n.outChannels,t=c?n.outChannels:n.outHeight*n.outWidth,i=n.filterHeight*n.filterWidth*n.inChannels;v.push({type:"int32",data:[e]},{type:"int32",data:[t]},{type:"int32",data:[i]});const s=r.adapterInfo.isIntel();g=new so(n,e,t,i,u,a,h,s)}const b=[],w=[e,t];u&&(c||1!==i.shape.length||(i=Rn({inputs:{x:i},backend:r,attrs:{shape:[i.shape[0],1,1]}}),b.push(i)),w.push(i)),h&&(c||1!==s.shape.length||(s=Rn({inputs:{x:s},backend:r,attrs:{shape:[s.shape[0],1,1]}}),b.push(s)),w.push(s)),"leakyrelu"===a&&(v.push({type:"float32",data:[l]}),g.uniforms+=" alpha : f32,");const k=r.runWebGPUProgram(g,w,e.dtype,v);for(const e of b)r.disposeData(e.dataId);return k}const po={kernelName:o.y,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:r}=e,{x:i,filter:s}=t,{strides:l,pad:a,dataFormat:u,dilations:h,dimRoundingMode:c}=n,d=o.Oc.convertConv2DDataFormat(u);return co({x:i,filter:s,convInfo:o.Oc.computeConv2DInfo(i.shape,s.shape,l,h,a,c,!1,d),backend:r})}};class fo{constructor(e){this.variableNames=["dy","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.inShape,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey="conv2DDerInput_"+this.isChannelsLast}getUserCode(){const e=this.isChannelsLast?1:2,t=this.isChannelsLast?2:3,n=this.isChannelsLast?3:1;return`\n    ${Nt("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let batch = coords[0];\n        let d1 = coords[${n}];\n\n        let dyCorner = vec2<i32>(coords[${e}], coords[${t}]) - uniforms.pads;\n        let dyRCorner = dyCorner.x;\n        let dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var wR = 0; wR < uniforms.filterDims.x; wR = wR + 1) {\n          let dyR = (f32(dyRCorner) + f32(wR)) / f32(uniforms.stride.x);\n          let wRPerm = uniforms.filterDims.x - 1 - wR;\n          if (dyR < 0.0 || dyR >= f32(uniforms.outBackprop[1]) || fract(dyR) > 0.0 ||\n              wRPerm < 0) {\n            continue;\n          }\n          let idyR = i32(dyR);\n\n          for (var wC = 0; wC < uniforms.filterDims.y; wC = wC + 1) {\n            let dyC = (f32(dyCCorner) + f32(wC)) / f32(uniforms.stride.y);\n            let wCPerm = uniforms.filterDims.y - 1 - wC;\n            if (dyC < 0.0 || dyC >= f32(uniforms.outBackprop[2]) ||\n                fract(dyC) > 0.0 || wCPerm < 0) {\n              continue;\n            }\n            let idyC = i32(dyC);\n\n            for (var d2 = 0; d2 < uniforms.outBackprop[3]; d2 = d2 + 1) {\n              if (${this.isChannelsLast}) {\n                let xValue = getDy(batch, idyR, idyC, d2);\n                let wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd = dotProd + xValue * wValue;\n              } else {\n                let xValue = getDy(batch, d2, idyR, idyC);\n                let wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd = dotProd + xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}class mo{constructor(e){this.variableNames=["x","dy"],this.uniforms="pad : vec2<i32>, stride : vec2<i32>, batchSize : i32, outHeight : i32, outWidth : i32, inHeight : i32, inWidth : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.filterShape,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,this.shaderKey="conv2DDerFilter_"+this.isChannelsLast}getUserCode(){return`\n    ${Nt("index")} {\n      if(index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let wR = coords[0];\n        let wC = coords[1];\n        let d1 = coords[2];\n        let d2 = coords[3];\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        var dotProd = 0.0;\n        for (var b = 0; b < uniforms.batchSize; b = b + 1) {\n          for (var yR = 0; yR < uniforms.outHeight; yR = yR + 1) {\n            let xR = wR + yR * uniforms.stride[0] - uniforms.pad[0];\n            if (xR < 0 || xR >= uniforms.inHeight) {\n              continue;\n            }\n\n            for (var yC = 0; yC < uniforms.outWidth; yC = yC + 1) {\n              let xC = wC + yC * uniforms.stride[1] - uniforms.pad[1];\n\n              if (xC < 0 || xC >= uniforms.inWidth) {\n                continue;\n              }\n\n              if (${this.isChannelsLast}) {\n                let dyValue = getDy(b, yR, yC, d2);\n                let xValue = getX(b, xR, xC, d1);\n                dotProd = dotProd + xValue * dyValue;\n              } else {\n                let dyValue = getDy(b, d2, yR, yC);\n                let xValue = getX(b, d1, xR, xC);\n                dotProd = dotProd + xValue * dyValue;\n              }\n            }\n          }\n        }\n        setOutputAtIndex(index, dotProd);\n      }\n    }\n  `}}const go={kernelName:o.z,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,dy:s}=t,{strides:l,pad:a,dataFormat:u,dimRoundingMode:h,filterShape:c}=r,d=o.Oc.convertConv2DDataFormat(u),f=o.Oc.computeConv2DInfo(i.shape,c,l,1,a,h,!1,d),p=new mo(f),m=[{type:"int32",data:[f.padInfo.top,f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.batchSize]},{type:"int32",data:[f.outHeight]},{type:"int32",data:[f.outWidth]},{type:"int32",data:[f.inHeight]},{type:"int32",data:[f.inWidth]}];return n.runWebGPUProgram(p,[i,s],i.dtype,m)}};class bo{constructor(e){this.variableNames=["x","W"],this.uniforms="filterDims : vec2<i32>, pads : vec2<i32>, stride : vec2<i32>, outBackprop : vec4<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32,",this.outputShape=e.inShape,o.Ed.assert("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),this.isVec4=e.inChannels%4==0&&e.outChannels%4==0,this.dispatchLayout={x:[3],y:[1,2],z:[0]},this.workgroupSize=Ht(this.dispatchLayout,this.outputShape,this.isVec4),this.elementsPerThread=Kt(this.dispatchLayout,this.outputShape,this.isVec4),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize,this.elementsPerThread),this.isVec4&&(this.variableTypes=["vec4<f32>","f32"]),this.shaderKey=`conv2DDerInputMM_${this.isVec4}_${this.elementsPerThread}`}getUserCode(){const e=this.isVec4?xn(this.elementsPerThread,this.workgroupSize):wn(this.elementsPerThread,this.workgroupSize);return`\n    ${function(e=4){const t=`if (row < uniforms.dimAOuter && col < uniforms.dimInner) {\n        \n      let outRow = row / uniforms.outShape[2];\n      let outCol = row % uniforms.outShape[2];\n\n      let WRow = col / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n      let WCol = col / uniforms.outBackprop[3] % uniforms.filterDims[1];\n      let xR = f32(outRow - uniforms.pads[0] + WRow) / f32(uniforms.stride[0]);\n      let xC = f32(outCol - uniforms.pads[1] + WCol) / f32(uniforms.stride[1]);\n      if (xR < 0.0 || xR >= f32(uniforms.outBackprop[1]) || fract(xR) > 0.0) {\n        return ${fn(e)}(0.0);\n      }\n      if (xC < 0.0 || xC >= f32(uniforms.outBackprop[2]) || fract(xC) > 0.0) {\n        return ${fn(e)}(0.0);\n      }\n      let coord = vec4<i32>(\n          batch,\n          i32(xR),\n          i32(xC),\n          col % uniforms.outBackprop[3]);\n      return x[getIndexFromCoords4D(coord, uniforms.xShape)/${e}];\n      }\n      return ${fn(e)}(0.0);`;return`\n  fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${fn(e)} {\n    let col = colIn * ${e};\n    ${t}\n  }\n\n  fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${fn(e)} {\n    let col = colIn * ${e};\n    let coordX = uniforms.filterDims.x - 1 -\n        row / (uniforms.filterDims[1] * uniforms.outBackprop[3]);\n    let coordY = uniforms.filterDims.y - 1 -\n        (row / uniforms.outBackprop[3]) % uniforms.filterDims[1];\n    if (row < uniforms.dimInner && col < uniforms.dimBOuter &&\n        coordX >= 0 && coordY >= 0) {\n      let rowInner = row % uniforms.outBackprop[3];\n      let coord = vec4<i32>(coordX, coordY, col, rowInner);\n      ${(e=>{switch(e){case 1:return"return W[getIndexFromCoords4D(coord, uniforms.wShape)];";case 4:return"\n            let coord1 = vec4<i32>(coordX, coordY, col + 1, rowInner);\n            let coord2 = vec4<i32>(coordX, coordY, col + 2, rowInner);\n            let coord3 = vec4<i32>(coordX, coordY, col + 3, rowInner);\n            let v0 = W[getIndexFromCoords4D(coord, uniforms.wShape)];\n            let v1 = W[getIndexFromCoords4D(coord1, uniforms.wShape)];\n            let v2 = W[getIndexFromCoords4D(coord2, uniforms.wShape)];\n            let v3 = W[getIndexFromCoords4D(coord3, uniforms.wShape)];\n            return vec4<f32>(v0, v1, v2, v3);\n            ";default:throw new Error(`innerElementSize ${e} is not supported.`)}})(e)}\n    }\n    return ${fn(e)}(0.0);\n  }\n\n  fn mm_write(batch: i32, row : i32, colIn : i32, valueInput : ${fn(e)}) {\n    let col = colIn * ${e};\n    if (row < uniforms.dimAOuter && (col + ${e-1}) < uniforms.dimBOuter) {\n      var value = valueInput;\n      let outCoord = vec4<i32>(\n          batch,\n          row / uniforms.outShape[2],\n          row % uniforms.outShape[2],\n          col);\n      result[getIndexFromCoords4D(outCoord, uniforms.outShape)/${e}] = value;\n    }\n  }`}(this.isVec4?4:1)}\n    ${e}\n    `}}const yo={kernelName:o.A,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{dy:i,filter:s}=t,{inputShape:l,strides:a,pad:u,dataFormat:h,dimRoundingMode:c}=r,d=o.Oc.convertConv2DDataFormat(h),f=o.Oc.computeConv2DInfo(l,s.shape,a,1,u,c,!1,d),p=[{type:"int32",data:[f.filterHeight,f.filterWidth]},{type:"int32",data:[f.filterHeight-1-f.padInfo.top,f.filterWidth-1-f.padInfo.left]},{type:"int32",data:[f.strideHeight,f.strideWidth]},{type:"int32",data:[f.batchSize,f.outHeight,f.outWidth,f.outChannels]}];let m;if(Object(o.ad)().getBool("WEBGPU_USE_NAIVE_CONV2D_TRANSPOSE")||f.filterHeight<=2&&f.filterWidth<=2&&f.outChannels<=16&&1===f.inChannels)m=new fo(f);else{m=new bo(f);const e=f.inHeight*f.inWidth,t=f.inChannels,n=f.filterHeight*f.filterWidth*f.outChannels;p.push({type:"uint32",data:[e]},{type:"uint32",data:[t]},{type:"uint32",data:[n]})}return n.runWebGPUProgram(m,[i,s],"float32",p)}},xo={kernelName:o.B,backendName:"webgpu",kernelFunc:Dn({opType:hn.COS})},vo={kernelName:o.C,backendName:"webgpu",kernelFunc:Dn({opType:hn.COSH})};class wo{constructor(e,t,n,r){this.variableNames=["Image","Boxes","BoxInd"],this.uniforms="extrapolationValue : f32,",this.workgroupSize=[64,1,1],this.size=!0;const[i]=t;this.outputShape=[i,n[0],n[1],e],this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.methodId="bilinear"===r?1:0,this.cropHeightBiggerThan1=this.outputShape[1]>1,this.cropWidthBiggerThan1=this.outputShape[2]>1,this.shaderKey=`cropAndResize_${this.methodId}_${this.cropHeightBiggerThan1}_${this.cropWidthBiggerThan1}`}getUserCode(){const[e,t]=["f32(uniforms.imageShape[1] - 1)","f32(uniforms.imageShape[2] - 1)"],[n,r,i]=this.cropHeightBiggerThan1?[`(${e} / f32(uniforms.outShape[1] - 1))`,"(y2-y1) * height_ratio",`y1*${e} + f32(y)*(height_scale)`]:["0.0","0.0","0.5 * (y1+y2) * "+e],[s,o,a]=this.cropWidthBiggerThan1?[`(${t} / f32(uniforms.outShape[2] - 1))`,"(x2-x1) * width_ratio",`x1*${t} + f32(x)*(width_scale)`]:["0.0","0.0","0.5 * (x1+x2) * "+t];return`\n    ${Nt("index")} {\n      if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n        let height_ratio = f32(${n});\n        let width_ratio = f32(${s});\n        let b = coords[0];\n        let y = coords[1];\n        let x = coords[2];\n        let d = coords[3];\n        // get box vals\n        let y1 = getBoxes(b, 0);\n        let x1 = getBoxes(b, 1);\n        let y2 = getBoxes(b, 2);\n        let x2 = getBoxes(b, 3);\n        // get image in batch index\n        let bInd = i32(round(getBoxInd(b)));\n        if(bInd < 0 || bInd >= uniforms.outShape[0]) {\n          return;\n        }\n        let height_scale = ${r};\n        let width_scale = ${o};\n        let in_y = ${i};\n        if( in_y < 0.0 || in_y > ${e} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let in_x = ${a};\n        if( in_x < 0.0 || in_x > ${t} ) {\n          setOutputAtIndex(index, uniforms.extrapolationValue);\n          return;\n        }\n        let sourceFracIndexCR = vec2<f32>(in_x,in_y);\n        if(${this.methodId} == 1) {\n          // Compute the four integer indices.\n          let sourceFloorCR = vec2<i32>(sourceFracIndexCR);\n          let sourceCeilCR = vec2<i32>(ceil(sourceFracIndexCR));\n          let topLeft = getImage(bInd, sourceFloorCR.y, sourceFloorCR.x, d);\n          let bottomLeft = getImage(bInd, sourceCeilCR.y, sourceFloorCR.x, d);\n          let topRight = getImage(bInd, sourceFloorCR.y, sourceCeilCR.x, d);\n          let bottomRight = getImage(bInd, sourceCeilCR.y, sourceCeilCR.x, d);\n          let fracCR = sourceFracIndexCR - vec2<f32>(sourceFloorCR);\n          let top = topLeft + (topRight - topLeft) * fracCR.x;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          let newValue = top + (bottom - top) * fracCR.y;\n          setOutputAtIndex(index, newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          let sourceNearestCR = vec2<i32>(floor(\n            sourceFracIndexCR + vec2<f32>(0.5,0.5)));\n          let newValue = getImage(\n            bInd, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    }\n    `}}const ko={kernelName:o.D,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:r}=e,{image:i,boxes:s,boxInd:o}=t,{cropSize:a,method:u,extrapolationValue:l}=r,h=new wo(i.shape[3],s.shape,a,u),c=[{type:"float32",data:[l]}];return n.runWebGPUProgram(h,[i,s,o],"float32",c)}};var So;!function(e){e.Prod="*",e.Sum="+"}(So||(So={}));class Io{constructor(e,t,n,r){this.variableNames=["x"],this.uniforms="index : f32,",this.size=!0,this.workgroupSize=[128,1,1],this.outputShape=t,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.exclusive=n,this.reverse=r,this.op=e,this.shaderKey=`cum_${this.op}_${this.exclusive}_${this.reverse}`}getUserCode(){const e=this.outputShape.length,t=this.op===So.Prod?"1.0":"0.0",n=this.exclusive?t:`getX(${Co(e,"coords",this.op)})`,r=this.outputShape[this.outputShape.length-1];let i="",s="";return this.exclusive?(i=this.reverse?"end != "+(r-1):"end != 0",s=this.reverse?"end + 1":"end - 1"):(i=this.reverse?"end + pow2 < "+r:"end >= pow2",s=this.reverse?"end + pow2":"end - pow2"),`\n      ${Nt("index")} {\n       if (index < uniforms.size) {\n         var coords = getCoordsFromIndex(index);\n\n         let end = ${Oo(e,"coords",this.op)};\n         var val = ${n};\n         let pow2 = i32(pow(2.0, uniforms.index));\n         if (${i}) {\n           let idx = ${s};\n           ${Oo(e,"coords",this.op)} = idx;\n           val ${this.op}= getX(${Co(e,"coords",this.op)});\n         }\n         setOutputAtIndex(index, val);\n       }\n      }\n    `}}function Co(e,t,n){if(1===e)return""+t;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Oo(e,t,n){if(1===e)return""+t;if(2===e)return t+".y";if(3===e)return t+".z";if(4===e)return t+".w";throw Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function Ao(e,t,n,r,i,s){const l=t.shape.length,a=o.Oc.getAxesPermutation([r],l);let u=t;null!=a&&(u=pi({inputs:{x:t},backend:n,attrs:{perm:a}}));const h=o.Oc.getInnerMostAxes(1,l)[0];if(h!==l-1)throw new Error(`WebGPU cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=`+r);const c=u.shape[h];let d=zn({inputs:{x:u},backend:n});for(let t=0;t<=Math.ceil(Math.log2(c))-1;t++){const r=new Io(e,u.shape,!1,s),i=d,o=[{type:"float32",data:[t]}];d=n.runWebGPUProgram(r,[d],d.dtype,o),n.disposeData(i.dataId)}if(i){const t=new Io(e,u.shape,i,s),r=d,o=[{type:"float32",data:[0]}];d=n.runWebGPUProgram(t,[d],d.dtype,o),n.disposeData(r.dataId)}if(null!=a){const e=pi({inputs:{x:d},backend:n,attrs:{perm:o.Oc.getUndoAxesPermutation(a)}});return n.disposeData(d.dataId),n.disposeData(u.dataId),e}return d}const To={kernelName:o.E,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,exclusive:o,reverse:a}=r;return Ao(So.Prod,i,n,s,o,a)}},Eo={kernelName:o.F,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,exclusive:o,reverse:a}=r;return Ao(So.Sum,i,n,s,o,a)}},Ro={kernelName:o.H,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s,weights:r}=t,{size:a,binaryOutput:u}=i,l=1===s.shape.length,h=o.Ed.sizeFromShape(r.shape)>0,c=r.dtype,d=l?[s.shape[0]]:[s.shape[0],s.shape[1]],p=Tn({backend:n,attrs:{shape:l?[a]:[s.shape[0],a],value:0,dtype:c}}),f=new Vi(d,h,u),m=[{type:"int32",data:[a]}],g=h?[s,r]:[s];return n.runWebGPUProgram(f,g,c,m,p)}};class Po{constructor(e,t){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.uniforms="blockSize : i32,",this.outputShape=e,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="depthToSpace_"+t,this.dataFormat=t}getUserCode(){return`\n      ${Nt("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let h = ${this.getHeightCoordString()};\n          let w = ${this.getWidthCoordString()};\n          let d = ${this.getDepthCoordString()};\n\n          let in_h = h / uniforms.blockSize;\n          let offset_h = h % uniforms.blockSize;\n          let in_w = w / uniforms.blockSize;\n          let offset_w = w % uniforms.blockSize;\n          let offset_d = (offset_h * uniforms.blockSize + offset_w) *\n            ${this.getOutputDepthSize()};\n          let in_d = d + offset_d;\n\n          let rlt = ${this.getInputSamplingString()};\n          setOutputAtIndex(index, rlt);\n        }\n      }`}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?"uniforms.outShape[3]":"uniforms.outShape[1]"}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const $o={kernelName:o.I,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{blockSize:s,dataFormat:o}=r,a=i.shape[0],u=("NHWC"===o?i.shape[1]:i.shape[2])*s,l=("NHWC"===o?i.shape[2]:i.shape[3])*s,h=("NHWC"===o?i.shape[3]:i.shape[1])/(s*s),c=[{type:"int32",data:[s]}],d=new Po("NHWC"===o?[a,u,l,h]:[a,h,u,l],o);return n.runWebGPUProgram(d,[i],i.dtype,c)}};class Fo{constructor(e,t,n,r=!1,i=null,s=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[16,16,1],this.outputShape=e,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),r&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),this.addBias=r,this.activation=i,this.hasPreluActivation=s,this.filterHeight=t,this.filterWidth=n,this.shaderKey=`depthwiseNCHW_${this.activation}_${this.filterHeight}_${this.filterWidth}`}getUserCode(){const e=this.filterWidth*this.filterHeight,t=this.workgroupSize[0]*this.workgroupSize[1]*this.workgroupSize[2],n=this.workgroupSize[1]+this.filterHeight-1,r=this.workgroupSize[0]+this.filterWidth-1;return`\n      ${mn(this.activation,this.hasPreluActivation,!1,4)}\n\n      var<workgroup> mm_Asub : array<array<f32, ${r}>, ${n}>;\n      var<workgroup> mm_Bsub : array<array<f32, ${this.filterWidth}>, ${this.filterHeight}>;\n      fn readX(batch : i32, channel : i32, row : i32, col : i32) -> f32 {\n        var value = 0.0;\n        if (row >=0 && row < uniforms.inDims[0] && col >=0 && col < uniforms.inDims[1])\n        {\n          value = getX(batch, channel, row, col);\n        }\n        return value;\n      }\n\n      ${Nt()} {\n        let coords = getOutputCoords();\n        let batch = coords[0];\n        let xRCCorner = vec2<i32>(coords.zw) - uniforms.pad;\n        let channelMul = uniforms.wShape[3];\n        let d1 = coords[1] / channelMul;\n        let q = coords[1] % channelMul;\n\n        let inputRowStart = xRCCorner.x;\n        let inputColStart = xRCCorner.y;\n\n        let localRow = i32(localId.y);\n        let localCol = i32(localId.x);\n\n        // Load one tile of X into local memory.\n        for (var inputRow = localRow; inputRow < ${n}; inputRow = inputRow + ${this.workgroupSize[1]}) {\n          for (var inputCol = localCol; inputCol < ${r}; inputCol = inputCol + ${this.workgroupSize[0]}) {\n            let rowOffset = inputRow - localRow;\n            let colOffset = inputCol - localCol;\n            mm_Asub[inputRow][inputCol] = readX(batch, d1, inputRowStart + rowOffset, inputColStart + colOffset);\n          }\n        }\n\n        // Load one tile of W into local memory.\n        var wIndex = i32(localIndex);\n        ${e<t?`if (wIndex < ${e})`:`for(; wIndex < ${e}; wIndex = wIndex + ${t})`}\n\n        {\n          let wRow = wIndex / ${this.filterWidth};\n          let wCol = wIndex % ${this.filterWidth};\n          mm_Bsub[wRow][wCol] = getW(wRow, wCol, d1, q);\n        }\n\n        workgroupBarrier();\n\n        var value = 0.0;\n        for (var wR = 0; wR < ${this.filterHeight}; wR = wR + 1) {\n          for (var wC = 0; wC < ${this.filterWidth}; wC = wC + 1) {\n            let xVal = mm_Asub[localRow + wR][localCol + wC];\n            let wVal = mm_Bsub[wR][wC];\n            value = fma(xVal, wVal, value);\n          }\n        }\n        ${gn(this.addBias,this.activation)}\n        if (coordsInBounds4D(coords, uniforms.outShape)) {\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}class _o{constructor(e,t=!1,n=null,i=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>,",this.workgroupSize=[4,4,4],this.workPerThread=4,this.isVec4=!0,this.outputShape=e.outShape,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize,[4,this.workPerThread,1]),o.Ed.assert("channelsLast"===e.dataFormat,(()=>"TODO: NCHW is unimplemented")),t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=i,this.shaderKey=`depthwiseVec4_${n}_${this.convInfo.filterHeight}_${this.convInfo.filterWidth}_${this.convInfo.strideHeight}_${this.convInfo.strideWidth}_${this.workPerThread}`}getUserCode(){const e=(this.workPerThread-1)*this.convInfo.strideWidth+this.convInfo.filterWidth,t=this.convInfo.strideHeight,n=this.convInfo.strideWidth;return`\n      ${mn(this.activation,this.hasPreluActivation,!0,4)}\n      fn readX(batch : i32, row : i32, col : i32, channel : i32) -> vec4<f32> {\n        var value = vec4<f32>(0.0);\n        if (col >=0 && col < uniforms.inDims[1]) {\n          value = getX(batch, row, col, channel);\n        }\n        return value;\n      }\n\n      ${Nt()} {\n        let batch = i32(globalId.z) / uniforms.outShape[1];\n        let r = i32(globalId.z) % uniforms.outShape[1];\n        let c = i32(globalId.y) * ${this.workPerThread};\n        let d1 = i32(globalId.x) * 4;\n        let xRCCorner = vec2<i32>(r, c) * vec2<i32>(${t}, ${n}) - uniforms.pad;\n\n        let xRCorner = xRCCorner.x;\n        let xCCorner = xRCCorner.y;\n        var xVals : array<vec4<f32>, ${e}>;\n        var dotProd : array<vec4<f32>, ${this.workPerThread}>;\n        for (var i = 0; i < ${this.workPerThread}; i++) {\n          dotProd[i] = vec4<f32>(0.0);\n        }\n\n        // Use constant instead of uniform can give better performance.\n        for (var wR = 0; wR < ${this.convInfo.filterHeight}; wR = wR + 1) {\n          let xR = xRCorner + wR;\n          if (xR >=0 && xR < uniforms.inDims[0]) {\n            for (var i = 0; i < ${e}; i++) {\n              xVals[i] = readX(batch, xR, xCCorner + i, d1);\n            }\n            for (var wC = 0; wC < ${this.convInfo.filterWidth}; wC = wC + 1) {\n              let wValue = getW(wR, wC, d1, 0);\n              for (var i = 0; i < ${this.workPerThread}; i++) {\n                dotProd[i] = fma(xVals[i * ${n} + wC], wValue, dotProd[i]);\n              }\n            }\n          }\n        }\n\n        for (var i = 0; i < ${this.workPerThread}; i = i + 1) {\n          let coords = vec4<i32>(batch, r, c + i, d1);\n          if (coordsInBounds4D(coords, uniforms.outShape)) {\n            var value = dotProd[i];\n            ${gn(this.addBias,this.activation)}\n            setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n          }\n        }\n      }\n    `}}class No{constructor(e,t=!1,n=null,r=!1){this.variableNames=["x","W"],this.uniforms="pad : vec2<i32>, inDims : vec2<i32>, filterHeight : i32,\n      filterWidth : i32, stride : vec2<i32>, dilation : vec2<i32>,",this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.isChannelsLast="channelsLast"===e.dataFormat,t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),this.convInfo=e,this.addBias=t,this.activation=n,this.hasPreluActivation=r,this.shaderKey=`depthwise_${this.activation}_${this.isChannelsLast}`}getUserCode(){const e=this.isChannelsLast?"getX(batch, xR, xC, d1);":"getX(batch, d1, xR, xC);";return`\n      ${mn(this.activation,this.hasPreluActivation,!1,4)}\n\n      ${Nt("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let batch = coords[0];\n          let xRCCorner = vec2<i32>(coords.${this.isChannelsLast?"yz":"zw"}) * uniforms.stride - uniforms.pad;\n          let d2 = coords[${this.isChannelsLast?3:1}];\n          let channelMul = uniforms.wShape[3];\n          let d1 = d2 / channelMul;\n          let q = d2 % channelMul;\n\n          let inputRowStart = xRCCorner.x;\n          let inputColStart = xRCCorner.y;\n          let inputRowEnd = inputRowStart + uniforms.filterHeight *\n              uniforms.dilation[0];\n          let inputColEnd = inputColStart + uniforms.filterWidth *\n              uniforms.dilation[1];\n\n          // Convolve x(?, ?, d1)|x(d1, ?, ?) with w(:, :, d1, q) to get\n          // y(yR, yC, d2)|y(d2, yR, yC). ? = to be determined. : = across all\n          // values in that axis. x(?, ?, d1) and y(yR, yC, d2) is for NHWC.\n          // x(d1, ?, ?) and y(d2, yR, yC) is for NCHW.\n          var value = 0.0;\n\n          // Extract if checking out of for loop for performance.\n          if (inputRowStart >= 0 && inputColStart >= 0 &&\n            inputRowEnd < uniforms.inDims[0] &&\n                inputColEnd < uniforms.inDims[1]) {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilation[0];\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilation[1];\n\n                  let xVal = ${e};\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            } else {\n              for (var wR = 0; wR < uniforms.filterHeight; wR = wR + 1) {\n                let xR = inputRowStart + wR * uniforms.dilation[0];\n\n                if (xR < 0 || xR >= uniforms.inDims[0]) {\n                  continue;\n                }\n\n                for (var wC = 0; wC < uniforms.filterWidth; wC = wC + 1) {\n                  let xC = inputColStart + wC * uniforms.dilation[1];\n\n                  if (xC < 0 || xC >= uniforms.inDims[1]) {\n                    continue;\n                  }\n\n                  let xVal = ${e};\n                  let wVal = getW(wR, wC, d1, q);\n                  value = value + xVal * wVal;\n                }\n              }\n            }\n            ${gn(this.addBias,this.activation)}\n          setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);\n        }\n      }\n    `}}const zo={kernelName:o.J,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,filter:s}=t,{strides:l,pad:a,dataFormat:u,dilations:h,dimRoundingMode:c}=r,d=o.Oc.convertConv2DDataFormat(u);let f=h;null==f&&(f=[1,1]);const p=o.Oc.computeConv2DInfo(i.shape,s.shape,l,f,a,c,!0,d),m=[{type:"int32",data:[p.padInfo.top,p.padInfo.left]},{type:"int32",data:[p.inHeight,p.inWidth]}],y="channelsLast"===p.dataFormat;let g;return!y&&p.inHeight>16&&p.inWidth>16&&1===p.strideHeight&&1===p.strideWidth&&1===p.dilationWidth&&1===p.dilationHeight&&p.inChannels===p.outChannels?g=new Fo(p.outShape,p.filterHeight,p.filterWidth):y&&p.outHeight>4&&p.outWidth>4&&p.strideWidth<=2&&p.inChannels===p.outChannels&&1===p.dilationHeight&&1===p.dilationWidth&&p.inChannels%4==0?g=new _o(p):(g=new No(p),m.push({type:"int32",data:[p.filterHeight]},{type:"int32",data:[p.filterWidth]},{type:"int32",data:[p.strideHeight,p.strideWidth]},{type:"int32",data:[p.dilationHeight,p.dilationWidth]})),n.runWebGPUProgram(g,[i,s],i.dtype,m)}};class Mo{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,e],this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="diag"}getUserCode(){return`\n      ${Nt("index")} {\n        if (index < uniforms.size) {\n          let coords = getOutputCoords();\n          let value = select(0.0, getX(coords[0]), coords[0] == coords[1]);\n          setOutputAtIndex(index, value);\n        }\n      }\n    `}}const Lo={kernelName:o.K,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:i}=t,s=[...i.shape,...i.shape],r=o.Ed.sizeFromShape(i.shape),a=Rn({inputs:{x:i},backend:n,attrs:{shape:[r]}}),u=new Mo(r),l=n.runWebGPUProgram(u,[a],a.dtype),h=Rn({inputs:{x:l},backend:n,attrs:{shape:s}});return n.disposeData(a.dataId),n.disposeData(l.dataId),h}};class Bo{constructor(e){this.variableNames=["x","w"],this.uniforms="filterDims: vec2<i32>, pad: vec2<i32>, stride: vec2<i32>, dilation: vec2<i32>",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.outShape,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="dilation2d"}getUserCode(){return`\n       ${Nt("index")} {\n         if (index < uniforms.size) {\n           let neg_infinity = -3.4e38;\n           let coords = getOutputCoords();\n           let batch = coords.x;\n           let d1 = coords.w;\n           let outTopLeftCorner = coords.yz * uniforms.stride - uniforms.pad;\n           let hBeg = outTopLeftCorner.x;\n           let wBeg = outTopLeftCorner.y;\n\n           var curVal = neg_infinity;\n           for (var h = 0; h < uniforms.filterDims[0]; h = h + 1) {\n             let hIn = hBeg + h * uniforms.dilation[0];\n\n             if (hIn >= 0 && hIn < uniforms.xShape[1]) {\n               for (var w = 0; w < uniforms.filterDims[1]; w = w + 1) {\n                 let wIn = wBeg + w * uniforms.dilation[1];\n\n                 if (wIn >= 0 && wIn < uniforms.xShape[2]) {\n                   let val = getX(batch, hIn, wIn, d1) + getW(h, w, d1);\n                   if (val > curVal) {\n                     curVal = val;\n                   }\n                 }\n               }\n             }\n           }\n\n           setOutputAtIndex(index, curVal);\n         }\n       }\n     `}}const Uo={kernelName:o.L,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,filter:s}=t,{strides:l,pad:a,dilations:u}=r,h=o.Oc.computeDilation2DInfo(i.shape,s.shape,l,a,"NHWC",u),c=[h.padInfo.top,h.padInfo.left],d=[{type:"int32",data:[h.filterHeight,h.filterWidth]},{type:"int32",data:[...c]},{type:"int32",data:[h.strideHeight,h.strideWidth]},{type:"int32",data:[h.dilationHeight,h.dilationWidth]}],f=new Bo(h);return n.runWebGPUProgram(f,[i,s],i.dtype,d)}},Do=jn({opType:en.MUL,cpuKernelImpl:jr,supportsComplex:!0}),jo={kernelName:o.Fb,backendName:"webgpu",kernelFunc:Do};function Wo(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,keepDims:o}=r;return gi(i,s,o,"sum",n)}const Vo={kernelName:o.zc,backendName:"webgpu",kernelFunc:Wo},Go={kernelName:o.M,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{equation:s}=i,r=t,{allDims:a,summedDims:u,idDims:l}=o.Oc.decodeEinsumEquation(s,r.length);o.Oc.checkEinsumDimSizes(a.length,l,r);const{path:h,steps:c}=o.Oc.getEinsumComputePath(u,l),d=c.length;let p=null,f=a.length;const m=[];for(let e=0;e<d;++e){for(const t of c[e]){const{permutationIndices:e,expandDims:i}=o.Oc.getEinsumPermutation(f,l[t]);let s;o.Oc.isIdentityPermutation(e)?s=r[t]:(s=pi({inputs:{x:r[t]},backend:n,attrs:{perm:e}}),m.push(s));const a=s.shape.slice();for(let e=0;e<i.length;++e)a.splice(i[e],0,1);o.Ed.arraysEqual(s.shape,a)||(s=Rn({inputs:{x:s},backend:n,attrs:{shape:a}}),m.push(s)),null===p?p=s:(p=Do({inputs:{a:s,b:p},backend:n}),m.push(p))}e<d-1&&(h[e]>=0&&(p=Wo({inputs:{x:p},backend:n,attrs:{axis:h[e]-(a.length-f),keepDims:!1}}),m.push(p)),f--)}for(const e of m)e!==p&&n.disposeData(e.dataId);return p}},Ho={kernelName:o.N,backendName:"webgpu",kernelFunc:Dn({opType:hn.ELU})},ol={kernelName:o.O,backendName:"webgpu",kernelFunc:jn({opType:en.EQUAL,dtype:"bool",cpuKernelImpl:Tr})},Ko={kernelName:o.P,backendName:"webgpu",kernelFunc:Dn({opType:hn.ERF})},ul=Dn({opType:hn.EXP,cpuKernelImpl:Er,dtype:"float32"}),Xo={kernelName:o.Q,backendName:"webgpu",kernelFunc:ul};function Yo(e){const{inputs:t,attrs:n,backend:i}=e,{dim:s}=n,{input:r}=t,a=r.shape.length,u=r.shape.slice();let l=s;return s<0&&(o.Ed.assert(-(a+1)<=s,(()=>`Axis must be in the interval [${-(a+1)}, ${a}]`)),l=a+s+1),u.splice(l,0,1),Rn({inputs:{x:r},backend:i,attrs:{shape:u}})}const qo={kernelName:o.R,backendName:"webgpu",kernelFunc:Yo},dl={kernelName:o.S,backendName:"webgpu",kernelFunc:Dn({opType:hn.EXPM1,cpuKernelImpl:Rr})};class Qo{constructor(e,t){this.variableNames=["real","imag"],this.outputShape=[],this.uniforms="exponentMultiplier : f32, denominator: f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.component=e,this.shaderKey="fft_"+e}getUserCode(){return`\n    fn unaryOpComplex(real: f32, expR: f32, imag: f32, expI: f32) -> f32 {\n      ${"real"===this.component?"return real * expR - imag * expI;":"return real * expI + imag * expR;"}\n    }\n\n    fn mulMatDFT(batch: i32, index: i32) -> f32 {\n      let indexRatio = f32(index) / f32(uniforms.realShape[1]);\n      let exponentMultiplierTimesIndexRatio =\n          uniforms.exponentMultiplier * indexRatio;\n\n      var result = 0.0;\n\n      for (var i = 0; i < uniforms.realShape[1]; i = i + 1) {\n        // x = (-2|2 * PI / N) * index * i;\n        let x = exponentMultiplierTimesIndexRatio * f32(i);\n        let expR = cos(x);\n        let expI = sin(x);\n        let real = getReal(batch, i);\n        let imag = getImag(batch, i);\n\n        result = result +\n            unaryOpComplex(real, expR, imag, expI) / uniforms.denominator;\n      }\n\n      return result;\n    }\n\n    ${Nt("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        setOutputAtIndex(index, mulMatDFT(coords[0], coords[1]));\n      }\n    }\n  `}}function Zo(e,t,n){const i=n.tensorMap.get(e.dataId),s=o.Ed.sizeFromShape(e.shape),r=e.shape[e.shape.length-1],a=[],u=Rn({inputs:{x:e},backend:n,attrs:{shape:[s/r,r]}});a.push(u);const l=u.shape,h=new Qo("real",l),c=new Qo("imag",l),d=[{dataId:i.complexTensorInfos.real.dataId,dtype:i.complexTensorInfos.real.dtype,shape:l},{dataId:i.complexTensorInfos.imag.dataId,dtype:i.complexTensorInfos.imag.dtype,shape:l}],p=[{type:"float32",data:[t?2*Math.PI:-2*Math.PI]},{type:"float32",data:[t?l[1]:1]}],f=n.runWebGPUProgram(h,d,"float32",p);a.push(f);const m=n.runWebGPUProgram(c,d,"float32",p);a.push(m);const g=Ln({inputs:{real:f,imag:m},backend:n});a.push(g);const y=Rn({inputs:{x:g},backend:n,attrs:{shape:e.shape}});return a.forEach((e=>n.disposeData(e.dataId))),y}const Jo={kernelName:o.T,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return Zo(r,!1,n)}};class ea{constructor(e){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="flipLeftRight"}getUserCode(){return`\n      ${Nt("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let coordX = uniforms.xShape[2] - coords[2] - 1;\n          let outputValue = getX(coords[0], coords[1], coordX, coords[3]);\n          setOutputAtIndex(index, outputValue);\n        }\n      }\n    `}}const ta={kernelName:o.V,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{const{image:n}=e,r=t,i=new ea(n.shape);return r.runWebGPUProgram(i,[n],n.dtype)}},na={kernelName:o.W,backendName:"webgpu",kernelFunc:Dn({opType:hn.FLOOR,cpuKernelImpl:Pr})},ra={kernelName:o.X,backendName:"webgpu",kernelFunc:jn({opType:en.INT_DIV,dtype:"int32"})};class ia{constructor(e,t,n=!1){this.isFromPixels=!0,this.outputShape=[0],this.variableNames=[],this.workgroupSize=[256,1,1],this.outputShape=e,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize,[t,1,1]),this.importVideo=n,this.shaderKey="fromPixels_"+this.importVideo}getUserCode(){const e=this.importVideo?"textureLoad(src, vec2<i32>(coords.yx));":"textureLoad(src, vec2<i32>(coords.yx), 0)";return`\n      @binding(1) @group(0) var src: ${this.importVideo?"texture_external":"texture_2d<f32>"};\n      ${Nt("index")} {\n        let flatIndex = index * uniforms.numChannels;\n        if (flatIndex < uniforms.size) {\n          let coords = getCoordsFromIndex(flatIndex);\n          let values = ${e};\n          for (var i = 0; i < uniforms.numChannels; i = i + 1) {\n            result[flatIndex + i] = i32(floor(255.0 * values[i]));\n          }\n        }\n      }\n  `}}const oa={kernelName:o.Y,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e;let{pixels:s}=t;const{numChannels:r}=i;if(null==s)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");const a="undefined"!=typeof HTMLVideoElement&&s instanceof HTMLVideoElement,u="undefined"!=typeof HTMLImageElement&&s instanceof HTMLImageElement,l="undefined"!=typeof HTMLCanvasElement&&s instanceof HTMLCanvasElement||"undefined"!=typeof OffscreenCanvas&&s instanceof OffscreenCanvas,h="undefined"!=typeof ImageBitmap&&s instanceof ImageBitmap,[c,d]=a?[s.videoWidth,s.videoHeight]:[s.width,s.height],p=[d,c,r],f=a||u;if(h||l||f){let e;{if(f){const e=Object(o.ad)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=aa&&e===sa||(sa=e,aa=document.createElement("canvas").getContext("2d",{willReadFrequently:sa})),aa.canvas.width=c,aa.canvas.height=d,aa.drawImage(s,0,0,c,d),s=aa.canvas}const t=GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,r="rgba8unorm",i=n.textureManager.acquireTexture(p[1],p[0],r,t);n.queue.copyExternalImageToTexture({source:s},{texture:i},[p[1],p[0]]),e={width:c,height:d,format:r,usage:t,texture:i}}const t=o.Ed.sizeFromShape(p),i=o.Ed.computeStrides(p),a=new ia(p,r,!1),u=[{type:"uint32",data:[t]},{type:"uint32",data:[r]},{type:"uint32",data:[...i]}],l=n.makeTensorInfo([d,c],"int32");n.tensorMap.get(l.dataId).resourceInfo=e;const h=n.runWebGPUProgram(a,[l],"int32",u);return n.disposeData(l.dataId),h}const m=s.data;let g=m;if(null!=r&&4!==r){g=new Uint8Array(s.width*s.height*r);const e=m.length;let t=0;for(let n=0;n<e;n++)n%4<r&&(g[t++]=m[n])}const y=n.makeTensorInfo(p,"int32",new Int32Array(g));return n.uploadToGPU(y.dataId),y}};let aa,sa=Object(o.ad)().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");class ua{constructor(e,t,n,r,i){this.uniforms="varianceEpsilon : f32,",this.workgroupSize=[128,1,1],this.size=!0,this.variableNames=["x","mean","variance"],o.Oc.assertAndGetBroadcastShape(e,t),o.Oc.assertAndGetBroadcastShape(e,n),this.outputShape=e,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),null!=r&&(o.Oc.assertAndGetBroadcastShape(e,r),this.variableNames.push("offset")),null!=i&&(o.Oc.assertAndGetBroadcastShape(e,i),this.variableNames.push("scale")),this.offsetShape=r,this.scaleShape=i,this.shaderKey="batchNorm"}getUserCode(){let e="0.0";null!=this.offsetShape&&(e="getOffsetByOutputIndex(index)");let t="1.0";return null!=this.scaleShape&&(t="getScaleByOutputIndex(index)"),`\n      ${Nt("index")} {\n        if (index < uniforms.size)\n        {\n          let xValue = getXByOutputIndex(index);\n          let meanValue = getMeanByOutputIndex(index);\n          let varianValue = getVarianceByOutputIndex(index);\n          let offsetValue = ${e};\n          let scaleValue = ${t};\n          let inv = scaleValue * inverseSqrt(varianValue + f32(uniforms.varianceEpsilon));\n          setOutputAtIndex(index,dot(vec3<f32>(xValue, -meanValue, offsetValue), vec3<f32>(inv, inv, 1.0)));\n        }\n      }\n  `}}const la={kernelName:o.Z,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r,scale:i,offset:s,mean:o,variance:a}=e,{varianceEpsilon:u}=t,l=n,h=[r,o,a];let c=null;null!=s&&(c=s.shape,h.push(s));let d=null;null!=i&&(d=i.shape,h.push(i));const p=new ua(r.shape,o.shape,a.shape,c,d),f=[{type:"float32",data:[u]}];return l.runWebGPUProgram(p,h,r.dtype,f)}},ha={kernelName:o.ab,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i,filter:s,bias:l,preluActivationWeights:a}=t,{strides:u,pad:h,dataFormat:c,dilations:d,dimRoundingMode:f,activation:p,leakyreluAlpha:m}=r,y=o.Oc.convertConv2DDataFormat(c);return co({x:i,filter:s,convInfo:o.Oc.computeConv2DInfo(i.shape,s.shape,u,d,h,f,!1,y),backend:n,bias:l,preluActivationWeights:a,leakyreluAlpha:m,activation:p})}},ca={kernelName:o.bb,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s,filter:r,bias:a,preluActivationWeights:u}=t,{strides:l,pad:h,dilations:c,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=i;let m=c;null==m&&(m=[1,1]),o.Ed.assert(o.Oc.eitherStridesOrDilationsAreOne(l,m),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`));const g=o.Oc.computeConv2DInfo(s.shape,r.shape,l,m,h,d,!0),y=[s,r],x=null!=a,b=null!=u;x&&y.push(a),b&&y.push(u);const v=[{type:"int32",data:[g.padInfo.top,g.padInfo.left]},{type:"int32",data:[g.inHeight,g.inWidth]}];let w;return g.outHeight>4&&g.outWidth>4&&g.strideWidth<=2&&g.inChannels===g.outChannels&&1===g.dilationHeight&&1===g.dilationWidth&&g.inChannels%4==0?w=new _o(g,x,p,b):(w=new No(g,x,p,b),v.push({type:"int32",data:[g.filterHeight]},{type:"int32",data:[g.filterWidth]},{type:"int32",data:[g.strideHeight,g.strideWidth]},{type:"int32",data:[g.dilationHeight,g.dilationWidth]})),"leakyrelu"===p&&(v.push({type:"float32",data:[f]}),w.uniforms+=" alpha : f32,"),n.runWebGPUProgram(w,y,"float32",v)}};class da{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gathernd_"+e,this.sliceDim=e,this.uniforms=`sliceDim : i32, strides : ${Ft(e)},`}getUserCode(){let e;return e=this.sliceDim>1?"uniforms.strides[j]":"uniforms.strides",`\n      ${Nt("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          var flattenIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexTemp = i32(round(getIndices(coords[0], j)));\n            let strideNum = ${e};\n            flattenIndex = flattenIndex + indexTemp * strideNum;\n          }\n\n          setOutputAtIndex(index, getA(flattenIndex, coords[1]));\n        }\n      }\n      `}}const pa={kernelName:o.cb,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:i,indices:s}=t,r=s.shape,a=r[r.length-1],u=o.Ed.sizeFromShape(i.shape),[l,h,c,d]=o.Oc.prepareAndValidate(i,s),p=Rn({inputs:{x:s},backend:n,attrs:{shape:[h,a]}}),f=Rn({inputs:{x:i},backend:n,attrs:{shape:[o.Ed.sizeFromShape(i.shape)/c,c]}});if(n.shouldExecuteOnCPU([i,s])||"string"===i.dtype){const e=n.readSync(s.dataId),t=n.bufferSync(i),r=$r(e,t,i.dtype,h,a,c,d,i.shape,u);return n.makeTensorInfo(l,i.dtype,r.values)}const m=new da(a,[h,c]),g=[{type:"int32",data:[a]},{type:"int32",data:d}],y=n.runWebGPUProgram(m,[f,p],f.dtype,g),x=Rn({inputs:{x:y},backend:n,attrs:{shape:l}});return n.disposeData(p.dataId),n.disposeData(f.dataId),n.disposeData(y.dataId),x}};class fa{constructor(e,t){this.variableNames=["A","indices"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e.slice(),this.aShape=e,this.outputShape=t,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="gather"}getUserCode(){const e=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let r=0;r<e.length;r++)2===r?n.push("indexZ"):n.push(""+t[r]);return n.join()}(this.aShape);return`\n      ${Nt("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let indexZ = i32(getIndices(resRC.x, resRC.z));\n          let inBounds = select(0.0, 1.0, indexZ >= 0 && indexZ < uniforms.aShape[2]);\n          setOutputAtIndex(index, inBounds * getA(${e}));\n        }\n      }\n    `}}function ma(e){const{inputs:t,backend:n,attrs:i}=e,{x:s,indices:r}=t,{axis:a,batchDims:u}=i,l=o.Ed.parseAxisParam(a,s.shape)[0],h=o.Oc.segment_util.collectGatherOpShapeInfo(s,r,l,u),c=o.Ed.sizeFromShape(r.shape),d=[],p=Rn({inputs:{x:s},backend:n,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),f=Rn({inputs:{x:r},backend:n,attrs:{shape:[h.batchSize,c/h.batchSize]}});d.push(p),d.push(f);const m=[h.batchSize,h.outerSize,c/h.batchSize,h.sliceSize];if(n.shouldExecuteOnCPU([s,r])){const e=n.tensorMap.get(f.dataId).values,t=Object(o.Sc)(f.shape,f.dtype,e),r=n.tensorMap.get(p.dataId).values,i=Object(o.Sc)(p.shape,p.dtype,r),s=Fr(i,t,m);return d.forEach((e=>n.disposeData(e.dataId))),n.makeTensorInfo(h.outputShape,s.dtype,s.values)}const g=new fa(p.shape,m),y=n.runWebGPUProgram(g,[p,f],p.dtype);d.push(y);const x=Rn({inputs:{x:y},backend:n,attrs:{shape:h.outputShape}});return d.forEach((e=>n.disposeData(e.dataId))),x}const ga={kernelName:o.db,backendName:"webgpu",kernelFunc:ma},ba={kernelName:o.eb,backendName:"webgpu",kernelFunc:jn({opType:en.GREATER,cpuKernelImpl:Nr,dtype:"bool"})},ya={kernelName:o.fb,backendName:"webgpu",kernelFunc:jn({opType:en.GREATER_EQUAL,dtype:"bool",cpuKernelImpl:_r})},xa={kernelName:o.gb,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:r}=t;return Zo(r,!0,n)}},va={kernelName:o.jb,backendName:"webgpu",kernelFunc:Dn({opType:hn.IS_FINITE,dtype:"bool"})},wa={kernelName:o.kb,backendName:"webgpu",kernelFunc:Dn({opType:hn.IS_INF,dtype:"bool"})},ka={kernelName:o.lb,backendName:"webgpu",kernelFunc:Dn({opType:hn.IS_NAN,dtype:"bool"})},Sa={kernelName:o.ob,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{alpha:s}=r,o=[{type:"float32",data:[s]}],a=new Un(i.shape,hn.LEAKYRELU,"alpha : f32,");return n.runWebGPUProgram(a,[i],"float32",o)}},Ia={kernelName:o.pb,backendName:"webgpu",kernelFunc:jn({opType:en.LESS,dtype:"bool",cpuKernelImpl:Mr})},Ca={kernelName:o.qb,backendName:"webgpu",kernelFunc:jn({opType:en.LESS_EQUAL,dtype:"bool",cpuKernelImpl:zr})};class Oa{constructor(e){this.variableNames=[],this.outputShape=[],this.uniforms="start : f32, step : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e],this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="linSpace"}getUserCode(){return`\n      ${Nt("index")} {\n        if (index < uniforms.size) {\n          setOutputAtIndex(index, uniforms.start + f32(index) * uniforms.step);\n        }\n      }\n    `}}const Aa={kernelName:o.rb,backendName:"webgpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:r,stop:i,num:s}=n,o=(i-r)/(s-1),a=new Oa(s),u=[{type:"float32",data:[r]},{type:"float32",data:[o]}];return t.runWebGPUProgram(a,[],"float32",u)}},Ta={kernelName:o.sb,backendName:"webgpu",kernelFunc:Dn({opType:hn.LOG,cpuKernelImpl:Lr})},Ea={kernelName:o.tb,backendName:"webgpu",kernelFunc:Dn({opType:hn.LOG1P})},Ra={kernelName:o.ub,backendName:"webgpu",kernelFunc:jn({opType:en.LOGICAL_AND,dtype:"bool"})},Pa={kernelName:o.vb,backendName:"webgpu",kernelFunc:Dn({opType:hn.LOGICAL_NOT})},$a={kernelName:o.wb,backendName:"webgpu",kernelFunc:jn({opType:en.LOGICAL_OR})},Fa="\n  var powValue = 0.0;\n  let basis = uniforms.bias + uniforms.alpha * sum;\n  if (uniforms.beta == 0.5) {\n    powValue = inverseSqrt(basis);\n  } else if (uniforms.beta == 1.0) {\n    powValue = 1.0 / basis;\n  } else {\n    powValue = exp(log(basis) * (-uniforms.beta));\n  }\n";class _a{constructor(e){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="lrn"}getUserCode(){return`\n    ${Nt("index")} {\n      if (index < uniforms.size) {\n        let coords = getOutputCoords();\n        let b = coords[0];\n        let r = coords[1];\n        let c = coords[2];\n        let d = coords[3];\n\n        let x = getX(b, r, c, d);\n        var sum = 0.0;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let idx = d + i;\n          if (idx >= 0 && idx < uniforms.xShape[3]) {\n            let z = getX(b, r, c, idx);\n            sum = sum + z * z;\n          }\n        }\n        ${Fa}\n\n        setOutputAtIndex(index, x * powValue);\n      }\n    }\n  `}}class Na{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.uniforms="radius : i32, bias : f32, alpha : f32, beta : f32,",this.workgroupSize=[256,1,1],this.maxAllowRadius=16,o.Ed.assert(t<=this.maxAllowRadius,(()=>`Radius must be less than or equal to ${this.maxAllowRadius}, current radius is ${t}`)),this.outputShape=e,this.elementsPerWorkgroup=this.workgroupSize[0]-2*this.maxAllowRadius,this.dispatchLayout={x:[3],y:[2],z:[0,1]},this.dispatch=Gt(this.dispatchLayout,this.outputShape,[this.elementsPerWorkgroup,this.workgroupSize[1],this.workgroupSize[2]]),this.shaderKey="lrn_shared"}getUserCode(){return`\n    var <workgroup>lrnSub: array<f32, ${this.workgroupSize[0]}>;\n    const elementsPerWorkgroup = ${this.elementsPerWorkgroup};\n    const maxAllowRadius = ${this.maxAllowRadius};\n\n    ${Nt()} {\n      let localDepth = i32(localId.x);\n      let workgroupDepth = i32(workgroupId.x) * elementsPerWorkgroup;\n      let xDepth = workgroupDepth + localDepth - maxAllowRadius;\n      let b = i32(globalId.z) / uniforms.xShape[1];\n      let r = i32(globalId.z) - b * uniforms.xShape[1];\n      let c = i32(globalId.y);\n      let d = workgroupDepth + localDepth;\n\n      var x = 0.0;\n      if (xDepth >= 0 && xDepth < uniforms.xShape[3]) {\n        x = getX(b, r, c, xDepth);\n      }\n      lrnSub[localDepth] = x;\n      workgroupBarrier();\n\n      if (localDepth < elementsPerWorkgroup && d < uniforms.outShape[3]) {\n        var sum = 0.0;\n        let index = localDepth + maxAllowRadius;\n        for (var i = -uniforms.radius; i <= uniforms.radius; i = i + 1) {\n          let z = lrnSub[index + i];\n          sum = sum + z * z;\n        }\n        ${Fa}\n\n        setOutputAtCoords(b, r, c, d, lrnSub[index] * powValue);\n      }\n    } `}}const za={kernelName:o.nb,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{depthRadius:s,bias:o,alpha:a,beta:u}=r;let l;l=s>16?new _a(i.shape):new Na(i.shape,s);const h=[{type:"int32",data:[s]},{type:"float32",data:[o]},{type:"float32",data:[a]},{type:"float32",data:[u]}];return n.runWebGPUProgram(l,[i],i.dtype,h)}},Ma={kernelName:o.zb,backendName:"webgpu",kernelFunc:jn({opType:en.MAX,cpuKernelImpl:Ur})},La={kernelName:o.yb,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{filterSize:s,strides:l,pad:a,dimRoundingMode:u}=r;return Fi(i,o.Oc.computePool2DInfo(i.shape,s,l,1,a,u),"max",n)}},th={kernelName:o.Bb,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,keepDims:o}=r;return gi(i,s,o,"min",n)}},Ba={kernelName:o.Cb,backendName:"webgpu",kernelFunc:jn({opType:en.MIN,cpuKernelImpl:Dr})};class Ua{constructor(e,t,n){this.uniforms="",this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1])),this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.xShape=e,t.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`})),this.offset="reflect"===n?0:1,this.shaderKey="mirrorPad_"+n}getUserCode(){const e=this.xShape.length,t=this.xShape.map(((e,t)=>`uniforms.pad${t}[0]`)).join(","),n=this.xShape.map(((t,n)=>`uniforms.pad${n}[0] + uniforms.xShape${e>1?`[${n}]`:""}`)).join(","),r=1===e?"start":"start[i]",i=1===e?"end":"end[i]",s=1===e?"outC":"outC[i]",o=Ft(e),a=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`\n      ${Nt("index")} {\n        if (index < uniforms.size) {\n          let start = ${o}(${t});\n          let end = ${o}(${n});\n          var outC = getCoordsFromIndex(index);\n          for (var i = 0; i < ${e}; i = i + 1) {\n            if (${s} < ${r}) {\n              ${s} = ${r} * 2 - ${s} - ${this.offset};\n            } else if(${s} >= ${i}) {\n              ${s} = (${i} - 1) * 2 - ${s} + ${this.offset};\n            }\n          }\n          let coords = outC - start;\n          setOutputAtIndex(index, getX(${a}));\n        }\n      }\n    `}}const Da={kernelName:o.Db,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{x:r}=e,{paddings:i,mode:s}=t,o=n,a=i.map((e=>({type:"int32",data:[e[0],e[1]]}))),u=new Ua(r.shape,i,s);return o.runWebGPUProgram(u,[r],r.dtype,a)}},ja={kernelName:o.Eb,backendName:"webgpu",kernelFunc:jn({opType:en.MOD})},Wa={kernelName:o.Gb,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r}=t;if(n.shouldExecuteOnCPU([r])){const e=n.tensorMap.get(r.dataId),[t,i]=Wr(e.values,r.shape,r.dtype);return n.makeTensorInfo(i,r.dtype,t)}const i=new Un(r.shape,hn.NEG);return n.runWebGPUProgram(i,[r],r.dtype)}},Va={kernelName:o.Hb,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:i,scores:s}=t,{maxOutputSize:l,iouThreshold:a,scoreThreshold:u}=r,h=n.readSync(i.dataId),c=n.readSync(s.dataId),{selectedIndices:d}=o.hd.nonMaxSuppressionV3Impl(h,c,l,a,u);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}},Ga={kernelName:o.Ib,backendName:"webgpu",kernelFunc:function(e){console.warn("tf.nonMaxSuppression() in webgpu locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:r}=e,{boxes:i,scores:s}=t,{maxOutputSize:l,iouThreshold:a,scoreThreshold:u,softNmsSigma:h}=r,c=n.readSync(i.dataId),d=n.readSync(s.dataId),f=l,p=a,m=u,y=h,{selectedIndices:g,selectedScores:x}=o.hd.nonMaxSuppressionV5Impl(c,d,f,p,m,y);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([x.length],"float32",new Float32Array(x))]}};class Ha{constructor(e,t){this.variableNames=["x"],this.uniforms="onValue : f32, offValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e,t],this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="onehot"}getUserCode(){return`\n      ${Nt("index")} {\n        if(index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          setOutputAtIndex(index, mix(uniforms.offValue, uniforms.onValue,\n                                      f32(i32(round(getX(coords.x))) == coords.y)));\n        }\n      }\n    `}}const Ka={kernelName:o.Kb,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{indices:s}=t,{dtype:r,depth:a,onValue:u,offValue:l}=i,h=o.Ed.sizeFromShape(s.shape),c=new Ha(h,a),d=Rn({inputs:{x:s},backend:n,attrs:{shape:[h]}}),p=[{type:"float32",data:[u]},{type:"float32",data:[l]}],f=n.runWebGPUProgram(c,[d],r,p);n.disposeData(d.dataId);const m=Rn({inputs:{x:f},backend:n,attrs:{shape:[...s.shape,a]}});return n.disposeData(f.dataId),m}};function Xa(e){const{inputs:t,backend:n}=e,{x:r}=t;if("complex64"===r.dtype){const e=Xi({inputs:{input:r},backend:n}),t=Xa({inputs:{x:e},backend:n}),i=no({inputs:{input:r},backend:n}),s=Xa({inputs:{x:i},backend:n}),o=Ln({inputs:{real:t,imag:s},backend:n});return n.disposeData(e.dataId),n.disposeData(t.dataId),n.disposeData(i.dataId),n.disposeData(s.dataId),o}return Tn({attrs:{shape:r.shape,dtype:r.dtype,value:"string"===r.dtype?"":0},backend:n})}const Ya={kernelName:o.Jc,backendName:"webgpu",kernelFunc:Xa},qa={kernelName:o.Lb,backendName:"webgpu",kernelFunc:function e(t){const{inputs:n,backend:r}=t,{x:i}=n;if("string"===i.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===i.dtype){const t=Xi({inputs:{input:i},backend:r}),n=e({inputs:{x:t},backend:r}),s=no({inputs:{input:i},backend:r}),o=Xa({inputs:{x:s},backend:r}),a=Ln({inputs:{real:n,imag:o},backend:r});return r.disposeData(t.dataId),r.disposeData(n.dataId),r.disposeData(s.dataId),r.disposeData(o.dataId),a}return Tn({attrs:{shape:i.shape,dtype:i.dtype,value:1},backend:r})}},Qa={kernelName:o.Mb,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{axis:s}=i;if(1===t.length)return Yo({inputs:{input:t[0]},backend:n,attrs:{dim:s}});const r=t[0].shape,a=t[0].dtype;t.forEach((e=>{o.Ed.assertShapesMatch(r,e.shape,"All tensors passed to stack must have matching shapes"),o.Ed.assert(a===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const u=[],l=oo({inputs:t.map((e=>{const t=Yo({inputs:{input:e},backend:n,attrs:{dim:s}});return u.push(t),t})),backend:n,attrs:{axis:s}});return u.forEach((e=>n.disposeData(e.dataId))),l}};class Za{constructor(e,t){this.variableNames=["x"],this.uniforms="constantValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1])),this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),t.map(((e,t)=>{this.uniforms+=` pad${t} : vec2<i32>,`})),this.xShape=e,this.shaderKey="pad"}getUserCode(){const e=this.xShape.length,t=Ft(e),n=this.xShape.map(((e,t)=>`uniforms.pad${t}[0]`)).join(","),r=this.xShape.map(((t,n)=>`uniforms.pad${n}[0] + uniforms.xShape${e>1?`[${n}]`:""}`)).join(","),i=e>1?`${t}(${n})`:""+n,s=e>1?`${t}(${r})`:""+r,o=e>1?"any(outC < start)":"outC < start",a=e>1?"any(outC >= end)":"outC >= end",u=e>1?["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,e):"coords";return`\n      ${Nt("index")} {\n        if (index < uniforms.size) {\n          let start = ${i};\n          let end = ${s};\n          let outC = getCoordsFromIndex(index);\n\n          if (${o} || ${a}) {\n            setOutputAtIndex(index, uniforms.constantValue);\n          } else {\n            let coords = outC - start;\n            setOutputAtIndex(index, getX(${u}));\n          }\n        }\n      }\n    `}}const Ja=e=>{const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{paddings:r,constantValue:a}=i;if(r.every((e=>o.Ed.arraysEqual(e,[0,0]))))return zn({inputs:{x:s},backend:n});if(0===o.Ed.sizeFromShape(s.shape))return Tn({backend:n,attrs:{shape:r.map(((e,t)=>e[0]+s.shape[t]+e[1])),value:a,dtype:s.dtype}});const u=[{type:"float32",data:[a]}];r.map((e=>u.push({type:"int32",data:[e[0],e[1]]})));const l=new Za(s.shape,r);return n.runWebGPUProgram(l,[s],s.dtype,u)},es={kernelName:o.Nb,backendName:"webgpu",kernelFunc:Ja},ts={kernelName:o.Ob,backendName:"webgpu",kernelFunc:jn({opType:en.POW})},ns={kernelName:o.Pb,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:r,alpha:i}=t,s=new Nn(en.PRELU,r.shape,i.shape);return n.runWebGPUProgram(s,[r,i],"float32")}},rs={kernelName:o.Qb,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{x:i}=t,{axis:s,keepDims:o}=r;return gi(i,s,o,"prod",n)}},is={kernelName:o.Rb,backendName:"webgpu",kernelFunc:e=>{const{backend:t,attrs:n}=e,{start:r,stop:i,step:s,dtype:o}=n,a=Hr(r,i,s,o);return t.makeTensorInfo([a.length],o,a)}},os=jn({opType:en.DIV}),as={kernelName:o.Tb,backendName:"webgpu",kernelFunc:os},ss={kernelName:o.Ub,backendName:"webgpu",kernelFunc:Dn({opType:hn.RECIPROCAL})},us={kernelName:o.Vb,backendName:"webgpu",kernelFunc:Dn({opType:hn.RELU})},ls={kernelName:o.Wb,backendName:"webgpu",kernelFunc:Dn({opType:hn.RELU6})};class hs{constructor(e,t,n){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, halfPixelCenters : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="resizeBilinear"}getUserCode(){return`\n      ${Nt("index")} {\n        if (index < uniforms.size) {\n        let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC =\n            (vec2<f32>(rc) + vec2<f32>(uniforms.halfPixelCenters)) *\n            effectiveInputOverOutputRatioRC - vec2<f32>(uniforms.halfPixelCenters);\n\n          // Compute the four integer indices.\n          let sourceFloorRC = vec2<i32>(sourceFracIndexRC);\n          let sourceCeilRC = vec2<i32>(\n            min(vec2<f32>(uniforms.xShape.yz) - vec2<f32>(1.0), ceil(sourceFracIndexRC)));\n\n          let topLeft = getX(b, sourceFloorRC.x, sourceFloorRC.y, d);\n          let bottomLeft = getX(b, sourceCeilRC.x, sourceFloorRC.y, d);\n          let topRight = getX(b, sourceFloorRC.x, sourceCeilRC.y, d);\n          let bottomRight = getX(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n          let fracRC = sourceFracIndexRC - vec2<f32>(sourceFloorRC);\n\n          let top = topLeft + (topRight - topLeft) * fracRC.y;\n          let bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n          let newValue = top + (bottom - top) * fracRC.x;\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}const cs={kernelName:o.Yb,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:i}=t,{alignCorners:s,size:o,halfPixelCenters:a}=r,[u,l]=o,h=[{type:"float32",data:[s&&u>1?1:0,s&&l>1?1:0]},{type:"float32",data:[a?.5:0]}],c=new hs(i.shape,u,l);return n.runWebGPUProgram(c,[i],"float32",h)}};class ds{constructor(e,t,n,r){this.variableNames=["x"],this.uniforms="adjustHeightWidth : vec2<f32>, roundBase : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=[e[0],t,n,e[3]],this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.halfPixelCenters=r,this.shaderKey="resizeNearest_"+r}getUserCode(){let e;return e=this.halfPixelCenters?"max((vec2<f32>(rc) + vec2<f32>(0.5)) * effectiveInputOverOutputRatioRC, vec2<f32>(0.0))":"vec2<f32>(rc) * effectiveInputOverOutputRatioRC",`\n      ${Nt("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let b = coords[0];\n          let d = coords[3];\n          let rc = coords.yz;\n\n          let effectiveInSize = vec2<f32>(\n            f32(uniforms.xShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.xShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveOutSize = vec2<f32>(\n            f32(uniforms.outShape.y) - uniforms.adjustHeightWidth[0],\n            f32(uniforms.outShape.z) - uniforms.adjustHeightWidth[1]);\n\n          let effectiveInputOverOutputRatioRC =\n              effectiveInSize / effectiveOutSize;\n\n          // Fractional source index\n          let sourceFracIndexRC = ${e};\n\n          // Compute the coordinators of nearest neighbor point.\n          let inputShapeRC = vec2<f32>(f32(uniforms.xShape.y), f32(uniforms.xShape.z));\n          let sourceNearestRC = vec2<i32>(\n            min(inputShapeRC - 1.0, floor(sourceFracIndexRC + uniforms.roundBase)));\n          let newValue = getX(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n          setOutputAtIndex(index, newValue);\n        }\n      }\n    `}}const ps={kernelName:o.Zb,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{images:i}=t,{alignCorners:s,halfPixelCenters:o,size:a}=r,[u,l]=a,h=[{type:"float32",data:[s&&u>1?1:0,s&&l>1?1:0]},{type:"float32",data:[s?.5:0]}],c=new ds(i.shape,u,l,o);return n.runWebGPUProgram(c,[i],i.dtype,h)}};class fs{constructor(e){this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms=" axis : vec4<i32>,",this.shaderKey="reverse"}getUserCode(){return`\n      \n      // Using uniform variables as judging conditions, so the function has\n      // coherent execution within all threads.\n      fn getReverseCoords(coords : vec4<i32>) -> vec4<i32> {\n        var reverseCoords = coords;\n        if (uniforms.axis[0] == 1) {\n          reverseCoords[0] = uniforms.xShape[0] - coords[0] - 1;\n        }\n        if (uniforms.axis[1] == 1) {\n          reverseCoords[1] = uniforms.xShape[1] - coords[1] - 1;\n        }\n        if (uniforms.axis[2] == 1) {\n          reverseCoords[2] = uniforms.xShape[2] - coords[2] - 1;\n        }\n        if (uniforms.axis[3] == 1) {\n          reverseCoords[3] = uniforms.xShape[3] - coords[3] - 1;\n        }\n\n        return reverseCoords;\n      }\n    \n      ${Nt("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let reverseCoords = getReverseCoords(coords);\n          setOutputAtIndex(index, getX(reverseCoords[0],\n              reverseCoords[1], reverseCoords[2], reverseCoords[3]));\n        }\n      }\n    `}}const ms={kernelName:o.ac,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{dims:r}=i,a=s.shape.length;if(0===a)return zn({inputs:{x:s},backend:n});const u=s.shape,l=[1,1,1,1];u.forEach(((e,t)=>{l[t+4-a]=e}));const h=o.Ed.parseAxisParam(r,s.shape),c=[0,0,0,0];h.forEach((e=>{c[e+4-a]=1}));const d=[{type:"int32",data:c}],p=Rn({inputs:{x:s},backend:n,attrs:{shape:l}}),f=new fs(l),m=n.runWebGPUProgram(f,[p],p.dtype,d);n.disposeData(p.dataId);const g=Rn({inputs:{x:m},backend:n,attrs:{shape:u}});return n.disposeData(m.dataId),g}};class gs{constructor(e,t){this.outputShape=[],this.variableNames=["x"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="centerX : f32, centerY : f32, sinRadians : f32,\n          cosRadians : f32,",this.shaderKey="rotate",this.outputShape=e,"number"==typeof t?(this.uniforms+=" fillValue : f32,",this.fillSnippet="var outputValue = uniforms.fillValue;",this.shaderKey+="_float"):(this.uniforms+=" fillValue : vec3<f32>,",this.fillSnippet="var outputValue = uniforms.fillValue[coords[3]];",this.shaderKey+="_vec3")}getUserCode(){return`\n        ${Nt("index")} {\n          if (index < uniforms.size) {\n            let coords = getCoordsFromIndex(index);\n            let coordXFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.cosRadians - (f32(coords[1]) - uniforms.centerY) *\n                uniforms.sinRadians;\n            let coordYFloat = (f32(coords[2]) - uniforms.centerX) *\n                uniforms.sinRadians + (f32(coords[1]) - uniforms.centerY) *\n                uniforms.cosRadians;\n            let coordX = i32(round(coordXFloat + uniforms.centerX));\n            let coordY = i32(round(coordYFloat + uniforms.centerY));\n            ${this.fillSnippet}\n            if(coordX >= 0 && coordX < uniforms.xShape[2] && coordY >= 0 &&\n                coordY < uniforms.xShape[1]) {\n              outputValue = getX(coords[0], coordY, coordX, coords[3]);\n            }\n            setOutputAtIndex(index, outputValue);\n          }\n        }\n      `}}const bs={kernelName:o.bc,backendName:"webgpu",kernelFunc:({inputs:e,attrs:t,backend:n})=>{const{image:r}=e,{radians:i,fillValue:s,center:l}=t,a=n,u=new gs(r.shape,s),[h,c]=o.Oc.getImageCenter(l,r.shape[1],r.shape[2]),d=[{type:"float32",data:[h]},{type:"float32",data:[c]},{type:"float32",data:[Math.sin(i)]},{type:"float32",data:[Math.cos(i)]}];return"number"==typeof s?d.push({type:"float32",data:[Number.parseFloat(s.toFixed(2))]}):d.push({type:"float32",data:s}),a.runWebGPUProgram(u,[r],r.dtype,d)}},ys={kernelName:o.cc,backendName:"webgpu",kernelFunc:Dn({opType:hn.ROUND})},xs={kernelName:o.dc,backendName:"webgpu",kernelFunc:Dn({opType:hn.RSQRT,cpuKernelImpl:Kr})};class vs{constructor(e,t,n,r,i,s,o,a=!0){this.variableNames=["updates","indices"],this.workgroupSize=[64,1,1],this.atomic=!0,this.outputShape=s,this.type=o,this.sumDupeIndices=a,this.dispatchLayout=Xt(e),this.dispatch=Gt(this.dispatchLayout,e,this.workgroupSize),this.sliceDimGreaterThanOne=t>1,this.shaderKey=`scatter_${n}_${r}_${this.sliceDimGreaterThanOne}_${o}_${a}`;const u=Ft(i.length);this.uniforms=`sliceDim : i32, strides: ${u}, updatesSize: i32,`,this.updatesRank=r,this.indicesRank=n}getUserCode(){let e="";1===this.indicesRank?e="coords[0]":2===this.indicesRank&&(e="coords[0], j");const t=`getIndices(${e})`,n=this.sliceDimGreaterThanOne?"uniforms.strides[j]":"uniforms.strides";let r="",i="";1===this.dispatchLayout.x.length?(r="flattenedIndex",i="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> i32 {\n        return index;\n      }\n      "):2===this.dispatchLayout.x.length&&(r="vec2<i32>(flattenedIndex, coords[1])",i="\n      fn getUpdatesCoordsFromFlatIndex(index : i32) -> vec2<i32> {\n        // N.B. |updates| could be a scalar tensor, conceptually representing a\n        // 2D tensor with all values equal to that. By design, its size must be\n        // the same as |outShape[1]| in one dimension, and |indicesShape[0]|\n        // gives the other.\n        let sliceSize = uniforms.outShape[1];\n        let d0 = index / sliceSize;\n        let d1 = index - d0 * sliceSize;\n        return vec2<i32>(d0, d1);\n      }\n      ");const s=`getUpdates(${Array.from({length:this.updatesRank},((e,t)=>`coords[${t}]`)).join(", ")})`;return`\n    ${i}\n      ${Nt("index")} {\n        if (index < uniforms.updatesSize) {\n          let coords = getUpdatesCoordsFromFlatIndex(index);\n          var flattenedIndex = 0;\n          for (var j = 0; j < uniforms.sliceDim; j = j + 1) {\n            let indexInside = i32(round(${t}));\n            flattenedIndex = flattenedIndex + indexInside * ${n};\n          }\n          let updateValue =\n              ${jt(this.type,!1)}(${s});\n          let flatIndex = getOutputIndexFromCoords(${r});\n\n          ${this.sumDupeIndices?$t("&result[flatIndex]","updateValue",this.type):"atomicStore(&result[flatIndex], bitcast<i32>(updateValue));"}\n        }\n      }`}}const ws={kernelName:o.ec,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{indices:s,updates:r}=t,{shape:a}=i,{sliceRank:u,numUpdates:l,sliceSize:h,strides:c,outputSize:d}=o.Oc.calculateShapes(r,s,a),p=[d/h,h];if(0===d)return n.makeTensorInfo(a,s.dtype);const f=Rn({inputs:{x:s},backend:n,attrs:{shape:[l,u]}}),m=Rn({inputs:{x:r},backend:n,attrs:{shape:[l,h]}}),g=m.dtype,y=Tn({backend:n,attrs:{shape:p,value:0,dtype:g}}),x=[{type:"int32",data:[u]},{type:"int32",data:c},{type:"int32",data:[o.Ed.sizeFromShape(m.shape)]}],b=new vs(m.shape,u,f.shape.length,m.shape.length,c,p,g),v=n.runWebGPUProgram(b,[m,f],g,x,y),w=Rn({inputs:{x:v},backend:n,attrs:{shape:a}});return n.disposeData(f.dataId),n.disposeData(m.dataId),n.disposeData(v.dataId),w}};class ks{constructor(e,t){this.outputShape=[],this.variableNames=["sortedSequence","values"],this.uniforms="numInputs : i32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.side=t,this.shaderKey="search_sorted_"+t}getUserCode(){return`\n      fn findBound(batch: i32, value: f32) -> i32 {\n        var left = i32(0);\n        var right = uniforms.numInputs;\n        while (left < right) {\n          var mid = (left + right) / 2;\n          if (getSortedSequence(batch, mid) ${"left"===this.side?"<":"<="} value) {\n            left = mid + 1;\n          } else {\n            right = mid;\n          }\n        }\n        return right;\n      }\n\n      ${Nt("index")} {\n        if (index < uniforms.size) {\n          let coords = getCoordsFromIndex(index);\n          let value = getValuesByOutputIndex(index);\n          setOutputAtIndexI32(index, findBound(coords[0], value));\n        }\n      }\n    `}}const Ss={kernelName:o.fc,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{sortedSequence:i,values:s}=t,{side:o}=r,a=new ks([s.shape[0],s.shape[1]],o),u=[{type:"int32",data:[i.shape[1]]}];return n.runWebGPUProgram(a,[i,s],"int32",u)}};class Is{constructor(e,t,n){this.variableNames=["c","a","b"],this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=t,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.cRank=e,this.rank=n,this.shaderKey="select"}getUserCode(){let e,t;if(this.rank>4)throw Error(`Where for rank ${this.rank} is not yet supported`);if(1===this.rank)t="resRC",e="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[],i=[];for(let e=0;e<this.outputShape.length;e++)i.push(""+n[e]),e<this.cRank&&r.push(""+n[e]);e=r.join(),t=i.join()}return`\n      ${Nt("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          let cVal = getC(${e});\n          if (cVal >= 1.0) {\n            setOutputAtIndex(index, getA(${t}));\n          } else {\n            setOutputAtIndex(index, getB(${t}));\n          }\n        }\n      }\n    `}}const Cs={kernelName:o.gc,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:r,t:i,e:s}=t,l=new Is(r.shape.length,i.shape,i.shape.length);return n.runWebGPUProgram(l,[r,i,s],Object(o.Dd)(i.dtype,s.dtype))}},Os={kernelName:o.hc,backendName:"webgpu",kernelFunc:Dn({opType:hn.SELU})},As={kernelName:o.ic,backendName:"webgpu",kernelFunc:Dn({opType:hn.SIGMOID})},Ts={kernelName:o.jc,backendName:"webgpu",kernelFunc:Dn({opType:hn.SIGN})},Es={kernelName:o.kc,backendName:"webgpu",kernelFunc:Dn({opType:hn.SIN})},Rs={kernelName:o.lc,backendName:"webgpu",kernelFunc:Dn({opType:hn.SINH})},Ps=jn({opType:en.SUB,cpuKernelImpl:Jr,supportsComplex:!0}),$s={kernelName:o.yc,backendName:"webgpu",kernelFunc:Ps},Fs={kernelName:o.nc,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{logits:s}=t,{dim:r}=i,a=o.Ed.parseAxisParam([r],s.shape),u=Ei({inputs:{x:s},backend:n,attrs:{reductionIndices:a,keepDims:!1}}),l=o.Oc.expandShapeToKeepDim(u.shape,a),h=Rn({inputs:{x:u},backend:n,attrs:{shape:l}}),c=Ps({inputs:{a:s,b:h},backend:n}),d=ul({inputs:{x:c},backend:n}),p=Wo({inputs:{x:d},backend:n,attrs:{axis:a,keepDims:!1}}),f=Rn({inputs:{x:p},backend:n,attrs:{shape:l}}),m=os({inputs:{a:d,b:f},backend:n});return n.disposeData(u.dataId),n.disposeData(h.dataId),n.disposeData(c.dataId),n.disposeData(d.dataId),n.disposeData(p.dataId),n.disposeData(f.dataId),m}},_s={kernelName:o.oc,backendName:"webgpu",kernelFunc:Dn({opType:hn.SOFTPLUS})},Ns={kernelName:o.pc,backendName:"webgpu",kernelFunc:e=>{const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{blockShape:r,paddings:a}=i;o.Ed.assert(s.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGPU backend not implemented yet"));const u=r.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...a);for(let e=1+r.length;e<s.shape.length;++e)l.push([0,0]);const h=[],c=Ja({inputs:{x:s},backend:n,attrs:{paddings:l,constantValue:0}}),d=o.Oc.getReshaped(c.shape,r,u,!1),p=o.Oc.getPermuted(d.length,r.length,!1),f=o.Oc.getReshapedPermuted(c.shape,r,u,!1),m=Rn({inputs:{x:c},backend:n,attrs:{shape:d}}),g=pi({inputs:{x:m},backend:n,attrs:{perm:p}}),y=Rn({inputs:{x:g},backend:n,attrs:{shape:f}});return h.push(c),h.push(m),h.push(g),h.forEach((e=>n.disposeData(e.dataId))),y}};class zs{constructor(e,t){this.variableNames=["A"],this.workgroupSize=[64,1,1],this.size=!0;const n=new Array(e.length);for(let r=0;r<n.length;r++)n[r]=e[r]*t[r];this.outputShape=n,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.rank=this.outputShape.length,this.shaderKey="tile"}getUserCode(){const e=function(e,t=""){if(e>=5)throw Error(`Tile for rank ${e} is not yet supported`);if(1===e)return`(resRC % ${t}aShape)`;const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let i=0;i<e;i++)r.push(`(${n[i]} % ${t}aShape[${i}])`);return r.join()}(this.rank,"uniforms.");return`\n      ${Nt("index")} {\n        if (index < uniforms.size) {\n          let resRC = getCoordsFromIndex(index);\n          setOutputAtIndex(index, getA(${e}));\n        }\n      }\n    `}}function Ms(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{reps:r}=i;if(n.shouldExecuteOnCPU([s])||"string"===s.dtype||s.shape.length>=5){const e=n.readSync(s.dataId),t="string"===s.dtype?e.map((e=>o.Ed.decodeString(e))):e,i=Object(o.Sc)(s.shape,s.dtype,t),a=ei(i,r);return n.makeTensorInfo(a.shape,a.dtype,a.values)}const a=new zs(s.shape,r);return n.runWebGPUProgram(a,[s],s.dtype)}const Ls={kernelName:o.Ec,backendName:"webgpu",kernelFunc:Ms},Bs={kernelName:o.qc,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{sparseIndices:s,sparseValues:r,defaultValue:a}=t,{outputShape:u}=i,{sliceRank:l,numUpdates:h,sliceSize:c,strides:d,outputSize:p}=o.Oc.calculateShapes(r,s,u);if("string"===r.dtype){const e=n.bufferSync(s),t=n.bufferSync(r),i=o.Ed.decodeString(n.readSync(a.dataId)[0]),f=Xr(e,t,u,p,c,h,l,d,i,!1);return n.makeTensorInfo(u,f.dtype,f.values)}const f=[p/c,c],m=Rn({inputs:{x:s},backend:n,attrs:{shape:[h,l]}}),g=r.shape.length?Rn({inputs:{x:r},backend:n,attrs:{shape:[h,c]}}):zn({inputs:{x:r},backend:n}),y=g.dtype,x=n.makeTensorInfo([],y,o.Ed.makeZerosTypedArray(1,y)),b=Rn({inputs:{x:a},backend:n,attrs:{shape:Array(f.length).fill(1)}}),v=Ms({inputs:{x:b},backend:n,attrs:{reps:f}}),w=[{type:"int32",data:[l]},{type:"int32",data:d},{type:"int32",data:[o.Ed.sizeFromShape([h,c])]}];switch(h){case 0:break;case 1:{const e=new vs([h,c],l,m.shape.length,g.shape.length,d,f,y,!1);n.runWebGPUProgram(e,[g,m],y,w,v)}break;default:{const e=new vs([h,c],l,m.shape.length,x.shape.length,d,f,y,!1);n.runWebGPUProgram(e,[x,m],y,w,v)}{const e=new vs([h,c],l,m.shape.length,g.shape.length,d,f,y);n.runWebGPUProgram(e,[g,m],y,w,v)}}const k=Rn({inputs:{x:v},backend:n,attrs:{shape:u}});return n.disposeData(m.dataId),n.disposeData(g.dataId),n.disposeData(b.dataId),n.disposeData(x.dataId),n.disposeData(v.dataId),k}},Us={kernelName:o.rc,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{numOrSizeSplits:r,axis:a}=i,u=o.Ed.parseAxisParam(a,s.shape)[0],l=o.Oc.prepareSplitSize(s,r,u),h=s.shape.length,c=new Array(h).fill(0),d=s.shape.slice();return l.map((e=>{const t=[...d];t[u]=e;const r=Ui({inputs:{x:s},backend:n,attrs:{begin:c,size:t}});return c[u]+=e,r}))}},Ds={kernelName:o.sc,backendName:"webgpu",kernelFunc:Dn({opType:hn.SQRT})},js={kernelName:o.tc,backendName:"webgpu",kernelFunc:({inputs:e,backend:t})=>{const{x:n}=e,r=t,i=new Un(n.shape,hn.SQUARE);return r.runWebGPUProgram(i,[n],n.dtype)}},Ws={kernelName:o.uc,backendName:"webgpu",kernelFunc:jn({opType:en.SQUARED_DIFFERENCE})},Vs={kernelName:o.vc,backendName:"webgpu",kernelFunc:function({inputs:e,attrs:t,backend:n}){const{x:r}=e,i=new Un(r.shape,hn.STEP,"stepAlpha : f32,"),s=[{type:"float32",data:[t.alpha]}];return n.runWebGPUProgram(i,[r],r.dtype,s)}};class Gs{constructor(e){this.variableNames=["x"],this.workPerThread=1,this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize,[this.workPerThread,1,1]);const t=Ft(this.outputShape.length);this.uniforms=`begin : ${t},  strides : ${t}, `,this.shaderKey="stridedSlice"}getUserCode(){let e="";if(1===this.outputShape.length)e="coords * uniforms.strides + uniforms.begin";else{let t=0;e=this.outputShape.map(((e,n)=>(t++,1===this.outputShape.length?`coords * uniforms.strides[${n}] + uniforms.begin[${n}]`:`coords[${t-1}] * uniforms.strides[${n}] + uniforms.begin[${n}]`))).join(",")}return`\n       ${Nt("index")} {\n         if (index < uniforms.size) {\n           let coords = getCoordsFromIndex(index);\n           setOutputAtIndex(index, getX(${e}));\n         }\n       }\n     `}}const Hs={kernelName:o.wc,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{begin:r,end:a,strides:u,beginMask:l,endMask:h,ellipsisMask:c,newAxisMask:d,shrinkAxisMask:p}=i,{finalShapeSparse:f,finalShape:m,isIdentity:g,sliceDim0:y,isSimpleSlice:x,begin:b,end:v,strides:w}=o.sd.sliceInfo(s.shape,r,a,u,l,h,c,d,p);let k;if(g)k=Rn({inputs:{x:s},backend:n,attrs:{shape:m}});else if(y||x){o.Ed.assert(s.shape.length>=1,(()=>"Input must have rank at least 1, got: "+s.shape.length));const e=o.sd.computeOutShape(b,v,w),t=Ui({inputs:{x:s},backend:n,attrs:{begin:b,size:e}});k=Rn({inputs:{x:t},backend:n,attrs:{shape:m}}),n.disposeData(t.dataId)}else if(n.shouldExecuteOnCPU([s])){const e=n.readSync(s.dataId),t=Object(o.Sc)(s.shape,s.dtype,e),r=Qr(f,t,w,b);k=n.makeTensorInfo(m,s.dtype,r.values)}else{const e=new Gs(f),t=[{type:"int32",data:b},{type:"int32",data:w}],r=n.runWebGPUProgram(e,[s],s.dtype,t);k=Rn({inputs:{x:r},backend:n,attrs:{shape:m}}),n.disposeData(r.dataId)}return k}},Ks={kernelName:o.xc,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{separator:i,nGramWidths:s,leftPad:o,rightPad:a,padWidth:u,preserveShortSequences:l}=r,{data:h,dataSplits:c}=t,d=n.readSync(h.dataId),p=n.readSync(c.dataId),[f,m]=Zr(d,p,i,s,o,a,u,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(c.shape,"int32",m)]}},Xs={kernelName:o.Ac,backendName:"webgpu",kernelFunc:Dn({opType:hn.TAN})},Ys={kernelName:o.Bc,backendName:"webgpu",kernelFunc:Dn({opType:hn.TANH})};class qs{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, negativeInf : f32,\n        dir : i32, inc : i32,",this.shaderKey="swap"}getUserCode(){return`\n        ${Nt("index")} {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // We compare elements pair-wise within a group of size 2 * inc.\n            // The comparing rule for each group alternates between ascending\n            // and descending. Within each group, we compare each pair at\n            // positions i and i+inc. To decide whether an element at position i\n            // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n            // inc, it is in the first half of the group, we denote it as x0,\n            // otherwise we denote it as x1.\n            // For example, as shown in the Bitonic top K paper referenced\n            // above, Figure5(a) shows that element[1] is in the second half of\n            // the group when group size is 2, but it is in the first half of\n            // the group when group size is 4.\n            let isFirstInPair = elemIdx % (2 * uniforms.inc) < uniforms.inc;\n            var i = 0;\n            if (isFirstInPair) {\n              i = elemIdx;\n            } else {\n              i = elemIdx - uniforms.inc;\n            }\n\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.inc;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.inc));\n            }\n\n            var x0 = f32(0.0);\n            var x1 = f32(0.0);\n            if (i0 < uniforms.inputSize) {\n              x0 = getX(batch, i0);\n            } else {\n              x0 = uniforms.negativeInf;\n            }\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = uniforms.negativeInf;\n            }\n\n            let reverse = elemIdx % (2 * uniforms.dir) >= uniforms.dir;\n            let isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n            if (reverse == isGreater) {\n              // Elements in opposite order of direction\n              let iTemp = i0;\n              i0 = i1;\n              i1 = iTemp;\n            }\n            if (isFirstInPair) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}class Qs{constructor(e){this.variableNames=["x","indices"],this.workgroupSize=[256,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.uniforms="inputSize : i32, firstPass : i32, k : i32,",this.shaderKey="merge"}getUserCode(){return`\n        ${Nt("index")} {\n          if (index < uniforms.size) {\n            let outC = getCoordsFromIndex(index);\n            let batch = outC[0];\n            let elemIdx = outC[1];\n            // The output size is half of the previous size.\n            // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _\n            // (k=4), we only need to output the indices at positions |, the\n            // indices at positions _ can be thrown away, see Figure5(b) After\n            // Phase 2 (Merge phase) in the Bitonic Top K paper referenced\n            // above.\n            // For example, the paper shows we only need to output the orange\n            // bars. The output sequence should look like this | | | | | | | |.\n            // Because the sequence is halved, to map the output index back to\n            // the previous sequence to find the corresponding value, we need\n            // to double the index. When we double the index, we basically\n            // interpolate a position, so 2i looks like\n            // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k\n            // position of each 2k positions by - elemIdx % k. E.g. for output\n            // at index 4,5,6,7, we want to get the corresponding element at\n            // original index 8,9,10,11, for output at index 8,9,10,11,\n            // we want to get the corresponding element at original index\n            // 16,17,18,19, so on and so forth.\n\n            var i = 0;\n            if (elemIdx < uniforms.k) {\n              i = elemIdx;\n            } else {\n              i = elemIdx * 2 - elemIdx % uniforms.k;\n            }\n            var i0 = 0;\n            if (uniforms.firstPass == 1) {\n              i0 = i;\n            } else {\n              i0 = i32(getIndices(batch, i));\n            }\n            var i1 = 0;\n            if (uniforms.firstPass == 1) {\n              i1 = i + uniforms.k;\n            } else {\n              i1 = i32(getIndices(batch, i + uniforms.k));\n            }\n\n            let x0 = getX(batch, i0);\n            var x1 = f32(0.0);\n            if (i1 < uniforms.inputSize) {\n              x1 = getX(batch, i1);\n            } else {\n              x1 = x0;\n            }\n\n            if (x0 >= x1) {\n              setOutputAtIndex(index, f32(i0));\n            } else {\n              setOutputAtIndex(index, f32(i1));\n            }\n          }\n        }\n      `}}function Zs(e,t){null!==t&&e.disposeData(t.dataId)}function Js(e){let t=1;for(;t<e;)t*=2;return t}const eu={kernelName:o.Fc,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:i}=e,{x:s}=t,{k:r,sorted:a}=i,u=s.shape,l=u[u.length-1];if(n.shouldExecuteOnCPU([s])){const e=n.readSync(s.dataId),[t,o]=ti(e,u,s.dtype,r,a);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(o.shape,o.dtype,o.values)]}if(0===r)return u[u.length-1]=0,[n.makeTensorInfo(u,s.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===l)return[s,Tn({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const h=o.Ed.sizeFromShape(u)/l,c=Rn({inputs:{x:s},attrs:{shape:[h,l]},backend:n}),d=Js(r),p=Js(l);let f=null;const m=()=>null===f?[c,c]:[c,f],g=(e,t,r)=>{const i=m(),s=new qs(r),o=[{type:"int32",data:[l]},{type:"int32",data:[null===f?1:0]},{type:"float32",data:[Number.NEGATIVE_INFINITY]},{type:"int32",data:[e]},{type:"int32",data:[t]}],a=f;f=n.runWebGPUProgram(s,i,"int32",o),Zs(n,a)};for(let e=1;e<d;e*=2){const t=2*e;for(let n=e;n>=1;n/=2)g(t,n,[h,p])}for(let e=p;e>d;e/=2){const t=m(),r=new Qs([h,e/2]),i=[{type:"int32",data:[l]},{type:"int32",data:[null===f?1:0]},{type:"int32",data:[d]}],s=f;f=n.runWebGPUProgram(r,t,"int32",i),Zs(n,s);const o=d/2,a=2*o;for(let e=o;e>=1;e/=2)g(a,e,f.shape)}let y=f;f=Ui({inputs:{x:f},backend:n,attrs:{begin:0,size:[h,r]}}),Zs(n,y);let x=ma({inputs:{x:c,indices:f},backend:n,attrs:{axis:1,batchDims:1}});Zs(n,c);const b=u.slice(0,-1);b.push(r),y=f,f=Rn({inputs:{x:f},attrs:{shape:b},backend:n}),Zs(n,y);const v=x;return x=Rn({inputs:{x:x},attrs:{shape:b},backend:n}),Zs(n,v),[x,f]}};class tu{constructor(e){this.variableNames=["Image","Transforms"],this.uniforms="interpolationModeId : i32, fillModeId : i32, fillValue : f32,",this.workgroupSize=[64,1,1],this.size=!0,this.outputShape=e,this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="transform"}getUserCode(){return`\n          fn mapCoord(outCoord : f32, len : f32) -> f32{\n            var inCoord = outCoord;\n            if(uniforms.fillModeId == 2) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  if (inCoord < sz2) {\n                    inCoord = sz2 * f32(i32(f32(-inCoord / sz2))) +\n                    inCoord;\n                  }\n                  if (inCoord < -len) {\n                    inCoord = inCoord + sz2;\n                  } else {\n                    inCoord = -inCoord - 1.0;\n                  }\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz2 = 2.0 * len;\n                  inCoord = inCoord - sz2 * f32(i32(f32(inCoord / sz2)));\n                  if (inCoord >= len) {\n                    inCoord = sz2 - inCoord - 1.0;\n                  }\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 3) {\n              if (inCoord < 0.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord + len * (f32(i32(f32(-inCoord / sz))) + 1.0);\n                }\n              } else if (inCoord > len - 1.0) {\n                if (len <= 1.0) {\n                  inCoord = 0.0;\n                } else {\n                  let sz = len - 1.0;\n                  inCoord = inCoord - len * f32(i32(f32(inCoord / sz)));\n                }\n              }\n              return clamp(inCoord, 0.0, len - 1.0);\n            } else if (uniforms.fillModeId == 4) {\n              return clamp(outCoord, 0.0, len - 1.0);\n            }\n            return outCoord;\n          }\n          fn readWithFillValue(batch : i32, coordY : i32, coordX : i32,\n            channel : i32) -> f32 {\n            var outputValue : f32;\n            if (0 <= coordY && coordY < uniforms.imageShape[1] && 0 <= coordX && coordX < uniforms.imageShape[2]) {\n                outputValue = getImage(batch, coordY, coordX, channel);\n            } else {\n              outputValue = uniforms.fillValue;\n            }\n            return outputValue;\n          }\n\n          ${Nt("index")} {\n            if (index < uniforms.size) {\n              let coords = getCoordsFromIndex(index);\n              var outputValue : f32;\n              let batch = coords[0];\n              let x = coords[2];\n              let y = coords[1];\n              let channel = coords[3];\n              let xf = f32(x);\n              let yf = f32(y);\n              let a1 = getTransforms(batch, 0);\n              let a2 = getTransforms(batch, 1);\n              let a3 = getTransforms(batch, 2);\n              let b1 = getTransforms(batch, 3);\n              let b2 = getTransforms(batch, 4);\n              let b3 = getTransforms(batch, 5);\n              let c1 = getTransforms(batch, 6);\n              let c2 = getTransforms(batch, 7);\n              let projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = uniforms.fillValue;\n              } else {\n                let inX = (a1 * xf + a2 * yf + a3) / projection;\n                let inY = (b1 * xf + b2 * yf + b3) / projection;\n                let mapX = mapCoord(inX, f32(uniforms.imageShape[2]));\n                let mapY = mapCoord(inY, f32(uniforms.imageShape[1]));\n\n                if (uniforms.interpolationModeId == 1) {\n                  let coordY = i32(round(mapY));\n                  let coordX = i32(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  let yFloor = floor(mapY);\n                  let xFloor = floor(mapX);\n                  let yCeil = yFloor + 1.0;\n                  let xCeil = xFloor + 1.0;\n                  let valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yFloor), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yFloor), i32(xCeil), channel);\n                  let valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, i32(yCeil), i32(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, i32(yCeil), i32(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutputAtIndex(index, outputValue);\n            }\n          }\n        `}}const nu=[Fn,ii,oi,ai,si,hi,bi,yi,vi,wi,ki,Si,Ii,Ci,Oi,_i,zi,Mi,ji,Gi,qi,Qi,eo,Bn,ao,po,go,yo,xo,vo,ko,To,Eo,Ro,$o,zo,Lo,Uo,Go,Ho,ol,Ko,Xo,qo,dl,Jo,En,ta,oa,na,ra,la,ha,ca,pa,ga,ba,ya,Mn,xa,ro,va,wa,ka,Sa,Ia,Ca,Aa,Ea,Ta,Ra,Pa,$a,za,Ri,Ma,La,$i,th,Ba,Da,ja,jo,Wa,Va,Ga,Ki,Ka,qa,Qa,es,ts,ns,rs,is,Yi,as,ss,us,ls,Pn,cs,ps,ms,bs,ys,xs,ws,Ss,Cs,Os,As,Ts,Es,Rs,Di,Vs,Hs,Ks,Fs,_s,Ns,Bs,Us,Ds,js,Ws,$s,Vo,Xs,Ys,Ls,eu,{kernelName:o.Gc,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{image:i,transforms:s}=t,{interpolation:o,fillMode:a,fillValue:u,outputShape:l}=r,[h,c,d,p]=i.shape,[f,m]=null!=l?l:[c,d],g=new tu([h,f,m,p]),y="nearest"===o?1:2;let x;switch(a){case"constant":default:x=1;break;case"reflect":x=2;break;case"wrap":x=3;break;case"nearest":x=4}const b=[{type:"int32",data:[y]},{type:"int32",data:[x]},{type:"float32",data:[u]}];return n.runWebGPUProgram(g,[i,s],"float32",b)}},fi,{kernelName:o.Ic,backendName:"webgpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:r}=e,{value:i}=t;let{axis:s}=r;s<0&&(s+=i.shape.length);const o=i,a=o.shape.length,u=i.shape[s],l=new Array(a-1);let h=0;for(let e=0;e<a;e++)e!==s&&(l[h++]=o.shape[e]);const c=[],d=new Array(a).fill(0),p=o.shape.slice();p[s]=1;const f=new Array(u);for(let e=0;e<f.length;e++){d[s]=e;const t=Ui({inputs:{x:o},backend:n,attrs:{begin:d,size:p}}),r=Rn({inputs:{x:t},backend:n,attrs:{shape:l}});f[e]=r,c.push(t)}return c.forEach((e=>n.disposeData(e.dataId))),f}},Ya];for(const e of nu)Object(o.nd)(e);function ru(){for(var e,t=[],n=0;n<arguments.length;n++)t[n]=arguments[n];switch(t.length){case 0:e="fn main() ";break;case 1:e="fn main(".concat(t[0]," : i32)");break;default:throw Error("Unreachable")}return e}var iu=function(){function e(e){this.variableNames=["A","B"],this.size=!0,this.workgroupSize=[32,1,1],this.outputShape=[e[0],1],this.dispatchLayout=Xt(this.outputShape),this.dispatch=Gt(this.dispatchLayout,this.outputShape,this.workgroupSize),this.shaderKey="getpointsConfidenceOp"}return e.prototype.getUserCode=function(){return"\n        ".concat(ru("index")," {\n          if (index < uniforms.size) {\n            let y = B[index * 2];\n            let x = B[index * 2 + 1];\n            let outIndex = y * uniforms.aShape.x * uniforms.aShape.z + x * uniforms.aShape.z + index;\n            result[index] = A[outIndex];\n          }\n        }\n        ")},e}();var ou=function(){function e(e){if(this.variableNames=["A","B"],this.size=!0,this.supportedLastDimension=2,2!==e.length||e[1]!==this.supportedLastDimension)throw new Error("GetOffsetVectorsProgram only supports shape of [x, ".concat(this.supportedLastDimension,"], but current shape is ").concat(e));this.workgroupSize=[32,1,1],this.outputShape=e;var t=[e[0],1];this.dispatchLayout=Xt(t),this.dispatch=Gt(this.dispatchLayout,t,this.workgroupSize),this.shaderKey="GetOffsetVectors"}return e.prototype.getUserCode=function(){return"\n    fn getOffsetPoint(y: i32, x: i32, index: i32) -> vec2<i32> {\n      let outIndexY = y * uniforms.bShape.x * uniforms.bShape.y + x * uniforms.bShape.y + index;\n      let outIndexX = outIndexY + uniforms.bShape.z;\n      let outY = i32(B[outIndexY]);\n      let outX = i32(B[outIndexX]);\n      return vec2<i32>(outY, outX);\n    }\n\n    ".concat(ru("index")," {\n      if (index < uniforms.size) {\n        let indexY = index * ").concat(this.supportedLastDimension,";\n        let indexX = indexY + 1;\n        let heatmapY = A[indexY];\n        let heatmapX = A[indexX];\n        let out = getOffsetPoint(i32(heatmapY), i32(heatmapX), index);\n        result[indexY] = f32(out[0]);\n        result[indexX] = f32(out[1]);\n      }\n    }\n    ")},e}();function au(e){var t=e.shape,n=t[0],r=t[1],s=t[2];return Object(o.Bd)((function(){var t,a,u=Object(o.od)(e,[n*r,s]),l=Object(o.Mc)(u,0),h=Object(o.cd)(Object(o.Yc)(l,Object(o.pd)(r,"int32")),1),c=Object(o.cd)((t=l,a=r,Object(o.Bd)((function(){var e=Object(o.Yc)(t,Object(o.pd)(a,"int32"));return Object(o.wd)(t,Object(o.kd)(e,Object(o.pd)(a,"int32")))}))),1);return Object(o.Wc)([h,c],1)}))}function su(e,t,n){return Object(o.Bd)((function(){var r=function(e,t){for(var n=[],r=0;r<x.length;r++){var l=uu(e.get(r,0).valueOf(),e.get(r,1).valueOf(),r,t),u=l.x,h=l.y;n.push(h),n.push(u)}return Object(o.Ad)(n,[x.length,2])}(e,n);return Object(o.Lc)(Object(o.Tc)(Object(o.kd)(e.toTensor(),Object(o.pd)(t,"int32")),"float32"),r)}))}function uu(e,t,n,r){return{y:r.get(e,t,n),x:r.get(e,t,n+x.length)}}function lu(e,t,n){return f(this,void 0,void 0,(function(){var r,i,s,o,a,u,l,h,c,d;return m(this,(function(p){switch(p.label){case 0:return r=0,i=au(e),[4,Promise.all([e.buffer(),t.buffer(),i.buffer()])];case 1:return s=p.sent(),o=s[0],a=s[1],u=s[2],[4,(l=su(u,n,a)).buffer()];case 2:return h=p.sent(),c=Array.from(function(e,t){for(var n=t.shape[0],r=new Float32Array(n),i=0;i<n;i++){var s=t.get(i,0),o=t.get(i,1);r[i]=e.get(s,o,i)}return r}(o,u)),d=c.map((function(e,t){return r+=e,{y:h.get(t,0),x:h.get(t,1),score:e,name:x[t]}})),i.dispose(),l.dispose(),[2,{keypoints:d,score:r/d.length}]}}))}))}function hu(e,t,n){return f(this,void 0,void 0,(function(){var r,a,u;return m(this,(function(l){return r=au(e),a=function(e,t,n){return Object(o.Bd)((function(){var r=function(e,t){if(Object(o.Nc)()instanceof Jt)return function(e,t){var n=Object(o.Nc)(),r=new ou(e.shape),i=n.runWebGPUProgram(r,[e,t],"float32");return Object(o.Zc)().makeTensorFromTensorInfo(i)}(e,t);throw new Error("getOffsetVectorsGPU is not supported in this backend!")}(e,n);return Object(o.Lc)(Object(o.Tc)(Object(o.kd)(e,Object(o.pd)(t,"int32")),"float32"),r)}))}(r,n,t),u=function(e,t){if(Object(o.Nc)()instanceof Jt)return function(e,t){var n=Object(o.Nc)(),r=new iu(t.shape),i=n.runWebGPUProgram(r,[e,t],"float32");return Object(o.Zc)().makeTensorFromTensorInfo(i)}(e,t);throw new Error("getPointsConfidenceWebGPU is not supported in this backend!")}(e,r),[2,[a,u]]}))}))}function cu(e,t){return(e-1)%t==0}var du="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",pu="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";function fu(e,t){return function(e,t){return(e-1)%t==0}(e,t)?e:Math.floor(e/t)*t+1}var mu=function(){function e(e,t){this.posenetModel=e;var n=this.posenetModel.inputs[0].shape;o.Ed.assert(-1===n[1]&&-1===n[2],(function(){return"Input shape [".concat(n[1],", ").concat(n[2],"] ")+"must both be equal to or -1"}));var i,s,r=(i=t.inputResolution,s=t.outputStride,{height:fu(i.height,s),width:fu(i.width,s)});!function(e){o.Ed.assert(Ze.indexOf(e)>=0,(function(){return"outputStride of ".concat(e," is invalid. ")+"It must be either 8 or 16."}))}(t.outputStride),function(e,t){o.Ed.assert(cu(e.height,t),(function(){return"height of ".concat(e.height," is invalid for output stride ")+"".concat(t,".")})),o.Ed.assert(cu(e.width,t),(function(){return"width of ".concat(e.width," is invalid for output stride ")+"".concat(t,".")}))}(r,t.outputStride),this.inputResolution=r,this.outputStride=t.outputStride,this.architecture=t.architecture}return e.prototype.estimatePoses=function(e,t){return void 0===t&&(t=tt),f(this,void 0,void 0,(function(){return m(this,(function(n){return[2,this.estimatePosesGPU(e,t,!1)]}))}))},e.prototype.estimatePosesGPU=function(e,t,n){return void 0===t&&(t=tt),void 0===n&&(n=!1),f(this,void 0,void 0,(function(){var r,i,l,a,u,h,c,f,y,x,g,v,w,b,k,S,I,C;return m(this,(function(m){switch(m.label){case 0:return r=function(e){var t=e;if(null==t.maxPoses&&(t.maxPoses=1),t.maxPoses<=0)throw new Error("Invalid maxPoses ".concat(t.maxPoses,". Should be > 0."));if(t.maxPoses>1){if((t=d(d({},nt),t)).scoreThreshold<0||t.scoreThreshold>1)throw new Error("Invalid scoreThreshold ".concat(t.scoreThreshold,". ")+"Should be in range [0.0, 1.0]");if(t.nmsRadius<=0)throw new Error("Invalid nmsRadius ".concat(t.nmsRadius,"."))}return t}(t),null==e?[2,n?[[],[]]:[]]:(this.maxPoses=r.maxPoses,i=G(e,{outputTensorSize:this.inputResolution,keepAspectRatio:!0,borderMode:"replicate"}),l=i.imageTensor,a=i.padding,u="ResNet50"===this.architecture?Object(o.Lc)(l,it):tr(l,[-1,1]),h=this.posenetModel.predict(u),"ResNet50"===this.architecture?(c=Object(o.ud)(h[2],[0]),f=Object(o.ud)(h[3],[0]),y=Object(o.ud)(h[0],[0]),x=Object(o.ud)(h[1],[0])):(c=Object(o.ud)(h[0],[0]),f=Object(o.ud)(h[1],[0]),y=Object(o.ud)(h[2],[0]),x=Object(o.ud)(h[3],[0])),g=Object(o.qd)(f),1!==this.maxPoses?[3,5]:n?[4,hu(g,c,this.outputStride)]:[3,2]);case 1:return w=m.sent(),k=w[0],b=w[1],v=[k,b],[3,4];case 2:return[4,lu(g,c,this.outputStride)];case 3:k=m.sent(),v=[k],m.label=4;case 4:return[3,7];case 5:if(n)throw new Error("GPU renderer only supports single pose!");return[4,St(g,c,y,x,this.outputStride,this.maxPoses,r.scoreThreshold,r.nmsRadius)];case 6:v=m.sent(),m.label=7;case 7:if(n){if(!0===r.flipHorizontal)throw new Error("flipHorizontal is not supported!");S=this.getCanvasInfo(N(e),this.inputResolution,a)}else C=N(e),I=function(e,t,n,r){var i=t.height,s=t.width,o=i/(n.height*(1-r.top-r.bottom)),a=s/(n.width*(1-r.left-r.right)),u=-r.top*n.height,l=-r.left*n.width;if(1===a&&1===o&&0===u&&0===l)return e;for(var h=0,c=e;h<c.length;h++)for(var d=0,p=c[h].keypoints;d<p.length;d++){var f=p[d];f.x=(f.x+l)*a,f.y=(f.y+u)*o}return e}(v,C,this.inputResolution,a),r.flipHorizontal&&(I=function(e,t){for(var n=0,r=e;n<r.length;n++)for(var i=0,s=r[n].keypoints;i<s.length;i++){var o=s[i];o.x=t.width-1-o.x}return e}(I,C));return l.dispose(),u.dispose(),Object(o.Xc)(h),c.dispose(),f.dispose(),y.dispose(),x.dispose(),g.dispose(),[2,n?[v,S]:I]}}))}))},e.prototype.getCanvasInfo=function(e,t,n){var r=e.height,i=e.width,s=r/(t.height*(1-n.top-n.bottom)),o=i/(t.width*(1-n.left-n.right)),a=-n.top*t.height;return[-n.left*t.width,a,o,s,e.width,e.height]},e.prototype.dispose=function(){this.posenetModel.dispose()},e.prototype.reset=function(){},e}();function gu(e){return void 0===e&&(e=Ye),f(this,void 0,void 0,(function(){var t,n,r,i,s;return m(this,(function(o){switch(o.label){case 0:return"ResNet50"!==(t=function(e){var t=e||Ye;if(null==t.architecture&&(t.architecture="MobileNetV1"),qe.indexOf(t.architecture)<0)throw new Error("Invalid architecture ".concat(t.architecture,". ")+"Should be one of ".concat(qe));if(null==t.inputResolution&&(t.inputResolution={height:257,width:257}),null==t.outputStride&&(t.outputStride=16),Qe[t.architecture].indexOf(t.outputStride)<0)throw new Error("Invalid outputStride ".concat(t.outputStride,". ")+"Should be one of ".concat(Qe[t.architecture]," ")+"for architecture ".concat(t.architecture,"."));if(null==t.multiplier&&(t.multiplier=1),Je[t.architecture].indexOf(t.multiplier)<0)throw new Error("Invalid multiplier ".concat(t.multiplier,". ")+"Should be one of ".concat(Je[t.architecture]," ")+"for architecture ".concat(t.architecture,"."));if(null==t.quantBytes&&(t.quantBytes=4),et.indexOf(t.quantBytes)<0)throw new Error("Invalid quantBytes ".concat(t.quantBytes,". ")+"Should be one of ".concat(et," ")+"for architecture ".concat(t.architecture,"."));if("MobileNetV1"===t.architecture&&32===t.outputStride&&1!==t.multiplier)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return t}(e)).architecture?[3,2]:(a=t.outputStride,u=t.quantBytes,h="model-stride".concat(a,".json"),n=4===u?pu+"float/"+h:pu+"quant".concat(u,"/")+h,[4,Object(l.a)(t.modelUrl||n)]);case 1:return r=o.sent(),[2,new mu(r,t)];case 2:return i=function(e,t,n){var r={1:"100",.75:"075",.5:"050"},i="model-stride".concat(e,".json");return 4===n?du+"float/".concat(r[t],"/")+i:du+"quant".concat(n,"/").concat(r[t],"/")+i}(t.outputStride,t.multiplier,t.quantBytes),[4,Object(l.a)(t.modelUrl||i)];case 3:return s=o.sent(),[2,new mu(s,t)]}var a,u,h}))}))}function bu(e,t){return f(this,void 0,void 0,(function(){var n,r;return m(this,(function(i){switch(e){case Fe.PoseNet:return[2,gu(t)];case Fe.BlazePose:if(r=void 0,null!=(n=t)){if("tfjs"===n.runtime)return[2,Pe(t)];if("mediapipe"===n.runtime)return[2,_(t)];r=n.runtime}throw new Error("Expect modelConfig.runtime to be either 'tfjs' "+"or 'mediapipe', but got ".concat(r));case Fe.MoveNet:return[2,Xe(t)];default:throw new Error("".concat(e," is not a supported model name."))}}))}))}var yu={modelType:{SINGLEPOSE_LIGHTNING:"SinglePose.Lightning",SINGLEPOSE_THUNDER:"SinglePose.Thunder",MULTIPOSE_LIGHTNING:"MultiPose.Lightning"}}},1065:function(e,t,n){(function(e){(function(){"use strict";var t;function n(a){var b=0;return function(){return b<a.length?{done:!1,value:a[b++]}:{done:!0}}}var r="function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,e){return a==Array.prototype||a==Object.prototype||(a[b]=e.value),a};var o=function(a){a=["object"==typeof globalThis&&globalThis,a,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof e&&e];for(var b=0;b<a.length;++b){var t=a[b];if(t&&t.Math==Math)return t}throw Error("Cannot find global object")}(this);function l(a,b){if(b)e:{var e=o;a=a.split(".");for(var t=0;t<a.length-1;t++){var n=a[t];if(!(n in e))break e;e=e[n]}(b=b(t=e[a=a[a.length-1]]))!=t&&null!=b&&r(e,a,{configurable:!0,writable:!0,value:b})}}function h(a){return(a={next:a})[Symbol.iterator]=function(){return this},a}function c(a){var b="undefined"!=typeof Symbol&&Symbol.iterator&&a[Symbol.iterator];return b?b.call(a):{next:n(a)}}function d(a){if(!(a instanceof Array)){a=c(a);for(var b,e=[];!(b=a.next()).done;)e.push(b.value);a=e}return a}l("Symbol",(function(a){function e(g,e){this.h=g,r(this,"description",{configurable:!0,writable:!0,value:e})}if(a)return a;e.prototype.toString=function(){return this.h};var t="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",n=0;return function b(g){if(this instanceof b)throw new TypeError("Symbol is not a constructor");return new e(t+(g||"")+"_"+n++,g)}})),l("Symbol.iterator",(function(a){if(a)return a;a=Symbol("Symbol.iterator");for(var b="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),e=0;e<b.length;e++){var t=o[b[e]];"function"==typeof t&&"function"!=typeof t.prototype[a]&&r(t.prototype,a,{configurable:!0,writable:!0,value:function(){return h(n(this))}})}return a}));var f="function"==typeof Object.assign?Object.assign:function(a,b){for(var e=1;e<arguments.length;e++){var t=arguments[e];if(t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(a[n]=t[n])}return a};l("Object.assign",(function(a){return a||f}));var m,y="function"==typeof Object.create?Object.create:function(a){function b(){}return b.prototype=a,new b};if("function"==typeof Object.setPrototypeOf)m=Object.setPrototypeOf;else{var x;e:{var v={};try{v.__proto__={a:!0},x=v.a;break e}catch(e){}x=!1}m=x?function(a,b){if(a.__proto__=b,a.__proto__!==b)throw new TypeError(a+" is not extensible");return a}:null}var w=m;function k(a,b){if(a.prototype=y(b.prototype),a.prototype.constructor=a,w)w(a,b);else for(var e in b)if("prototype"!=e)if(Object.defineProperties){var t=Object.getOwnPropertyDescriptor(b,e);t&&Object.defineProperty(a,e,t)}else a[e]=b[e];a.za=b.prototype}function S(){this.m=!1,this.j=null,this.i=void 0,this.h=1,this.v=this.s=0,this.l=null}function I(a){if(a.m)throw new TypeError("Generator is already running");a.m=!0}function C(a,b){a.l={ma:b,na:!0},a.h=a.s||a.v}function O(a,b,e){return a.h=e,{value:b}}function A(a){this.h=new S,this.i=a}function T(a,b,e,t){try{var n=b.call(a.h.j,e);if(!(n instanceof Object))throw new TypeError("Iterator result "+n+" is not an object");if(!n.done)return a.h.m=!1,n;var g=n.value}catch(e){return a.h.j=null,C(a.h,e),E(a)}return a.h.j=null,t.call(a.h,g),E(a)}function E(a){for(;a.h.h;)try{var b=a.i(a.h);if(b)return a.h.m=!1,{value:b.value,done:!1}}catch(e){a.h.i=void 0,C(a.h,e)}if(a.h.m=!1,a.h.l){if(b=a.h.l,a.h.l=null,b.na)throw b.ma;return{value:b.return,done:!0}}return{value:void 0,done:!0}}function R(a){this.next=function(b){return I(a.h),a.h.j?b=T(a,a.h.j.next,b,a.h.u):(a.h.u(b),b=E(a)),b},this.throw=function(b){return I(a.h),a.h.j?b=T(a,a.h.j.throw,b,a.h.u):(C(a.h,b),b=E(a)),b},this.return=function(b){return function(a,b){I(a.h);var e=a.h.j;return e?T(a,"return"in e?e.return:function(e){return{value:e,done:!0}},b,a.h.return):(a.h.return(b),E(a))}(a,b)},this[Symbol.iterator]=function(){return this}}function P(a){return function(a){function b(e){return a.next(e)}function e(e){return a.throw(e)}return new Promise((function(t,n){!function g(r){r.done?t(r.value):Promise.resolve(r.value).then(b,e).then(g,n)}(a.next())}))}(new R(new A(a)))}function $(a){return a||Array.prototype.fill}S.prototype.u=function(a){this.i=a},S.prototype.return=function(a){this.l={return:a},this.h=this.v},l("Promise",(function(a){function b(e){this.i=0,this.j=void 0,this.h=[],this.u=!1;var t=this.l();try{e(t.resolve,t.reject)}catch(e){t.reject(e)}}function e(){this.h=null}function t(e){return e instanceof b?e:new b((function(t){t(e)}))}if(a)return a;e.prototype.i=function(e){if(null==this.h){this.h=[];var t=this;this.j((function(){t.m()}))}this.h.push(e)};var n=o.setTimeout;e.prototype.j=function(e){n(e,0)},e.prototype.m=function(){for(;this.h&&this.h.length;){var e=this.h;this.h=[];for(var t=0;t<e.length;++t){var n=e[t];e[t]=null;try{n()}catch(e){this.l(e)}}}this.h=null},e.prototype.l=function(e){this.j((function(){throw e}))},b.prototype.l=function(){function e(e){return function(r){n||(n=!0,e.call(t,r))}}var t=this,n=!1;return{resolve:e(this.I),reject:e(this.m)}},b.prototype.I=function(e){if(e===this)this.m(new TypeError("A Promise cannot resolve to itself"));else if(e instanceof b)this.L(e);else{e:switch(typeof e){case"object":var t=null!=e;break e;case"function":t=!0;break e;default:t=!1}t?this.F(e):this.s(e)}},b.prototype.F=function(e){var t=void 0;try{t=e.then}catch(e){return void this.m(e)}"function"==typeof t?this.M(t,e):this.s(e)},b.prototype.m=function(e){this.v(2,e)},b.prototype.s=function(e){this.v(1,e)},b.prototype.v=function(e,t){if(0!=this.i)throw Error("Cannot settle("+e+", "+t+"): Promise already settled in state"+this.i);this.i=e,this.j=t,2===this.i&&this.K(),this.H()},b.prototype.K=function(){var e=this;n((function(){if(e.D()){var t=o.console;void 0!==t&&t.error(e.j)}}),1)},b.prototype.D=function(){if(this.u)return!1;var e=o.CustomEvent,t=o.Event,n=o.dispatchEvent;return void 0===n||("function"==typeof e?e=new e("unhandledrejection",{cancelable:!0}):"function"==typeof t?e=new t("unhandledrejection",{cancelable:!0}):(e=o.document.createEvent("CustomEvent")).initCustomEvent("unhandledrejection",!1,!0,e),e.promise=this,e.reason=this.j,n(e))},b.prototype.H=function(){if(null!=this.h){for(var e=0;e<this.h.length;++e)g.i(this.h[e]);this.h=null}};var g=new e;return b.prototype.L=function(e){var t=this.l();e.T(t.resolve,t.reject)},b.prototype.M=function(e,t){var n=this.l();try{e.call(t,n.resolve,n.reject)}catch(e){n.reject(e)}},b.prototype.then=function(e,t){function n(p,e){return"function"==typeof p?function(q){try{r(p(q))}catch(e){o(e)}}:e}var r,o,l=new b((function(p,e){r=p,o=e}));return this.T(n(e,r),n(t,o)),l},b.prototype.catch=function(e){return this.then(void 0,e)},b.prototype.T=function(e,t){function n(){switch(r.i){case 1:e(r.j);break;case 2:t(r.j);break;default:throw Error("Unexpected state: "+r.i)}}var r=this;null==this.h?g.i(n):this.h.push(n),this.u=!0},b.resolve=t,b.reject=function(e){return new b((function(t,n){n(e)}))},b.race=function(e){return new b((function(n,r){for(var o=c(e),l=o.next();!l.done;l=o.next())t(l.value).T(n,r)}))},b.all=function(e){var n=c(e),r=n.next();return r.done?t([]):new b((function(e,o){function l(q){return function(t){p[q]=t,0==--h&&e(p)}}var p=[],h=0;do{p.push(void 0),h++,t(r.value).T(l(p.length-1),o),r=n.next()}while(!r.done)}))},b})),l("Array.prototype.keys",(function(a){return a||function(){return function(a,b){a instanceof String&&(a+="");var e=0,t=!1,n={next:function(){if(!t&&e<a.length){var g=e++;return{value:b(g,a[g]),done:!1}}return t=!0,{done:!0,value:void 0}}};return n[Symbol.iterator]=function(){return n},n}(this,(function(b){return b}))}})),l("Array.prototype.fill",(function(a){return a||function(b,e,t){var n=this.length||0;for(0>e&&(e=Math.max(0,n+e)),(null==t||t>n)&&(t=n),0>(t=Number(t))&&(t=Math.max(0,n+t)),e=Number(e||0);e<t;e++)this[e]=b;return this}})),l("Int8Array.prototype.fill",$),l("Uint8Array.prototype.fill",$),l("Uint8ClampedArray.prototype.fill",$),l("Int16Array.prototype.fill",$),l("Uint16Array.prototype.fill",$),l("Int32Array.prototype.fill",$),l("Uint32Array.prototype.fill",$),l("Float32Array.prototype.fill",$),l("Float64Array.prototype.fill",$),l("Object.is",(function(a){return a||function(b,e){return b===e?0!==b||1/b==1/e:b!=b&&e!=e}})),l("Array.prototype.includes",(function(a){return a||function(b,e){var t=this;t instanceof String&&(t=String(t));var n=t.length;for(0>(e=e||0)&&(e=Math.max(e+n,0));e<n;e++){var g=t[e];if(g===b||Object.is(g,b))return!0}return!1}})),l("String.prototype.includes",(function(a){return a||function(b,e){if(null==this)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(b instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return-1!==this.indexOf(b,e||0)}}));var F=this||self;function _(a,b){a=a.split(".");var e,t=F;a[0]in t||void 0===t.execScript||t.execScript("var "+a[0]);for(;a.length&&(e=a.shift());)a.length||void 0===b?t=t[e]&&t[e]!==Object.prototype[e]?t[e]:t[e]={}:t[e]=b}function N(a){var b;return(b=F.navigator)&&(b=b.userAgent)||(b=""),-1!=b.indexOf(a)}var z=Array.prototype.map?function(a,b){return Array.prototype.map.call(a,b,void 0)}:function(a,b){for(var e=a.length,t=Array(e),n="string"==typeof a?a.split(""):a,g=0;g<e;g++)g in n&&(t[g]=b.call(void 0,n[g],g,a));return t},M={},L=null;function B(a){var b=a.length,e=3*b/4;e%3?e=Math.floor(e):-1!="=.".indexOf(a[b-1])&&(e=-1!="=.".indexOf(a[b-2])?e-2:e-1);var t=new Uint8Array(e),n=0;return function(a,b){function e(e){for(;t<a.length;){var n=a.charAt(t++),r=L[n];if(null!=r)return r;if(!/^[\s\xa0]*$/.test(n))throw Error("Unknown base64 encoding at char: "+n)}return e}U();for(var t=0;;){var n=e(-1),g=e(0),r=e(64),o=e(64);if(64===o&&-1===n)break;b(n<<2|g>>4),64!=r&&(b(g<<4&240|r>>2),64!=o&&b(r<<6&192|o))}}(a,(function(g){t[n++]=g})),n!==e?t.subarray(0,n):t}function U(){if(!L){L={};for(var a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),b=["+/=","+/","-_=","-_.","-_"],e=0;5>e;e++){var t=a.concat(b[e].split(""));M[e]=t;for(var n=0;n<t.length;n++){var g=t[n];void 0===L[g]&&(L[g]=n)}}}}var D="undefined"!=typeof Uint8Array,j=!(N("Trident")||N("MSIE"))&&"function"==typeof F.btoa;function W(a){if(!j){var b;void 0===b&&(b=0),U(),b=M[b];for(var e=Array(Math.floor(a.length/3)),t=b[64]||"",n=0,g=0;n<a.length-2;n+=3){var r=a[n],o=a[n+1],l=a[n+2],h=b[r>>2];r=b[(3&r)<<4|o>>4],o=b[(15&o)<<2|l>>6],l=b[63&l],e[g++]=h+r+o+l}switch(h=0,l=t,a.length-n){case 2:l=b[(15&(h=a[n+1]))<<2]||t;case 1:a=a[n],e[g]=b[a>>2]+b[(3&a)<<4|h>>4]+l+t}return e.join("")}for(b="";10240<a.length;)b+=String.fromCharCode.apply(null,a.subarray(0,10240)),a=a.subarray(10240);return b+=String.fromCharCode.apply(null,a),btoa(b)}var V,G=RegExp("[-_.]","g");function H(a){switch(a){case"-":return"+";case"_":return"/";case".":return"=";default:return""}}function K(a){if(!j)return B(a);G.test(a)&&(a=a.replace(G,H)),a=atob(a);for(var b=new Uint8Array(a.length),e=0;e<a.length;e++)b[e]=a.charCodeAt(e);return b}function X(){return V||(V=new Uint8Array(0))}var Y={},Q="function"==typeof Uint8Array.prototype.slice,Z=0,J=0;function ee(a){var b=0>a,e=(a=Math.abs(a))>>>0;a=Math.floor((a-e)/4294967296),b&&(b=(e=c(re(e,a))).next().value,a=e.next().value,e=b),Z=e>>>0,J=a>>>0}var te,ne="function"==typeof BigInt;function re(a,b){return b=~b,a?a=1+~a:b+=1,[a,b]}function ie(a,b){this.i=a>>>0,this.h=b>>>0}function oe(a){if(!a)return te||(te=new ie(0,0));if(!/^-?\d+$/.test(a))return null;if(16>a.length)ee(Number(a));else if(ne)a=BigInt(a),Z=Number(a&BigInt(4294967295))>>>0,J=Number(a>>BigInt(32)&BigInt(4294967295));else{var b=+("-"===a[0]);J=Z=0;for(var e=a.length,t=b,n=(e-b)%6+b;n<=e;t=n,n+=6)t=Number(a.slice(t,n)),J*=1e6,4294967296<=(Z=1e6*Z+t)&&(J+=Z/4294967296|0,Z%=4294967296);b&&(a=(b=c(re(Z,J))).next().value,b=b.next().value,Z=a,J=b)}return new ie(Z,J)}function ae(a,b){return Error("Invalid wire type: "+a+" (at position "+b+")")}function se(){return Error("Failed to read varint, encoding is invalid.")}function ue(a,b){return Error("Tried to read past the end of the data "+b+" > "+a)}function le(){throw Error("Invalid UTF8")}function he(a,b){return b=String.fromCharCode.apply(null,b),null==a?b:a+b}var ce,de,pe,fe=void 0,me="undefined"!=typeof TextDecoder,ge="undefined"!=typeof TextEncoder;function be(a){if(a!==Y)throw Error("illegal external caller")}function ye(a,b){if(be(b),this.V=a,null!=a&&0===a.length)throw Error("ByteString should be constructed with non-empty values")}function xe(){return pe||(pe=new ye(null,Y))}function ve(a){be(Y);var b=a.V;return null==(b=null==b||D&&null!=b&&b instanceof Uint8Array?b:"string"==typeof b?K(b):null)?b:a.V=b}function we(a,b){this.i=null,this.m=!1,this.h=this.j=this.l=0,ke(this,a,b)}function ke(a,b,e){e=void 0===e?{}:e,a.S=void 0!==e.S&&e.S,b&&(b=function(a){if("string"==typeof a)return{buffer:K(a),C:!1};if(Array.isArray(a))return{buffer:new Uint8Array(a),C:!1};if(a.constructor===Uint8Array)return{buffer:a,C:!1};if(a.constructor===ArrayBuffer)return{buffer:new Uint8Array(a),C:!1};if(a.constructor===ye)return{buffer:ve(a)||X(),C:!0};if(a instanceof Uint8Array)return{buffer:new Uint8Array(a.buffer,a.byteOffset,a.byteLength),C:!1};throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers")}(b),a.i=b.buffer,a.m=b.C,a.l=0,a.j=a.i.length,a.h=a.l)}function Se(a,b){if(a.h=b,b>a.j)throw ue(a.j,b)}function Ie(a){var b=a.i,e=a.h,t=b[e++],n=127&t;if(128&t&&(n|=(127&(t=b[e++]))<<7,128&t&&(n|=(127&(t=b[e++]))<<14,128&t&&(n|=(127&(t=b[e++]))<<21,128&t&&(n|=(t=b[e++])<<28,128&t&&128&b[e++]&&128&b[e++]&&128&b[e++]&&128&b[e++]&&128&b[e++])))))throw se();return Se(a,e),n}function Ce(a,b){if(0>b)throw Error("Tried to read a negative byte length: "+b);var e=a.h,t=e+b;if(t>a.j)throw ue(b,a.j-e);return a.h=t,e}we.prototype.reset=function(){this.h=this.l};var Oe=[];function Ae(){this.h=[]}function Te(a,b,e){for(;0<e||127<b;)a.h.push(127&b|128),b=(b>>>7|e<<25)>>>0,e>>>=7;a.h.push(b)}function Ee(a,b){for(;127<b;)a.h.push(127&b|128),b>>>=7;a.h.push(b)}function Re(a,b){if(Oe.length){var e=Oe.pop();ke(e,a,b),a=e}else a=new we(a,b);this.h=a,this.j=this.h.h,this.i=this.l=-1,this.setOptions(b)}function Pe(a){var b=a.h;if(b.h==b.j)return!1;a.j=a.h.h;var e=Ie(a.h)>>>0;if(b=e>>>3,!(0<=(e&=7)&&5>=e))throw ae(e,a.j);if(1>b)throw Error("Invalid field number: "+b+" (at position "+a.j+")");return a.l=b,a.i=e,!0}function $e(a){switch(a.i){case 0:if(0!=a.i)$e(a);else e:{for(var b=(a=a.h).h,e=b+10,t=a.i;b<e;)if(0==(128&t[b++])){Se(a,b);break e}throw se()}break;case 1:Se(a=a.h,a.h+8);break;case 2:2!=a.i?$e(a):(b=Ie(a.h)>>>0,Se(a=a.h,a.h+b));break;case 5:Se(a=a.h,a.h+4);break;case 3:for(b=a.l;;){if(!Pe(a))throw Error("Unmatched start-group tag: stream EOF");if(4==a.i){if(a.l!=b)throw Error("Unmatched end-group tag");break}$e(a)}break;default:throw ae(a.i,a.j)}}Ae.prototype.length=function(){return this.h.length},Ae.prototype.end=function(){var a=this.h;return this.h=[],a},Re.prototype.setOptions=function(a){a=void 0===a?{}:a,this.ca=void 0!==a.ca&&a.ca},Re.prototype.reset=function(){this.h.reset(),this.j=this.h.h,this.i=this.l=-1};var Fe=[];function _e(){this.j=[],this.i=0,this.h=new Ae}function Ne(a,b){0!==b.length&&(a.j.push(b),a.i+=b.length)}var ze="function"==typeof Symbol&&"symbol"==typeof Symbol()?Symbol():void 0;function Me(a,b){return ze?a[ze]|=b:void 0!==a.A?a.A|=b:(Object.defineProperties(a,{A:{value:b,configurable:!0,writable:!0,enumerable:!1}}),b)}function Le(a,b){ze?a[ze]&&(a[ze]&=~b):void 0!==a.A&&(a.A&=~b)}function Be(a){var b;return null==(b=ze?a[ze]:a.A)?0:b}function Ue(a,b){ze?a[ze]=b:void 0!==a.A?a.A=b:Object.defineProperties(a,{A:{value:b,configurable:!0,writable:!0,enumerable:!1}})}function De(a){return Me(a,1),a}function je(a,b){Ue(b,-51&(0|a))}function We(a,b){Ue(b,-41&(18|a))}var Ve={};function Ge(a){return null!==a&&"object"==typeof a&&!Array.isArray(a)&&a.constructor===Object}var He,Ke,Xe=[];function Ye(a){if(2&Be(a.o))throw Error("Cannot mutate an immutable Message")}function qe(a){var b=a.length;(b=b?a[b-1]:void 0)&&Ge(b)?b.g=1:(b={},a.push((b.g=1,b)))}function Qe(a){var b=a.i+a.G;return a.B||(a.B=a.o[b]={})}function Ze(a,b){return-1===b?null:b>=a.i?a.B?a.B[b]:void 0:a.o[b+a.G]}function Je(a,b,e,t){Ye(a),et(a,b,e,t)}function et(a,b,e,t){a.j&&(a.j=void 0),b>=a.i||t?Qe(a)[b]=e:(a.o[b+a.G]=e,(a=a.B)&&b in a&&delete a[b])}function tt(a,b,e,t){var n=Ze(a,b);Array.isArray(n)||(n=He);var g=Be(n);if(1&g||De(n),t)2&g||Me(n,2),1&e||Object.freeze(n);else{t=!(2&e);var r=2&g;1&e||!r?t&&16&g&&!r&&Le(n,16):et(a,b,n=De(Array.prototype.slice.call(n)))}return n}function nt(a,b){var e=Ze(a,b),t=null==e?e:"number"==typeof e||"NaN"===e||"Infinity"===e||"-Infinity"===e?Number(e):void 0;return null!=t&&t!==e&&et(a,b,t),t}function it(a,b,e,t,n){a.h||(a.h={});var g=a.h[e],r=tt(a,e,3,n);if(!g){var o=r;g=[];var l=!!(16&Be(a.o));r=!!(2&Be(o));var h=o;!n&&r&&(o=Array.prototype.slice.call(o));for(var c=r,d=0;d<o.length;d++){var p=o[d],f=b,q=!1;if(q=void 0!==q&&q,void 0!==(p=Array.isArray(p)?new f(p):q?new f:void 0)){var m=q=Be(f=p.o);r&&(m|=2),l&&(m|=16),m!=q&&Ue(f,m),f=m,c=c||!!(2&f),g.push(p)}}return a.h[e]=g,b=33|(l=Be(o)),l!=(b=c?-9&b:8|b)&&(c=o,Object.isFrozen(c)&&(c=Array.prototype.slice.call(c)),Ue(c,b),o=c),h!==o&&et(a,e,o),(n||t&&r)&&Me(g,2),t&&Object.freeze(g),g}return n||(n=Object.isFrozen(g),t&&!n?Object.freeze(g):!t&&n&&(g=Array.prototype.slice.call(g),a.h[e]=g)),g}function ot(a,b,e){var t=!!(2&Be(a.o));if(b=it(a,b,e,t,t),a=tt(a,e,3,t),!(t||8&Be(a))){for(t=0;t<b.length;t++){if(2&Be((e=b[t]).o)){var n=yt(e,!1);n.j=e}else n=e;e!==n&&(b[t]=n,a[t]=n.o)}Me(a,8)}return b}function at(a,b,e){if(null!=e&&"number"!=typeof e)throw Error("Value of float/double field must be a number|null|undefined, found "+typeof e+": "+e);Je(a,b,e)}function st(a,b,e,t,n){Ye(a);var g=it(a,e,b,!1,!1);return e=null!=t?t:new e,a=tt(a,b,2,!1),null!=n?(g.splice(n,0,e),a.splice(n,0,e.o)):(g.push(e),a.push(e.o)),e.C()&&Le(a,8),e}function ut(a,b){return null==a?b:a}function lt(a,b,e){return e=void 0===e?0:e,ut(nt(a,b),e)}function ht(a,b,e,t){if(null!=a){if(Array.isArray(a))a=ct(a,b,e,void 0!==t);else if(Ge(a)){var g,n={};for(g in a)n[g]=ht(a[g],b,e,t);a=n}else a=b(a,t);return a}}function ct(a,b,e,t){var n=Be(a);t=t?!!(16&n):void 0,a=Array.prototype.slice.call(a);for(var g=0;g<a.length;g++)a[g]=ht(a[g],b,e,t);return e(n,a),a}function pt(a){return a.ja===Ve?a.toJSON():function(a){switch(typeof a){case"number":return isFinite(a)?a:String(a);case"object":if(a)if(Array.isArray(a)){if(0!=(128&Be(a)))return qe(a=Array.prototype.slice.call(a)),a}else{if(D&&null!=a&&a instanceof Uint8Array)return W(a);if(a instanceof ye){var b=a.V;return null==b?"":"string"==typeof b?b:a.V=W(b)}}}return a}(a)}function ft(a,b){128&a&&qe(b)}function mt(a,b,e){if(e=void 0===e?We:e,null!=a){if(D&&a instanceof Uint8Array)return a.length?new ye(new Uint8Array(a),Y):xe();if(Array.isArray(a)){var t=Be(a);return 2&t?a:!b||32&t||!(16&t||0===t)?(4&(b=Be(a=ct(a,mt,4&t?We:e,!0)))&&2&b&&Object.freeze(a),a):(Ue(a,2|t),a)}return a.ja===Ve?bt(a):a}}function gt(a,b,e,t,n,g,r){if(a=a.h&&a.h[e]){if(2&(t=Be(a))?t=a:(We(t,g=z(a,bt)),Object.freeze(g),t=g),Ye(b),r=null==t?He:De([]),null!=t){for(g=!!t.length,a=0;a<t.length;a++){var o=t[a];g=g&&!(2&Be(o.o)),r[a]=o.o}g=1|(g?8:0),((a=Be(r))&g)!==g&&(Object.isFrozen(r)&&(r=Array.prototype.slice.call(r)),Ue(r,a|g)),b.h||(b.h={}),b.h[e]=t}else b.h&&(b.h[e]=void 0);et(b,e,r,n)}else Je(b,e,mt(t,g,r),n)}function bt(a){return 2&Be(a.o)||Me((a=yt(a,!0)).o,2),a}function yt(a,b){var e=a.o,t=[];Me(t,16);var n=a.constructor.h;if(n&&t.push(n),n=a.B){t.length=e.length,t.fill(void 0,t.length,e.length);var g={};t[t.length-1]=g}0!=(128&Be(e))&&qe(t),b=b||a.C()?We:je,g=a.constructor,Ke=t,t=new g(t),Ke=void 0,a.R&&(t.R=a.R.slice()),g=!!(16&Be(e));for(var r=n?e.length-1:e.length,o=0;o<r;o++)gt(a,t,o-a.G,e[o],!1,g,b);if(n)for(var l in n)gt(a,t,+l,n[l],!0,g,b);return t}function xt(a,b,e){null==a&&(a=Ke),Ke=void 0;var t,n=this.constructor.i||0,r=0<n,g=this.constructor.h,o=!1;if(null==a){var l=48,h=!0;r&&(n=0,l|=128),Ue(a=g?[g]:[],l)}else{if(!Array.isArray(a))throw Error();if(g&&g!==a[0])throw Error();var c=l=Me(a,0);if((h=0!=(16&c))&&((o=0!=(32&c))||(c|=32)),r){if(128&c)n=0;else if(0<a.length){var d=a[a.length-1];if(Ge(d)&&"g"in d){n=0,c|=128,delete d.g;var p,f=!0;for(p in d){f=!1;break}f&&a.pop()}}}else if(128&c)throw Error();l!==c&&Ue(a,c)}if(this.G=(g?0:-1)-n,this.h=void 0,this.o=a,n=(g=this.o.length)-1,g&&Ge(g=this.o[n])?(this.B=g,this.i=n-this.G):void 0!==b&&-1<b?(this.i=Math.max(b,n+1-this.G),this.B=void 0):this.i=Number.MAX_VALUE,!r&&this.B&&"g"in this.B)throw Error('Unexpected "g" flag in sparse object of message that is not a group type.');if(e)for(b=h&&!o&&!0,r=this.i,h=0;h<e.length;h++)(o=e[h])<r?(n=a[o+=this.G])?vt(n,b):a[o]=He:(t||(t=Qe(this)),(n=t[o])?vt(n,b):t[o]=He)}function vt(a,b){if(Array.isArray(a)){var e=Be(a),t=1;!b||2&e||(t|=16),(e&t)!==t&&Ue(a,e|t)}}function wt(a,b,e){if(e){var t,n={};for(t in e){var g=e[t],r=g.ra;r||(n.J=g.xa||g.oa.W,g.ia?(n.aa=Et(g.ia),r=function(e){return function(t,n,r){return e.J(t,n,r,e.aa)}}(n)):g.ka?(n.Z=Rt(g.da.P,g.ka),r=function(e){return function(t,n,r){return e.J(t,n,r,e.Z)}}(n)):r=n.J,g.ra=r),r(b,a,g.da),n={J:n.J,aa:n.aa,Z:n.Z}}}!function(a,b){if(b=b.R){Ne(a,a.h.end());for(var e=0;e<b.length;e++)Ne(a,ve(b[e])||X())}}(b,a)}Ue(Xe,23),He=Object.freeze(Xe),xt.prototype.toJSON=function(){return ct(this.o,pt,ft)},xt.prototype.C=function(){return!!(2&Be(this.o))},xt.prototype.ja=Ve,xt.prototype.toString=function(){return this.o.toString()};var kt=Symbol();function St(a,b,e){return a[kt]||(a[kt]=function(t,n){return b(t,n,e)})}function It(a){var b=a[kt];if(!b){var e=jt(a);b=function(t,n){return Wt(t,n,e)},a[kt]=b}return b}function Ct(a){var b=function(a){var b=a.ia;return b?It(b):(b=a.wa)?St(a.da.P,b,a.ka):void 0}(a),e=a.da,t=a.oa.U;return b?function(n,g){return t(n,g,e,b)}:function(n,g){return t(n,g,e)}}function Ot(a,b){var e=a[b];return"function"==typeof e&&0===e.length&&(e=e(),a[b]=e),Array.isArray(e)&&(Mt in e||Pt in e||0<e.length&&"function"==typeof e[0])?e:void 0}function At(a,b,e,t,n,g){b.P=a[0];var r=1;if(a.length>r&&"number"!=typeof a[r]){var o=a[r++];e(b,o)}for(;r<a.length;){e=a[r++];for(var l=r+1;l<a.length&&"number"!=typeof a[l];)l++;switch(o=a[r++],l-=r){case 0:t(b,e,o);break;case 1:(l=Ot(a,r))?(r++,n(b,e,o,l)):t(b,e,o,a[r++]);break;case 2:n(b,e,o,l=Ot(a,l=r++),a[r++]);break;case 3:g(b,e,o,a[r++],a[r++],a[r++]);break;case 4:g(b,e,o,a[r++],a[r++],a[r++],a[r++]);break;default:throw Error("unexpected number of binary field arguments: "+l)}}return b}var Tt=Symbol();function Et(a){var b=a[Tt];if(!b){var e=zt(a);b=function(t,n){return Vt(t,n,e)},a[Tt]=b}return b}function Rt(a,b){var e=a[Tt];return e||(e=function(e,t){return wt(e,t,b)},a[Tt]=e),e}var Pt=Symbol();function $t(a,b){a.push(b)}function Ft(a,b,e){a.push(b,e.W)}function _t(a,b,e,t){var n=Et(t),g=zt(t).P,r=e.W;a.push(b,(function(e,t,o){return r(e,t,o,g,n)}))}function Nt(a,b,e,t,n,g){var r=Rt(t,g),o=e.W;a.push(b,(function(e,n,l){return o(e,n,l,t,r)}))}function zt(a){var b=a[Pt];return b||(b=At(a,a[Pt]=[],$t,Ft,_t,Nt),Mt in a&&Pt in a&&(a.length=0),b)}var Mt=Symbol();function Lt(a,b){a[0]=b}function Bt(a,b,e,t){var n=e.U;a[b]=t?function(g,e,r){return n(g,e,r,t)}:n}function Ut(a,b,e,t,n){var g=e.U,r=It(t),o=jt(t).P;a[b]=function(e,t,l){return g(e,t,l,o,r,n)}}function Dt(a,b,e,t,n,g,r){var o=e.U,l=St(t,n,g);a[b]=function(e,n,h){return o(e,n,h,t,l,r)}}function jt(a){var b=a[Mt];return b||(b=At(a,a[Mt]={},Lt,Bt,Ut,Dt),Mt in a&&Pt in a&&(a.length=0),b)}function Wt(a,b,e){for(;Pe(b)&&4!=b.i;){var t=b.l,n=e[t];if(!n){var g=e[0];g&&(g=g[t])&&(n=e[t]=Ct(g))}if(!n||!n(b,a,t)){t=a,g=(n=b).j,$e(n);var r=n;if(!r.ca){if(n=r.h.h-g,r.h.h=g,r=r.h,0==n)n=xe();else{if(g=Ce(r,n),r.S&&r.m)n=r.i.subarray(g,g+n);else{r=r.i;var o=g;n=o===(n=g+n)?X():Q?r.slice(o,n):new Uint8Array(r.subarray(o,n))}n=0==n.length?xe():new ye(n,Y)}(g=t.R)?g.push(n):t.R=[n]}}}return a}function Vt(a,b,e){for(var t=e.length,n=1==t%2,g=n?1:0;g<t;g+=2)(0,e[g+1])(b,a,e[g]);wt(a,b,n?e[0]:void 0)}function Gt(a,b){return{U:a,W:b}}var Ht=Gt((function(a,b,e){if(5!==a.i)return!1;var t=(a=a.h).i,n=a.h,g=t[n],r=t[n+1],o=t[n+2];return t=t[n+3],Se(a,a.h+4),a=2*((r=(g<<0|r<<8|o<<16|t<<24)>>>0)>>31)+1,g=r>>>23&255,r&=8388607,Je(b,e,255==g?r?NaN:1/0*a:0==g?a*Math.pow(2,-149)*r:a*Math.pow(2,g-150)*(r+Math.pow(2,23))),!0}),(function(a,b,e){if(null!=(b=nt(b,e))){Ee(a.h,8*e+5),a=a.h;var t=+b;0===t?0<1/t?Z=J=0:(J=0,Z=2147483648):isNaN(t)?(J=0,Z=2147483647):34028234663852886e22<(t=(e=0>t?-2147483648:0)?-t:t)?(J=0,Z=(2139095040|e)>>>0):11754943508222875e-54>t?(t=Math.round(t/Math.pow(2,-149)),J=0,Z=(e|t)>>>0):(b=Math.floor(Math.log(t)/Math.LN2),t*=Math.pow(2,-b),16777216<=(t=Math.round(8388608*t))&&++b,J=0,Z=(e|b+127<<23|8388607&t)>>>0),e=Z,a.h.push(e>>>0&255),a.h.push(e>>>8&255),a.h.push(e>>>16&255),a.h.push(e>>>24&255)}})),Kt=Gt((function(a,b,e){if(0!==a.i)return!1;var t=a.h,n=0,g=a=0,r=t.i,o=t.h;do{var l=r[o++];n|=(127&l)<<g,g+=7}while(32>g&&128&l);for(32<g&&(a|=(127&l)>>4),g=3;32>g&&128&l;g+=7)a|=(127&(l=r[o++]))<<g;if(Se(t,o),!(128>l))throw se();return t=n>>>0,(a=2147483648&(l=a>>>0))&&(l=~l>>>0,0==(t=1+~t>>>0)&&(l=l+1>>>0)),t=4294967296*l+(t>>>0),Je(b,e,a?-t:t),!0}),(function(a,b,e){null!=(b=Ze(b,e))&&("string"==typeof b&&oe(b),null!=b&&(Ee(a.h,8*e),"number"==typeof b?(a=a.h,ee(b),Te(a,Z,J)):(e=oe(b),Te(a.h,e.i,e.h))))})),Xt=Gt((function(a,b,e){return 0===a.i&&(Je(b,e,Ie(a.h)),!0)}),(function(a,b,e){if(null!=(b=Ze(b,e))&&null!=b)if(Ee(a.h,8*e),a=a.h,0<=(e=b))Ee(a,e);else{for(b=0;9>b;b++)a.h.push(127&e|128),e>>=7;a.h.push(1)}})),Yt=Gt((function(a,b,e){if(2!==a.i)return!1;var t=Ie(a.h)>>>0,n=Ce(a=a.h,t);if(a=a.i,me){var r,g=a;(r=ce)||(r=ce=new TextDecoder("utf-8",{fatal:!0})),a=n+t,g=0===n&&a===g.length?g:g.subarray(n,a);try{var o=r.decode(g)}catch(e){if(void 0===fe){try{r.decode(new Uint8Array([128]))}catch(e){}try{r.decode(new Uint8Array([97])),fe=!0}catch(e){fe=!1}}throw!fe&&(ce=void 0),e}}else{t=(o=n)+t,n=[];for(var l,h,c=null;o<t;)128>(l=a[o++])?n.push(l):224>l?o>=t?le():(h=a[o++],194>l||128!=(192&h)?(o--,le()):n.push((31&l)<<6|63&h)):240>l?o>=t-1?le():128!=(192&(h=a[o++]))||224===l&&160>h||237===l&&160<=h||128!=(192&(g=a[o++]))?(o--,le()):n.push((15&l)<<12|(63&h)<<6|63&g):244>=l?o>=t-2?le():128!=(192&(h=a[o++]))||0!=h-144+(l<<28)>>30||128!=(192&(g=a[o++]))||128!=(192&(r=a[o++]))?(o--,le()):(l=(7&l)<<18|(63&h)<<12|(63&g)<<6|63&r,l-=65536,n.push(55296+(l>>10&1023),56320+(1023&l))):le(),8192<=n.length&&(c=he(c,n),n.length=0);o=he(c,n)}return Je(b,e,o),!0}),(function(a,b,e){if(null!=(b=Ze(b,e))){var t=!1;if(t=void 0!==t&&t,ge){if(t&&/(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])/.test(b))throw Error("Found an unpaired surrogate");b=(de||(de=new TextEncoder)).encode(b)}else{for(var n=0,g=new Uint8Array(3*b.length),r=0;r<b.length;r++){var o=b.charCodeAt(r);if(128>o)g[n++]=o;else{if(2048>o)g[n++]=o>>6|192;else{if(55296<=o&&57343>=o){if(56319>=o&&r<b.length){var l=b.charCodeAt(++r);if(56320<=l&&57343>=l){o=1024*(o-55296)+l-56320+65536,g[n++]=o>>18|240,g[n++]=o>>12&63|128,g[n++]=o>>6&63|128,g[n++]=63&o|128;continue}r--}if(t)throw Error("Found an unpaired surrogate");o=65533}g[n++]=o>>12|224,g[n++]=o>>6&63|128}g[n++]=63&o|128}}b=n===g.length?g:g.subarray(0,n)}Ee(a.h,8*e+2),Ee(a.h,b.length),Ne(a,a.h.end()),Ne(a,b)}})),qt=Gt((function(a,b,e,t,n){if(2!==a.i)return!1;b=st(b,e,t),e=a.h.j,t=Ie(a.h)>>>0;var g=a.h.h+t,r=g-e;if(0>=r&&(a.h.j=g,n(b,a,void 0,void 0,void 0),r=g-a.h.h),r)throw Error("Message parsing ended unexpectedly. Expected to read "+t+" bytes, instead read "+(t-r)+" bytes, either the data ended unexpectedly or the message misreported its own length");return a.h.h=g,a.h.j=e,!0}),(function(a,b,e,t,n){if(null!=(b=ot(b,t,e)))for(t=0;t<b.length;t++){var g=a;Ee(g.h,8*e+2);var r=g.h.end();Ne(g,r),r.push(g.i),g=r,n(b[t],a),r=a;var o=g.pop();for(o=r.i+r.h.length()-o;127<o;)g.push(127&o|128),o>>>=7,r.i++;g.push(o),r.i++}}));function Qt(a){return function(b,e){e:{if(Fe.length){var t=Fe.pop();t.setOptions(e),ke(t.h,b,e),b=t}else b=new Re(b,e);try{var n=jt(a),g=Wt(new n.P,b,n);break e}finally{(n=b.h).i=null,n.m=!1,n.l=0,n.j=0,n.h=0,n.S=!1,b.l=-1,b.i=-1,100>Fe.length&&Fe.push(b)}g=void 0}return g}}function Zt(a){return function(){var b=new _e;Vt(this,b,zt(a)),Ne(b,b.h.end());for(var e=new Uint8Array(b.i),t=b.j,n=t.length,g=0,r=0;r<n;r++){var o=t[r];e.set(o,g),g+=o.length}return b.j=[e],e}}function Jt(a){xt.call(this,a)}k(Jt,xt);var en=[Jt,1,Xt,2,Ht,3,Yt,4,Yt];function tn(a){xt.call(this,a,-1,nn)}Jt.prototype.l=Zt(en),k(tn,xt),tn.prototype.addClassification=function(a,b){return st(this,1,Jt,a,b),this};var nn=[1],rn=Qt([tn,1,qt,en]);function on(a){xt.call(this,a)}k(on,xt);var an=[on,1,Ht,2,Ht,3,Ht,4,Ht,5,Ht];function sn(a){xt.call(this,a,-1,un)}on.prototype.l=Zt(an),k(sn,xt);var un=[1],ln=Qt([sn,1,qt,an]);function hn(a){xt.call(this,a)}k(hn,xt);var cn=[hn,1,Ht,2,Ht,3,Ht,4,Ht,5,Ht,6,Kt],dn=Qt(cn);function pn(a,b,e){if(e=a.createShader(0===e?a.VERTEX_SHADER:a.FRAGMENT_SHADER),a.shaderSource(e,b),a.compileShader(e),!a.getShaderParameter(e,a.COMPILE_STATUS))throw Error("Could not compile WebGL shader.\n\n"+a.getShaderInfoLog(e));return e}function fn(a){return ot(a,Jt,1).map((function(b){var e=Ze(b,1);return{index:null==e?0:e,qa:lt(b,2),label:null!=Ze(b,3)?ut(Ze(b,3),""):void 0,displayName:null!=Ze(b,4)?ut(Ze(b,4),""):void 0}}))}function mn(a){return{x:lt(a,1),y:lt(a,2),z:lt(a,3),visibility:null!=nt(a,4)?lt(a,4):void 0}}function gn(a){return ot(ln(a),on,1).map(mn)}function bn(a,b){this.i=a,this.h=b,this.m=0}function yn(a,b,e){return function(a,b){var e=a.h;if(void 0===a.s){var t=pn(e,"\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }",0),n=pn(e,"\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D sampler0;\n  void main(){\n    gl_FragColor = texture2D(sampler0, vTex);\n  }",1),g=e.createProgram();if(e.attachShader(g,t),e.attachShader(g,n),e.linkProgram(g),!e.getProgramParameter(g,e.LINK_STATUS))throw Error("Could not compile WebGL program.\n\n"+e.getProgramInfoLog(g));t=a.s=g,e.useProgram(t),n=e.getUniformLocation(t,"sampler0"),a.l={O:e.getAttribLocation(t,"aVertex"),N:e.getAttribLocation(t,"aTex"),ya:n},a.v=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,a.v),e.enableVertexAttribArray(a.l.O),e.vertexAttribPointer(a.l.O,2,e.FLOAT,!1,0,0),e.bufferData(e.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,null),a.u=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,a.u),e.enableVertexAttribArray(a.l.N),e.vertexAttribPointer(a.l.N,2,e.FLOAT,!1,0,0),e.bufferData(e.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,null),e.uniform1i(n,0)}t=a.l,e.useProgram(a.s),e.canvas.width=b.width,e.canvas.height=b.height,e.viewport(0,0,b.width,b.height),e.activeTexture(e.TEXTURE0),a.i.bindTexture2d(b.glName),e.enableVertexAttribArray(t.O),e.bindBuffer(e.ARRAY_BUFFER,a.v),e.vertexAttribPointer(t.O,2,e.FLOAT,!1,0,0),e.enableVertexAttribArray(t.N),e.bindBuffer(e.ARRAY_BUFFER,a.u),e.vertexAttribPointer(t.N,2,e.FLOAT,!1,0,0),e.bindFramebuffer(e.DRAW_FRAMEBUFFER?e.DRAW_FRAMEBUFFER:e.FRAMEBUFFER,null),e.clearColor(0,0,0,0),e.clear(e.COLOR_BUFFER_BIT),e.colorMask(!0,!0,!0,!0),e.drawArrays(e.TRIANGLE_FAN,0,4),e.disableVertexAttribArray(t.O),e.disableVertexAttribArray(t.N),e.bindBuffer(e.ARRAY_BUFFER,null),a.i.bindTexture2d(0)}(a,b),"function"==typeof a.h.canvas.transferToImageBitmap?Promise.resolve(a.h.canvas.transferToImageBitmap()):e?Promise.resolve(a.h.canvas):"function"==typeof createImageBitmap?createImageBitmap(a.h.canvas):(void 0===a.j&&(a.j=document.createElement("canvas")),new Promise((function(e){a.j.height=a.h.canvas.height,a.j.width=a.h.canvas.width,a.j.getContext("2d",{}).drawImage(a.h.canvas,0,0,a.h.canvas.width,a.h.canvas.height),e(a.j)})))}function xn(a){this.h=a}hn.prototype.l=Zt(cn);var vn=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function wn(a,b){return b+a}function kn(a,b){window[a]=b}function Sn(a){if(this.h=a,this.listeners={},this.l={},this.L={},this.s={},this.v={},this.M=this.u=this.ga=!0,this.I=Promise.resolve(),this.fa="",this.D={},this.locateFile=a&&a.locateFile||wn,"object"==typeof window)var b=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else{if("undefined"==typeof location)throw Error("solutions can only be loaded on a web page or in a web worker");b=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/"}if(this.ha=b,a.options)for(var e=(b=c(Object.keys(a.options))).next();!e.done;e=b.next()){e=e.value;var t=a.options[e].default;void 0!==t&&(this.l[e]="function"==typeof t?t():t)}}function In(a){var b,e,t,n,g,r,o,l,h,c,f;return P((function(p){switch(p.h){case 1:return a.ga?(b=void 0===a.h.files?[]:"function"==typeof a.h.files?a.h.files(a.l):a.h.files,O(p,P((function(a){switch(a.h){case 1:return a.s=2,O(a,WebAssembly.instantiate(vn),4);case 4:a.h=3,a.s=0;break;case 2:return a.s=0,a.l=null,a.return(!1);case 3:return a.return(!0)}})),2)):p.return();case 2:if(e=p.i,"object"==typeof window)return kn("createMediapipeSolutionsWasm",{locateFile:a.locateFile}),kn("createMediapipeSolutionsPackedAssets",{locateFile:a.locateFile}),r=b.filter((function(e){return void 0!==e.data})),o=b.filter((function(e){return void 0===e.data})),l=Promise.all(r.map((function(e){var q=Cn(a,e.url);if(void 0!==e.path){var t=e.path;q=q.then((function(e){return a.overrideFile(t,e),Promise.resolve(e)}))}return q}))),h=Promise.all(o.map((function(t){return void 0===t.simd||t.simd&&e||!t.simd&&!e?function(a){var b=document.createElement("script");return b.setAttribute("src",a),b.setAttribute("crossorigin","anonymous"),new Promise((function(e){b.addEventListener("load",(function(){e()}),!1),b.addEventListener("error",(function(){e()}),!1),document.body.appendChild(b)}))}(a.locateFile(t.url,a.ha)):Promise.resolve()}))).then((function(){var e,q,t;return P((function(n){if(1==n.h)return e=window.createMediapipeSolutionsWasm,q=window.createMediapipeSolutionsPackedAssets,t=a,O(n,e(q),2);t.i=n.i,n.h=0}))})),c=P((function(e){return a.h.graph&&a.h.graph.url?e=O(e,Cn(a,a.h.graph.url),0):(e.h=0,e=void 0),e})),O(p,Promise.all([h,l,c]),7);if("function"!=typeof importScripts)throw Error("solutions can only be loaded on a web page or in a web worker");return t=b.filter((function(t){return void 0===t.simd||t.simd&&e||!t.simd&&!e})).map((function(e){return a.locateFile(e.url,a.ha)})),importScripts.apply(null,d(t)),n=a,O(p,createMediapipeSolutionsWasm(Module),6);case 6:n.i=p.i,a.m=new OffscreenCanvas(1,1),a.i.canvas=a.m,g=a.i.GL.createContext(a.m,{antialias:!1,alpha:!1,va:"undefined"!=typeof WebGL2RenderingContext?2:1}),a.i.GL.makeContextCurrent(g),p.h=4;break;case 7:if(a.m=document.createElement("canvas"),!(f=a.m.getContext("webgl2",{}))&&!(f=a.m.getContext("webgl",{})))return alert("Failed to create WebGL canvas context when passing video frame."),p.return();a.K=f,a.i.canvas=a.m,a.i.createContext(a.m,!0,!0,{});case 4:a.j=new a.i.SolutionWasm,a.ga=!1,p.h=0}}))}function Cn(a,b){var e,t;return P((function(n){return b in a.L?n.return(a.L[b]):(e=a.locateFile(b,""),t=fetch(e).then((function(g){return g.arrayBuffer()})),a.L[b]=t,n.return(t))}))}function On(a,b,e){var t,n,g,r,o,l,h,d,f,p,m,q,y,x;return P((function(v){switch(v.h){case 1:if(!e)return v.return(b);for(t={},n=0,g=c(Object.keys(e)),r=g.next();!r.done;r=g.next())o=r.value,"string"!=typeof(l=e[o])&&"texture"===l.type&&void 0!==b[l.stream]&&++n;1<n&&(a.M=!1),h=c(Object.keys(e)),r=h.next();case 2:if(r.done){v.h=4;break}if(d=r.value,"string"==typeof(f=e[d]))return y=t,x=d,O(v,function(a,b,e){var t;return P((function(n){return"number"==typeof e||e instanceof Uint8Array||e instanceof a.i.Uint8BlobList?n.return(e):e instanceof a.i.Texture2dDataOut?((t=a.v[b])||(t=new bn(a.i,a.K),a.v[b]=t),n.return(yn(t,e,a.M))):n.return(void 0)}))}(a,d,b[f]),14);if(p=b[f.stream],"detection_list"===f.type){if(p){for(var w=p.getRectList(),k=p.getLandmarksList(),S=p.getClassificationsList(),u=[],I=0;I<w.size();++I){var C=dn(w.get(I)),A=void 0;A=void 0===A?0:A,C={la:{sa:lt(C,1),ta:lt(C,2),height:lt(C,3),width:lt(C,4),rotation:lt(C,5,0),pa:ut(Ze(C,6),A)},ea:gn(k.get(I)),ba:fn(rn(S.get(I)))},u.push(C)}w=u}else w=[];t[d]=w,v.h=7;break}if("proto_list"===f.type){if(p){for(w=Array(p.size()),k=0;k<p.size();k++)w[k]=p.get(k);p.delete()}else w=[];t[d]=w,v.h=7;break}if(void 0===p){v.h=3;break}if("float_list"===f.type){t[d]=p,v.h=7;break}if("proto"===f.type){t[d]=p,v.h=7;break}if("texture"!==f.type)throw Error("Unknown output config type: '"+f.type+"'");return(m=a.v[d])||(m=new bn(a.i,a.K),a.v[d]=m),O(v,yn(m,p,a.M),13);case 13:q=v.i,t[d]=q;case 7:f.transform&&t[d]&&(t[d]=f.transform(t[d])),v.h=3;break;case 14:y[x]=v.i;case 3:r=h.next(),v.h=2;break;case 4:return v.return(t)}}))}function An(a,b){for(var e=b.name||"$",t=[].concat(d(b.wants)),n=new a.i.StringList,g=c(b.wants),r=g.next();!r.done;r=g.next())n.push_back(r.value);g=a.i.PacketListener.implement({onResults:function(n){for(var r={},o=0;o<b.wants.length;++o)r[t[o]]=n.get(o);var l=a.listeners[e];l&&(a.I=On(a,r,b.outs).then((function(e){e=l(e);for(var p=0;p<b.wants.length;++p){var n=r[t[p]];"object"==typeof n&&n.hasOwnProperty&&n.hasOwnProperty("delete")&&n.delete()}e&&(a.I=e)})))}}),a.j.attachMultiListener(n,g),n.delete()}function Tn(a){switch(void 0===a&&(a=0),a){case 1:return"pose_landmark_full.tflite";case 2:return"pose_landmark_heavy.tflite";default:return"pose_landmark_lite.tflite"}}function En(a){var b=this;a=a||{},this.h=new Sn({locateFile:a.locateFile,files:function(e){return[{url:"pose_solution_packed_assets_loader.js"},{simd:!1,url:"pose_solution_wasm_bin.js"},{simd:!0,url:"pose_solution_simd_wasm_bin.js"},{data:!0,url:Tn(e.modelComplexity)}]},graph:{url:"pose_web.binarypb"},listeners:[{wants:["pose_landmarks","world_landmarks","segmentation_mask","image_transformed"],outs:{image:{type:"texture",stream:"image_transformed"},poseLandmarks:{type:"proto",stream:"pose_landmarks",transform:gn},poseWorldLandmarks:{type:"proto",stream:"world_landmarks",transform:gn},segmentationMask:{type:"texture",stream:"segmentation_mask"}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"object"==typeof window&&void 0!==window.navigator&&("iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document)},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},modelComplexity:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorModelComplexity",fieldName:"int_value"},onChange:function(e){var t,n,g;return P((function(r){return 1==r.h?(t=Tn(e),n="third_party/mediapipe/modules/pose_landmark/"+t,O(r,Cn(b.h,t),2)):(g=r.i,b.h.overrideFile(n,g),r.return(!0))}))}},smoothLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothLandmarks",fieldName:"bool_value"}},enableSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorEnableSegmentation",fieldName:"bool_value"}},smoothSegmentation:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorSmoothSegmentation",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"poselandmarkgpu__posedetectiongpu__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"poselandmarkgpu__poselandmarkbyroigpu__tensorstoposelandmarksandsegmentation__ThresholdingCalculator",fieldName:"threshold"}}}})}(t=Sn.prototype).close=function(){return this.j&&this.j.delete(),Promise.resolve()},t.reset=function(){var a=this;return P((function(b){a.j&&(a.j.reset(),a.s={},a.v={}),b.h=0}))},t.setOptions=function(a,b){var e=this;if(b=b||this.h.options){for(var t=[],n=[],g={},r=c(Object.keys(a)),o=r.next();!o.done;g={X:g.X,Y:g.Y},o=r.next())if(!((o=o.value)in this.l)||this.l[o]!==a[o]){this.l[o]=a[o];var l=b[o];void 0!==l&&(l.onChange&&(g.X=l.onChange,g.Y=a[o],t.push(function(t){return function(){return P((function(n){if(1==n.h)return O(n,t.X(t.Y),2);!0===n.i&&(e.u=!0),n.h=0}))}}(g))),l.graphOptionXref&&(o=Object.assign({},{calculatorName:"",calculatorIndex:0},l.graphOptionXref,{valueNumber:1===l.type?a[o]:0,valueBoolean:0===l.type&&a[o],valueString:2===l.type?a[o]:""}),n.push(o)))}0===t.length&&0===n.length||(this.u=!0,this.H=(void 0===this.H?[]:this.H).concat(n),this.F=(void 0===this.F?[]:this.F).concat(t))}},t.initialize=function(){var a=this;return P((function(b){return 1==b.h?O(b,In(a),2):3!=b.h?O(b,function(a){var b,e,t,n,g,r,o,l;return P((function(h){if(1==h.h)return a.h.graph&&a.h.graph.url&&a.fa===a.h.graph.url?h.return():(a.u=!0,a.h.graph&&a.h.graph.url?(a.fa=a.h.graph.url,O(h,Cn(a,a.h.graph.url),3)):void(h.h=2));for(2!=h.h&&(b=h.i,a.j.loadGraph(b)),e=c(Object.keys(a.D)),t=e.next();!t.done;t=e.next())n=t.value,a.j.overrideFile(n,a.D[n]);if(a.D={},a.h.listeners)for(g=c(a.h.listeners),r=g.next();!r.done;r=g.next())o=r.value,An(a,o);l=a.l,a.l={},a.setOptions(l),h.h=0}))}(a),3):O(b,function(a){var b,e,t,g,n,r;return P((function(o){switch(o.h){case 1:if(!a.u)return o.return();if(!a.F){o.h=2;break}b=c(a.F),e=b.next();case 3:if(e.done){o.h=5;break}return O(o,(0,e.value)(),4);case 4:e=b.next(),o.h=3;break;case 5:a.F=void 0;case 2:if(a.H){for(t=new a.i.GraphOptionChangeRequestList,g=c(a.H),n=g.next();!n.done;n=g.next())r=n.value,t.push_back(r);a.j.changeOptions(t),t.delete(),a.H=void 0}a.u=!1,o.h=0}}))}(a),0)}))},t.overrideFile=function(a,b){this.j?this.j.overrideFile(a,b):this.D[a]=b},t.clearOverriddenFiles=function(){this.D={},this.j&&this.j.clearOverriddenFiles()},t.send=function(a,b){var e,t,g,n,r,o,l,h,d,f=this;return P((function(p){switch(p.h){case 1:return f.h.inputs?(e=1e3*(null==b?performance.now():b),O(p,f.I,2)):p.return();case 2:return O(p,f.initialize(),3);case 3:for(t=new f.i.PacketDataList,g=c(Object.keys(a)),n=g.next();!n.done;n=g.next())if(r=n.value,o=f.h.inputs[r]){e:{var m=a[r];switch(o.type){case"video":var q=f.s[o.stream];if(q||(q=new bn(f.i,f.K),f.s[o.stream]=q),0===q.m&&(q.m=q.i.createTexture()),"undefined"!=typeof HTMLVideoElement&&m instanceof HTMLVideoElement)var y=m.videoWidth,x=m.videoHeight;else"undefined"!=typeof HTMLImageElement&&m instanceof HTMLImageElement?(y=m.naturalWidth,x=m.naturalHeight):(y=m.width,x=m.height);x={glName:q.m,width:y,height:x},(y=q.h).canvas.width=x.width,y.canvas.height=x.height,y.activeTexture(y.TEXTURE0),q.i.bindTexture2d(q.m),y.texImage2D(y.TEXTURE_2D,0,y.RGBA,y.RGBA,y.UNSIGNED_BYTE,m),q.i.bindTexture2d(0),q=x;break e;case"detections":for((q=f.s[o.stream])||(q=new xn(f.i),f.s[o.stream]=q),q.data||(q.data=new q.h.DetectionListData),q.data.reset(m.length),x=0;x<m.length;++x){y=m[x];var v=q.data,w=v.setBoundingBox,k=x,S=y.la,u=new hn;if(at(u,1,S.sa),at(u,2,S.ta),at(u,3,S.height),at(u,4,S.width),at(u,5,S.rotation),Je(u,6,S.pa),S=u.l(),w.call(v,k,S),y.ea)for(v=0;v<y.ea.length;++v){u=y.ea[v],k=(w=q.data).addNormalizedLandmark,S=x,u=Object.assign({},u,{visibility:u.visibility?u.visibility:0});var I=new on;at(I,1,u.x),at(I,2,u.y),at(I,3,u.z),u.visibility&&at(I,4,u.visibility),u=I.l(),k.call(w,S,u)}if(y.ba)for(v=0;v<y.ba.length;++v)k=(w=q.data).addClassification,S=x,u=y.ba[v],at(I=new Jt,2,u.qa),u.index&&Je(I,1,u.index),u.label&&Je(I,3,u.label),u.displayName&&Je(I,4,u.displayName),u=I.l(),k.call(w,S,u)}q=q.data;break e;default:q={}}}switch(l=q,h=o.stream,o.type){case"video":t.pushTexture2d(Object.assign({},l,{stream:h,timestamp:e}));break;case"detections":(d=l).stream=h,d.timestamp=e,t.pushDetectionList(d);break;default:throw Error("Unknown input config type: '"+o.type+"'")}}return f.j.send(t),O(p,f.I,4);case 4:t.delete(),p.h=0}}))},t.onResults=function(a,b){this.listeners[b||"$"]=a},_("Solution",Sn),_("OptionType",{BOOL:0,NUMBER:1,ua:2,0:"BOOL",1:"NUMBER",2:"STRING"}),(t=En.prototype).reset=function(){this.h.reset()},t.close=function(){return this.h.close(),Promise.resolve()},t.onResults=function(a){this.h.onResults(a)},t.initialize=function(){var a=this;return P((function(b){return O(b,a.h.initialize(),0)}))},t.send=function(a,b){var e=this;return P((function(t){return O(t,e.h.send(a,b),0)}))},t.setOptions=function(a){this.h.setOptions(a)},_("Pose",En),_("POSE_CONNECTIONS",[[0,1],[1,2],[2,3],[3,7],[0,4],[4,5],[5,6],[6,8],[9,10],[11,12],[11,13],[13,15],[15,17],[15,19],[15,21],[17,19],[12,14],[14,16],[16,18],[16,20],[16,22],[18,20],[11,23],[12,24],[23,24],[23,25],[24,26],[25,27],[26,28],[27,29],[28,30],[29,31],[30,32],[27,31],[28,32]]),_("POSE_LANDMARKS",{NOSE:0,LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,LEFT_EAR:7,RIGHT_EAR:8,LEFT_RIGHT:9,RIGHT_LEFT:10,LEFT_SHOULDER:11,RIGHT_SHOULDER:12,LEFT_ELBOW:13,RIGHT_ELBOW:14,LEFT_WRIST:15,RIGHT_WRIST:16,LEFT_PINKY:17,RIGHT_PINKY:18,LEFT_INDEX:19,RIGHT_INDEX:20,LEFT_THUMB:21,RIGHT_THUMB:22,LEFT_HIP:23,RIGHT_HIP:24,LEFT_KNEE:25,RIGHT_KNEE:26,LEFT_ANKLE:27,RIGHT_ANKLE:28,LEFT_HEEL:29,RIGHT_HEEL:30,LEFT_FOOT_INDEX:31,RIGHT_FOOT_INDEX:32}),_("POSE_LANDMARKS_LEFT",{LEFT_EYE_INNER:1,LEFT_EYE:2,LEFT_EYE_OUTER:3,LEFT_EAR:7,LEFT_RIGHT:9,LEFT_SHOULDER:11,LEFT_ELBOW:13,LEFT_WRIST:15,LEFT_PINKY:17,LEFT_INDEX:19,LEFT_THUMB:21,LEFT_HIP:23,LEFT_KNEE:25,LEFT_ANKLE:27,LEFT_HEEL:29,LEFT_FOOT_INDEX:31}),_("POSE_LANDMARKS_RIGHT",{RIGHT_EYE_INNER:4,RIGHT_EYE:5,RIGHT_EYE_OUTER:6,RIGHT_EAR:8,RIGHT_LEFT:10,RIGHT_SHOULDER:12,RIGHT_ELBOW:14,RIGHT_WRIST:16,RIGHT_PINKY:18,RIGHT_INDEX:20,RIGHT_THUMB:22,RIGHT_HIP:24,RIGHT_KNEE:26,RIGHT_ANKLE:28,RIGHT_HEEL:30,RIGHT_FOOT_INDEX:32}),_("POSE_LANDMARKS_NEUTRAL",{NOSE:0}),_("VERSION","0.5.1675469404")}).call(this)}).call(this,n(56))}}]);